\chapter{Atores Remotos com o Padrão AMQP}
\index{Atores Remotos com AMQP}
\label{cap:atores_remotos_amqp}

Apresentamos neste capítulo nossa implementação de atores remotos que utilizam
o padrão AMQP como meio de transporte para troca de mensagens. Nossa 
implementação utiliza a implementação de atores remotos do projeto Akka apresentada
no capítulo \ref{cap:atores_akka}. Na seção \ref{sec:atores_remotos_amqp:novos_componentes}
apresentamos os novos componentes que criamos dentro da estrutura do Akka e
na seção \ref{sec:atores_remotos_amqp:integracao_akka} como fizemos a integração dos
novos componentes com a implementação existente. Para concluir, apresentamos
na seção \ref{sec:atores_remotos_amqp:analise_de_desempenho} uma comparação de desempenho entre nossa implementação e a implementação original do projeto Akka.

\section{Novos componentes}
\index{Atores Remotos com AMQP!componentes}
\label{sec:atores_remotos_amqp:novos_componentes}

A implementação de atores remotos do projeto Akka define uma camada intermediária
que desacopla a definição dos componentes para transporte das mensagens a atores
remotos, como apresentado na seção \ref{sec:atores_remotos_akka}. 

Para viabilizar o envio de mensagens remotas via \english{broker} AMQP, tivemos
que criar novos componentes para a camada de implementação com base nas classes
e \english{traits} que definem a interface remota (figura \ref{fig:remote-actor-colaboracao}).
Utilizamos a estrutura apresentada no capítulo \ref{cap:estrutura-troca-mensagens-amqp} 
como suporte para a implementação dos novos componentes do Akka. 
Os novos componentes são:

\begin{itemize}
	\item \lstinline$AMQPRemoteServer$: É uma classe utilizada no lado do servidor onde
	estão os atores remotamente acessíveis. Essa classe implementa os métodos abstrados
	de um \lstinline$MessageHandler$ e é responsável pelo recebimento,
	desseriação e encaminhamento das mensagens para os atores que estão em seu registro. 
	A classe também é responsável por enviar eventuais mensagens de resposta para os 
	remetentes, seja como consequência de envios feitos via \lstinline$!!$ e \lstinline$!!!$, 
	ou ainda mensagens para atores supervisores. Tanto no recebimento como no envio de mensagens 
	a classe utiliza um módulo separado para seriação e desseriação de mensagens. Existe um 
	relacionamento bidirecional um para um entre um \lstinline$AMQPRemoteServer$ e uma ponte 
	servidora;
			
	\item \lstinline$AMQPRemoteServerModule$: É uma \english{trait} que extende 
	a \english{trait} \lstinline$RemoteServerModule$ e define um nó onde atores
	são registrados para ficarem acessíveis remotamente. Essa implementação 
	mantém o registro desses atores e possui uma relação 
	bidirecional um para um com um \lstinline$AMQPRemoteServer$. As mensagens recebidas pelo 
	\lstinline$AMQPRemoteServer$ são encaminhadas para os atores residentes nesse módulo;

	\item \lstinline$AMQPRemoteClient$:	É uma classe utilizada no lado do cliente
	onde ficam os \english{proxies} dos atores remotos. A classe mantém o registro de 
	atores que são supervisores de atores remotos, além de também manter um registro para 
	resultados futuros. Tal como a classe \lstinline$AMQPRemoteServer$, essa classe também 
	implementa os métodos abstratos de um \lstinline$MessageHandler$ e é também é responsável
	pelo recebimento, desseriação e encaminhamento das mensagens para os atores ou
	resultados futuros que estão em seu registro. O principal papel da classe é
	fazer o envio das mensagens para o \english{broker} AMQP. 
	Existe uma relação bidirecional um para um entre um \lstinline$AMQPRemoteClient$
	e uma ponte cliente. A classe ainda é responsável por manter um identificador
	que deve ser único entre todos os clientes do mesmo servidor remoto. Esse identificador
	é utilizado na criação da instância da ponte cliente;
	
	\item \lstinline$AMQPRemoteClientModule$: É uma \english{trait} que extende
	a \english{trait} \lstinline$RemoteClientModule$. Essa é uma \english{trait}
	que tem um papel complementar a \lstinline$AMQPRemoteServerModule$ e seu
	papel principal é definir uma interface para envios de mensagens a atores
	remotos via \lstinline$AMQPRemoteClient$. Ademais, a \english{trait}
	mantém ainda um registro de \lstinline$AMQPRemoteClient$, que são utilizados
	para enviar as mensagens para seus respectivos nós remotos, já que
	uma aplicação cliente pode interagir com diversos atores em diferentes nós;

	\item \lstinline$AMQPRemoteSupport$: É a implementação que tornamos acessível 
	via \lstinline$Actor.remote$. Essa classe é responsável por concentrar as 
	responsabilidades definidas nos módulos acima listados para prover o suporte
	remoto via \english{broker} AMQP.
\end{itemize}

O relacionamento entre os novos componentes com as pontes AMQP e com as classes do
Akka são mostrados na figura \ref{fig:atores-remotos-amqp-colaboracao}.

%% mostrar código aonde?!
\begin{figure}[!h]
	\centering
	\includegraphics[scale=.60]{remote-actor-amqp-colaboracao} 
 	\caption{Relacionamento entre os componentes para atores remotos com AMQP.}
  	\label{fig:atores-remotos-amqp-colaboracao}
\end{figure}

A definição das \english{traits} para suporte a atores remotos do Akka define assinaturas
de métodos baseadas em \english{host} e porta. Para não quebrar a compatibilidade em nossas
implementações e nem alterar a interface dos métodos, optamos por criar internamente 
o nome do nó com base nos valores informados para \english{host} e porta. O padrão
utilizado é \lstinline$host@porta$. 

Como mencionado seção \ref{sec:atores_locais}, \lstinline$ActorRef$s
guardam o endereço do local onde o ator foi criado. Pelo fato de não haver associação
entre o endereço definido e uma \english{socket}, e de os valores para \english{host}
e porta serem recebidos no construtor da classe, optamos por manter a compatibilidade e
não mudar nem o construtor e nem o atributo. Em nossa implementação, o valor
do atributo \lstinline$homeAddress$ não é utilizado.

Pelo fato do projeto Akka possuir um desenvolvimento ativo, acreditamos que existe
uma grande possibilidade de haver uma mudança na interface dos componentes
do módulo de atores remotos, de modo que haja um desacomplamento entre sua interface
e as implementações da camada de transporte.

\section{Integração com o Akka}
\index{Atores Remotos com AMQP!integração Akka}
\label{sec:atores_remotos_amqp:integracao_akka}

Uma vez definidos os componentes dentro da estrutura do Akka, é necessário que 
a biblioteca do Akka faça uso deles, de modo que a instância referenciada por
\lstinline$Actor.remote$ seja uma instância de \lstinline$AMQPRemoteSupport$.

\subsection{Alterações no arquivo akka.conf}

Além de alterar o valor para a camada de suporte para atores remotos no arquivo 
\lstinline$akka.conf$, optamos por adicionar novas propriedades para a configuração do 
suporte que implementamos, como os dados
para conexão com o \english{broker}, a política de armazenamento e de compartilhamento
de conexões entre canais. Uma outra propriedade importante que adicionamos foi a 
definição do identificador a ser utilizado na criação de diferentes 
\lstinline$AMQPRemoteClient$s (e consequentemente de \lstinline$ClientAMQPBridge$s). 
O novo valor para a camada de suporte para atores remotos e as novas propriedades são 
listadas a seguir:

\begin{lstlisting}[frame=none, numbers=none]
remote {
	...
	layer = "akka.remote.amqp.AMQPRemoteSupport"
	amqp {
		policy {
			storage {        	 
				mode = "EXCLUSIVE_PERSISTENT"
				client_id {
					suffix = "MYPLACE"
        	 	}
        	}
        	connection {
            	server = "ONE_CONN_PER_NODE"
            	client = "ONE_CONN_PER_NODE"
			}
		}
		broker {
			host = "192.168.0.121"
			virtualhost = "/actor_host"
			username = "actor_admin"
			password = "actor_admin"
		}
	}
	...
}
\end{lstlisting}

\subsubsection{Restrições}

Pelo fato arquivo \lstinline$akka.conf$ ser único por JVM, a maneira pelo qual
é feita a configuração das propriedades remotas impõe algumas restrições.
Com o Akka em execução em uma JVM, podemos criar diversos servidores remotos,
cada um com um nome de nó diferente. Também podemos criar clientes
remotos, um para cada servidor remoto. Poderíamos ainda ter em uma JVM
uma combinação dos dois cenários, com servidores remotos e clientes para
servidores remotos. 

Todos os clientes remotos que forem criados na JVM, independente
do nome do servidor remoto utilizam o mesmo identificador de cliente.
Contudo, essa restrição não impedimende a criação dos objetos
no \english{broker}. Para exemplificar, podemos analizar o
caso onde dois clientes remotos são criados em uma JVM para os
servidores remotos cujos nomes são \lstinline$node1$ e \lstinline$node2$.
Os objetos criados pelos primeiro cliente remoto terão o sufixo
\lstinline$client.node1.<id>$ e \lstinline$client.node2.<id>$.	
Um outro detalhe importante é que, pelo fato de classe 
\lstinline$AMQPRemoteClientModule$ manter um registro dos clientes remotos, 
não há a possibilidade de na mesma JVM ser criado mais de uma instância de 
\lstinline$AMQPRemoteClient$ para um mesmo servidor remoto.

As propriedades para configuração da política de armazenamento
são utilizadas para ambos os servidores e clientes remotos. Configurações 
divergentes entre JVMs podem levar aos seguintes cenários:

\begin{enumerate}
	\item A JVM onde foi iniciado um servidor remoto utiliza uma configuração
	persistente e alguma das JVMs com um cliente remoto define uma configuração
	transiente: Esse não é um caso muito problemático, já que os objetos criados
	pelo servidor não dependem dos objetos criados pelos clientes. Como os objetos 
	definidos como transientes só são removidos quando o \english{message broker}
	é desligado, o problema se limita a perda de eventuais mensagens que 
	ainda não foram consumidas e estavam na fila;
	
	\item Um cenário oposto ao anterior, onde o servidor remoto possui uma configuração
	transiente e algum de seus clientes uma configuração persistente: Esse é 
	um cenário mais problemático, já que quando a \english{exchange} do servidor
	é removida todas as suas associações também são removidas, porém as filas persistentes
	não. Esse cenário deve ser analizado de duas ópticas diferentes: \entry{(i)} 
	Óptica da criação dos objetos:
	como a biblioteca Java do RabbitMQ faz uma verificação da existência de um objeto
	antes de tentar fazer a sua criação (\ref{sec:entidades-via-broker-amqp-gerenciamento-conexoes}),
	logo não há problemas. A associação da fila persistente com a \english{exchange}
	recém criada acontecerá durante a execução da inicialização do módulo do cliente remoto;
	\entry{(ii)} Óptica é a da aplicação: Eventuais mensagens não consumidas pelo servidor
	remoto são perdidas.	
\end{enumerate}

As configurações relacionadas ao compartilhamento da conexão entre os canais de leitura e
escrita são definidas separadamente para os clientes e servidores remotos. A divergência
nas configurações entre um cliente remoto em um nó e um servidor remoto em outro nó
pode acontecer sem problemas, já que o impacto será no volume de dados trafegado
na conexão.

\subsection{Segurança}

Com o intuito de previnir conexões em servidores remotos de clientes não autorizados,
o Akka deixa como opção de configuração exigir que somente clientes autenticados
possam interagir com os atores. A autenticação é feita via \english{secure cookie}. O \english{secure cookie}
é definido no arquivo \lstinline$akka.conf$ na seção \lstinline$remote$. O uso de 
autenticação é opcional e deve ser exigido, quando necessário, pelo servidor remoto. A propriedade
utilizada para forçar o uso de \english{cookie} na comunicação é definida dentro de
\lstinline$remote { server { ... } }$.

O valor do \english{cookie} é parte do protocolo remoto definido no Akka, mostrado
na listagem \ref{lst:proto-remote-message} no capítulo \ref{cap:atores_akka}. Como
o uso do \english{cookie} é definido no protocolo remoto, 
mantemos o suporte na nossa implementação. Mensagens oriundas de clientes
que não se autenticarem nos servidores remotos, não são processadas e o
cliente remoto remetente recebe uma mensagem de resposta com indicando a 
necessidade a autenticação.

Com o uso das filas definidas no \english{broker} como repositório 
intermediário das mensagens (salvo no caso de filas com acesso
exclusivo), qualquer entidade que possua os dados necessários para acessar
o \english{virtual host} onde estão criadas as filas pode registrar outros
consumidores. Uma fila com mais de um consumidor pode ser interessante
quando se deseja fazer um monitoramento do volume ou até do conteúdo das
mensagens. No caso de haver mais de um consumidor em uma fila, uma cópia da mensagem
é entregue a cada consumidor. Não é possível, portanto, um consumidor
mal intencionado ``roubar'' ou mesmo alterar a integridade das mensagens.

Com o uso de um \english{broker} AMQP, a segurança depende muito de 
quem possui as informações para acesso ao \english{virtual host} onde
estão criadas as filas e \english{exchanges}.

\subsection{Alterações no protocolo}

Para que o servidor remoto pudesse identificar qual o remetente de uma mensagem recebida,
foi necessária uma pequena alteração no protocolo remoto. A implementação de transporte
feita com o JBoss Netty consegue identificar na \english{socket} qual o endereço
do a entidade remota que está se conectada. O protocolo utilizado para definir uma mensagem
remota passa a incluir um parâmetro não mandatório para que o identificador do cliente
possa ser identificado. O protocolo com a alteração é mostrado na listagem 
\ref{lst:proto-remote-message-amqp}. Essa alteração implicou em
alterações no objeto \lstinline$RemoteActorSerialization$. Esse objeto é o responsável por 
fabricar uma instância com as informações a serem seriadas. O método 
\lstinline$createRemoteMessageProtocolBuilder$ foi sobrecarregado e passou
a receber o identificador do cliente como parâmetro. 

A alteração apresentada na listagem \ref{lst:proto-remote-message-amqp} não seria 
necessária caso o protocolo definisse um identificador para o nó remoto responsável 
pelo envio da mensagem. 

\begin{lstlisting}[frame=tb, caption={Protocolo para mensagens remotas com identificador do cliente.}, 
label={lst:proto-remote-message-amqp}]
message RemoteMessageProtocol {
  required UuidProtocol uuid = 1;
  required ActorInfoProtocol actorInfo = 2;
  required bool oneWay = 3;
  optional MessageProtocol message = 4;
  optional ExceptionProtocol exception = 5;
  optional UuidProtocol supervisorUuid = 6;
  optional RemoteActorRefProtocol sender = 7;
  repeated MetadataEntryProtocol metadata = 8;
  optional string cookie = 9;
  optional string remoteClientId = 10; // identificador do cliente
}
\end{lstlisting}

Devemos nos lembrar que o protocolo que descreve as referências de atores remotos, mostrado
na listagem \ref{lst:proto-remote-actor}, define um campo para armazenar o endereço de 
onde o ator remoto foi criado. Esse campo é composto pelo endereço do hospedeiro e porta
do nó. Pelo fato de não haver uma associação entre o endereço do ator remoto e uma 
\english{socket} e do valor não ser utilizado no envio de mensagens e nem no envio
de respostas, optamos por não fazer alterações na sua definição.

\section{Fluxo de envio das mensagens}

Parte do fluxo de um envio de uma mensagem a um ator remoto com a nova camada de transporte
continua acontecendo em sete passos, como descrito na sub-seção \ref{sec:atores_remotos_akka_fluxo}.
O processo de envio começa com o \english{proxy} local 
embrulhando a mensagem e adicionando a ela informações de cabeçalho necessárias para 
o envio e posterior processamento. 

Antes da mensagem ser repassada para o seriador, o \lstinline$AMQPRemoteSupport$ 
adiciona o identificador do cliente na mensagem (campo na linha $11$ 
da listagem \ref{lst:proto-remote-message-amqp}). 

O seriador continua sendo o responsável por converter a informação 
recebida em um vetor de \english{bytes} para que o transporte possa ocorrer. Uma vez que a 
informação esteja no formato a ser transportado, o \english{proxy} usa uma 
implementação de \lstinline$RemoteSupport$ (que na figura \ref{fig:remote-actor-message-flow-amqp} é 
uma instância de \lstinline$AMQPRemoteSupport$) para enviar a mensagem ao \lstinline$RemoteSupport$ 
que está no lado do servidor.

Os passos $3$ (transporte da mensagem do \lstinline$ClientBootstrap$ para
o \lstinline$ServerBootstrap$) e $4$ (recebimento da mensagem pelo \lstinline$ServerBootstrap$ e 
repasse para o \english{handler}) acontecem de modo diferente em relação a implementação com JBoss 
Netty. 

Pelo fato de utilizarmos as pontes AMQP definidas no capítulo \ref{cap:estrutura-troca-mensagens-amqp},
o passo $3$ se resume em enviar uma mensagem à \english{exchange} associada a ponte utilizando
o a chave de roteamento da ponte servidora. O \english{broker} roteia a mensagem para 
a fila criada pela ponte servidora. Apesar de o \english{broker} tentar entregar a mensagem para o 
consumidor da fila o quanto antes, a mensagem pode ficar armazenada caso o consumidor não esteja pronto
para fazer o recebimento da mensagem. O passo $4$ se resume no consumo da mensagem enviada
e no seu repasse para a implementação de \lstinline$MessageHandler$ utilizada na ponte servidora.

Vale lembrar que após o recebimento de um mensagem remota, ocorre um envio exatamente igual a 
um envio local. O envio local de uma mensagem leva tempo $O(1)$, que essa é a ordem do tempo 
gasto para colocar uma mensagem na fila de um ator.

\begin{figure}[!h]
		\includegraphics[scale=.80]{remote-actor-message-flow-amqp} 
 		\caption{Fluxo de um envio assíncrono de mensagem entre atores com AMQP.}
  		\label{fig:remote-actor-message-flow-amqp}
\end{figure}

Assim como na implementação com JBoss Netty, os envios feitos via métodos \lstinline$!!$ e 
\lstinline$!!!$ possuem um passo a mais do que os mostrados na figura 
\ref{fig:remote-actor-message-flow-amqp}. Entre os passos $2$ e $3$,
uma cópia da referência para instância de resultado futuro que é retornada é colocada 
no mapa de resultados futuros.

As mensagem de resposta para envios feitos via \lstinline$!!$ e \lstinline$!!!$, ou para notificar 
atores supervisores sobre atores supervisionados fazer o caminho inverso. Essas mensagens
são enviadas para a mesma \english{exchange} que a ponte cliente fez o envio, porém utilizando
como chave de roteamento o valor que utiliza o identificador do cliente. Assim o \english{broker}
fará o roteamento da mensagem para a fila do cliente.

Devemos lembrar que, caso a mensagem que foi enviada pelo servidor seja o resultado de um 
envio com \lstinline$!!$ ou \lstinline$!!!$, o conteúdo da mensagem
(seja um resultado de sucesso ou uma exceção) é utilizado para completar a instância cujo a
referência havia sido colocada no mapa de resultados futuros.

\section{Comparação de desempenho}
\index{Atores Remotos com AMQP!comparação de desempenho}
\label{sec:atores_remotos_amqp:analise_de_desempenho}

Com o intuito de medir como novas alterações no código da biblioteca de atores melhoravam o desempenho, 
os desenvolvedores do projeto Akka criaram um sistema que simula a compra e venda de ações
chamado de \english{Trading System}. Os desenvolvedores criaram também algumas classes que cuidam do armazenamento, 
comparação e geração de relatórios dos dados coletados nos testes de desempenho.

\subsection{Trading System}
\index{Atores Remotos com AMQP!comparação de desempenho!Trading System}
\label{sec:atores_remotos_amqp:trading_system}

A disposição dos componentes do sistema de cotações é mostrados na figura \ref{fig:trading-system}.
Os componentes são descritos a seguir:

\begin{itemize}
	\item \english{Order Book}: É uma entidade que possui informações sobre as
	ordens de compra e venda de uma ação em específico. Neste sistema, uma ação
	é composta por uma letra e por um número. Ele é responsável
	por fazer o casamento de uma ordem de venda com uma ordem de compra.
	É utilizado como nomes de ações as letras A, B e C, combinadas com
	números de $1$ a $5$, num total de quinze \english{order books};

	\item \english{Matching Engine}: É um ator que age como intermediário 
	no encaminhamento de mensagens aos \english{order books}. Existe um \english{matching engine}
	para cada letra de \english{order book};

	\item \english{Order Receiver}: É um ator externo que tem o papel de receber
	mensagens de compra e venda de qualquer ação, encontrar o \english{matching engine}
	responsavél e repassar a mensagem. A quantidade de \english{order receivers} não possui
	relação com \english{matching engines}, já que um \english{order receiver} recebe
	mensagens para qualquer tipo de ação. O sistema possui dez \english{order receivers};

	\item \english{Trading System}: É o ator recepcionista do sistema e é responsável
	por fazer a criação e inicialização dos atores internos do sistema. Este ator ainda
	responde a atores clientes os endereços (referências) dos \english{order receivers}
	que foram criados;

	\item \english{Order}: É um componente que não é mostrado na figura e que representa
	uma ordem. É definida em uma classe abstrata e possui como informações o código da ação, o volume e o valor. 
	Suas implementações são \english{Ask} para indicar uma ordem de venda, e \english{Bid} para indicar uma 
	ordem de compra;
\end{itemize}

\begin{figure}[!h]
		\centering
		\includegraphics[scale=.70]{trading-system} 
 		\caption{Trading System -- Sistema de compra e vendas de ações.}
  		\label{fig:trading-system}
\end{figure}

Existe ainda atores rotulados como ``clientes''. Um ator cliente é um ator externo ao 
sistema de cotações que possui uma lista de ordens a serem enviadas, um valor inteiro
indicando a quantidade de repetições a serem executadas na lista
e um \english{order receiver} para onde as mensagens devem ser enviadas.
A quantidade de atores cliente varia de acordo com a instância do teste que
se deseja fazer. A quantidade não será necessariamente igual à quantidade de \english{order receivers}.
Por este motivo, a associação de um ator cliente a um \english{order receiver} é feita em sequência. 
Itera-se na lista de \english{order receivers} junto com a lista de atores clientes.
Uma vez que se tenha alcançado o décimo \english{order receiver}, reinicia-se a iteração a partir do
primeiro ator. Depedendo a quantidade de atores clientes, alguns \english{order receivers}
podem recebem mensagens de mais, de menos ou até mesmo de nenhum ator cliente quando comparados com
outros \english{order receivers}.

Cada ator cliente envia um total de trinta ordens (quinze ordens de compra e quinze ordenrs de venda)
para o \english{order receiver} que lhe foi associado. Este valor é multiplicado pela quantidade
de repetições que o ator cliente deve executar. A medição é feita com base no tempo que uma mensagem 
enviada por um ator cliente levou para ser processada em um \english{order book}.

\subsubsection{Trading System com atores remotos}
\index{Atores Remotos com AMQP!comparação de desempenho!Trading System!remoto}
\label{sec:atores_remotos_amqp:trading_system_remoto}

Ainda que o \english{Trading System} não tenha sido criado para testes com atores remotos, 
consideramos ser de grande utilidade utilizá-lo para fazer uma comparação de desempenho
entre o suporte padrão a atores remotos do Akka com o que desenvolvemos. Para tal,
foram necessárias as alterações listadas a seguir:

\begin{enumerate}
	\item Registramos todos os atores que estão posicionados na área rotulada como ``Atores Externos''
	na figura \ref{fig:trading-system}, como atores remotos (seção \ref{sec:atores_remotos_akka}).
	Essa modificação resultou em alterações na inicialização do \english{Trading System} e na obtenção
	dos \english{order receivers}. Na versão remota, apenas os nomes sob o qual foram registrados
	no registro de atores remotos é devolvido. Na versão local, são devolvidas \lstinline$ActorRefs$.
	Evitamos devolver \lstinline$ActorRefs$ como parte das mensagens pois, neste caso, os atores deveriam
	passar por uma seriação funda. Enviando os nomes sob os quais os atores foram registrados, permite que
	façamos buscas no registro de atores remotos, trabalhando apenas com as referências remotas;	

	\item Fizemos com que as classes \english{Ask} e \english{Bid} fossem seriáveis 
	(seção \ref{sec:atores_remotos_akka_seriacao}). Optamos por utilizar como formato de seriação, 
	o formato definido na \english{trait} \lstinline$ScalaJSON$;

	\item Trocamos os envios assíncronos de mensagens por envios síncronos (\lstinline{!!})
	nos atores cliente. Assim, uma nova mensagem só é enviada uma vez que a mensagem anterior
	tenha sido processada e sua confirmação recebida no ator cliente. O comportamento de um ator
	cliente teve uma pequena alteração: para cada mensagem enviada, o ator cliente marca o momento de início
	do envio da mensagen, aguarda o valor devolvido pelo método \lstinline{!!} 
	(que é invocado no \english{order receiver}), marca o tempo de término do envio e salva a 
	diferença de tempo em um repositório.
\end{enumerate}

As configurações utilizadas no arquivo \lstinline$akka.conf$ para os testes com o suporte padrão
a atores remotos do Akka são as recomendadas uso geral (compressão média de mensagens e tamanho
do janelamento das mensagens de $1$KB). Nos testes executados com o suporte desenvolvido neste trabalho,
utilizamos uma conexão por canal além da configuração \lstinline$DURABLE$ para as pontes AMQP 
(seção \ref{sec:entidades-via-broker-amqp-bridges}).

Para que pudessemos tem medidas mais reais, separamos os atores clientes e os atores do
\english{Trading System} em JVMs residentes em nós fisicamente separados. A máquina
virtual Erlang, onde o RabbitMQ esteve em execução, ficou separada em um terceiro nó.

\subsection{Resultados}

Definimos o número de mensagens que cada cliente enviou da seguinte maneira: seja $n_c$ a 
quantidade de atores cliente utilizada no teste e seja $r$ o número de repetições; cada ator cliente 
enviou $30 (\lfloor r/n_c \rfloor)$ mensagens. O valor $r$ de repetições definido foi $1000$. 
Variamos os valores de $n_c$ de modo que o resultado da divisão fosse sempre inteiro. O total 
de mensagens enviadas por todos os atores cliente em uma instância de teste foi sempre $30000$. 

A estrutura criada para medição e comparação de desempenho de atores locais do Akka
utiliza algumas bibliotecas para o armazenamento e geração de relatórios. Os valores
das medidas registradas em uma instância de teste são organizados em percentis. 
A biblioteca utilizada para o cálculo de percentis é a Commons Math da fundação Apache \cite{commons-math}.
Os relatórios gerados apresentam também a quantidade de envios/respostas por segundo (ER/S),
o tempo médio de cada envio/resposta e ainda o tempo total gasto para a execução de
todos os envios/recebimentos. 

A tabela \ref{tab:medidas} mostra as melhores medidas dentre todas as execuções
feitas na execução do \english{Trading System} com atores remotos. O critério
utilizado para a comparação entre as medidas de um mesmo conjunto de instâncias
foi o valor que é apresentado na coluna média.

% lembrar de comentar de mensagens que ficam bufferizadas e sao entregues depois

\renewcommand{\arraystretch}{0.85}
\captionsetup{margin=1.0cm}
\begin{table}
\begin{center}
\begin{small}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|} 
\hline

{Impl.} & {Clientes} & {ER/S} & {Média ($\mu s$)} & {25\% ($\mu s$)} & {50\% ($\mu s$)} & {75\% ($\mu s$)} & 
{95\% ($\mu s$)} & {Dur. ($s$)} \\ \hline \hline
Netty & 1 & 501 &  1995 & 1364 & 1433 & 1968 & 3266 & 59.85 \\
AMQP  & 1 & 263 &  3797 & 3283 & 3361 & 3537 & 4550 & 113.91 \\ \hline
 & Delta & -47.50\% & 90.33\%  &  140.69\% &  134.54\% &  79.73\% &  39.31\% &  54.06 (90.33\%) \\ \hline
									
Netty & 2 & 894 & 1119 & 885 & 898 & 918 & 1645 & 33.57 \\
AMQP  & 2 & 528 & 1894.5 & 1617 & 1679.5 & 1776 & 2104 & 56.835 \\ \hline
 & Delta & -40.99\% &  69.30\% &   82.71\% &  87.03\% &  93.46\% &  27.90\% &  23.26 (69.33\%) \\ \hline

Netty & 4 & 1245 & 893 & 517.5 & 629.25 & 618.5 & 1053.5 & 24.09 \\
AMQP  & 4 &  906 & 1104 & 812 & 903.5 & 1033.5 & 1272 & 33.12 \\ \hline
 & Delta  & -27.31\% &  37.48\% &  56.91\% &  43.58\% &  51.65\% &  20.74\% &  9.03 (37.48\%) \\ \hline

Netty & 8 & 1494 & 669.125 & 409.25 & 471.375 & 593.125 & 771 & 20.07 \\
AMQP & 8 & 1389 & 720 & 445.875 & 518.625 & 646 & 803.125 & 21.60 \\ \hline
 & Delta & -7.10\% &  7.60\% &  8.95\% &  10.02\% &  8.91\% &  4.17\% &   1.52 (7.60\%) \\ \hline

Netty & 10 & 1542 & 648.4 & 400.5 & 433 & 570.4 & 704.1 & 19.45 \\
AMQP & 10 & 1424 & 702.3 & 439.6 & 510.7 & 613.6 & 761 & 21.06 \\ \hline
 & Delta & -7.72\% &  8.31\% &   9.76\% &  17.94\% &  7.57\% &  8.08\% &  1.61 (8.31\%) \\ \hline

Netty & 20 & 1568 & 637.85 & 410.3 & 482.3 & 507.3 & 600.75 & 19.13 \\
AMQP & 20 & 1503 & 665.45 & 436.4 & 498.2 & 544.4 & 671.5 & 19.96 \\ \hline
 & Delta & -4.15\% &  4.33\% &   6.36\% &  3.30\% &  7.31\% &  11.78\% &  0.82 (4.33\%) \\ \hline

Netty & 40 & 1589 & 629.4 & 440.4 & 454.57 & 485.9 & 533.75 & 18.82 \\
AMQP & 40 & 1518 & 658.62 & 462.4 & 488.12 & 521.05 & 584 & 19.75 \\ \hline
& Delta & -4.41\% &  4.64\% &   5.00\% &  7.38\% &  7.23\% &  9.41\% &  0.87 (4.64\%) \\ \hline 

Netty & 80 & 1615 & 619.06 & 442.53 & 456.76 & 473.28 & 500.51 & 18.57 \\
AMQP & 80 & 1535 & 651.52 & 473.93 & 492.48 & 511.78 & 543.7 & 19.54 \\ \hline
 & Delta & -5.02\% & 5.24\% &  7.10\% & 7.82\% & 8.13\% & 8.63\% & 0.97 (5.24\%) \\

\hline 
\end{tabular}
\caption{Medidas de tempo do Trading System com atores remotos.}
\label{tab:medidas}
\end{small}
\end{center}
\end{table}

O fato de adicionarmos um terceiro nó com um \english{message broker} na comunicação
entre os atores remotos, naturalmente adiciona mais passagens pela rede que conecta os nós.
Um envio que utiliza o Netty faz com que duas mensagens trafeguem pela rede (a ordem é
enviada pelo \lstinline$RemoteClient$ direto ao \lstinline$RemoteServer$ e a resposta
faz o caminho inverso). Já quando utilizamos a implementação com AMQP, quatro mensagens
são trafegadas (a ordem é enviada pelo \lstinline$RemoteClient$ ao \english{message broker},
o \english{message broker} envia a ordem para o \lstinline$RemoteServer$ e a resposta faz o caminho
inverso). Por este motivo, esperávamos que o tempo gasto pela implementação com AMQP fosse, 
aproximadamente, duas vezes mais do que o tempo gasto pela implementação com Netty. 
Observando a comparação dos dados da tabela \ref{tab:medidas} para a instância com apenas $1$ ator cliente, 
podemos notar uma diferença bem próxima da esperada, 
já que o número de envios/respostas por segundo é quase metade ($-47.50\%$), o valor médio 
para cada envio/resposta leva quase o dobro do tempo ($90.33\%$), fazendo com que a duração total 
também leve quase o dobro do tempo ($90.33$\%). Quando analizamos os percentis, podemos notar que as execuções mais rápidas
feitas com AMQP foram mais de duas vezes mais lentas em relação às execuções feitas com Netty 
($140.69$\% e  $134.54$\%). Entretanto, quando comparamos os percentis acima da mediana, observamos
uma boa redução na diferença ($79.73$\% e  $39.31$\%).

Devemos relembrar que não adicionamos compressão de mensagens na implementação com AMQP, e que
os testes feitos com Netty utilizaram compressão média. Como as mensagens são 
menores que $1$KB, entendemos que a implementação com AMQP possa ter levado ligeira
vantagem. Ademais, o terceiro nó colabora para a distribuição do processamento. Na implementação
feita com Netty, tanto as classes responsáveis pelo envio e recebimento de mensagens quanto as classes
do arcabouço compartilham mesma JVM que executa as classes do sistema de cotações. 
Já na implementação com AMQP, apenas as classes responsáveis pelo envio e recebimento de mensagens 
compartilham a mesma JVM. 

O gráfico da figura \ref{fig:grafico-er} mostra a evolução da quantidade de envios/recebimentos com o aumento
da quantidade de atores cliente. Podemos observar que, conforme a quantidade de atores cliente foi aumentando, 
os resultados com nossa implementação apresentaram uma boa melhora e se mantiveram muito
próximos dos resultados obtidos com a implementação original. A diferença que era de quase $-47.50\%$ envios/recebimentos
cai até chegar em apenas $-5.02\%$, o que no nosso teste representa pouco menos de $1$ segundo para
completar todos os envios/recebimentos. De um modo geral, se observarmos a diferença do tempo de execução 
para os testes a partir de $8$ clientes, a diferença de tempo fica abaixo de $1.6$ segundos.

\begin{figure}[!h]
		\centering
		\includegraphics[scale=.70]{grafico-er} 
 		\caption{Comparação da quantidade de envios/recebimentos.}
  		\label{fig:grafico-er}
\end{figure}
