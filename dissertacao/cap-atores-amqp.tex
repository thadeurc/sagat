\chapter{Atores Remotos com o Padrão AMQP}
\index{Atores Remotos com AMQP}
\label{cap:atores_remotos_amqp}

Apresentamos neste capítulo nossa implementação de atores remotos que utilizam
o padrão AMQP como meio de transporte para troca de mensagens. Nossa 
implementação utiliza a implementação de atores remotos do projeto Akka apresentada
no capítulo \ref{cap:atores_akka}. Na seção \ref{sec:atores_remotos_amqp:novos_componentes}
apresentamos os novos componentes que criamos dentro da estrutura do Akka e
na seção \ref{sec:atores_remotos_amqp:integracao_akka} como fizemos a integração dos
novos componentes com a implementação existente. 

\section{Novos componentes}
\index{Atores Remotos com AMQP!componentes}
\label{sec:atores_remotos_amqp:novos_componentes}

A implementação de atores remotos do projeto Akka define uma camada intermediária
que desacopla a definição dos componentes para transporte das mensagens a atores
remotos, como apresentado na seção \ref{sec:atores_remotos_akka}. Para viabilizar 
o envio de mensagens remotas via \english{message broker} AMQP, tivemos
que criar novos componentes para a camada de implementação com base nas classes
e feições que definem a interface remota (figura \ref{fig:remote-actor-colaboracao}).
Utilizamos a estrutura apresentada no capítulo \ref{cap:estrutura-troca-mensagens-amqp} 
como suporte para a implementação dos novos componentes do Akka. 
Criamos os seguintes componentes:

\begin{itemize}
	\item \lstinline{AMQPRemoteServer}: É uma classe utilizada no lado do servidor onde
	estão os atores remotamente acessíveis. Essa classe implementa os métodos abstratos
	de um \lstinline{MessageHandler} e é responsável pelo recebimento,
	desseriação e encaminhamento das mensagens para os atores que estão em seu registro. 
	A classe também é responsável por enviar eventuais mensagens de resposta para os 
	remetentes, seja como consequência de envios feitos via \lstinline{!!} e \lstinline{!!!}, 
	ou ainda mensagens para atores supervisores. Tanto no recebimento como no envio de mensagens 
	a classe utiliza um módulo separado para seriação e desseriação de mensagens. Existe um 
	relacionamento bidirecional um para um entre um \lstinline{AMQPRemoteServer} e uma ponte 
	servidora. O nome da ponte servidora (parâmetro \lstinline{name} do construtor da classe \lstinline{ServerAMQPBridge})
	é usado também como nome do servidor remoto.
			
	\item \lstinline{AMQPRemoteServerModule}: É uma feição que estende 
	a feição \lstinline{RemoteServerModule}, possui um \lstinline{AMQPRemoteServer} e mantém
	um registro de atores que ficam acessíveis remotamente. Há um  
	relacionamento bidirecional um para um entre \lstinline{AMQPRemoteServerModule} e 
	\lstinline{AMQPRemoteServer}. As mensagens recebidas pelo  \lstinline{AMQPRemoteServer} são encaminhadas 
	para os atores registrados no \lstinline{AMQPRemoteServerModule}.

	\item \lstinline{AMQPRemoteClient}:	É uma classe utilizada no lado do cliente
	onde ficam os \english{proxies} dos atores remotos. A classe mantém o registro de 
	atores que são supervisores de atores remotos, além de também manter um registro para 
	resultados futuros. Tal como a classe \lstinline{AMQPRemoteServer}, essa classe também 
	implementa os métodos abstratos de um \lstinline{MessageHandler} e é também é responsável
	pelo recebimento, desseriação e encaminhamento das mensagens para os atores ou
	resultados futuros que estão em seu registro. O principal papel da classe é
	fazer o envio das mensagens para o seu servidor remoto. 
	Existe uma relação bidirecional um para um entre um \lstinline{AMQPRemoteClient}
	e uma ponte cliente. A classe ainda é responsável por manter um identificador
	que deve ser único entre todos os clientes do mesmo servidor remoto. Esse identificador
	é utilizado na criação da instância da ponte cliente.
	
	\item \lstinline{AMQPRemoteClientModule}: É uma feição que estende
	a feição \lstinline{RemoteClientModule}. Essa feição
	que tem um papel complementar a \lstinline{AMQPRemoteServerModule}. Seu
	papel principal é definir uma interface para envios de mensagens a atores
	remotos via \lstinline{AMQPRemoteClient}. Ademais, esta feição
	mantém ainda um registro dos \lstinline{AMQPRemoteClient}s que são utilizados
	para enviar as mensagens para seus respectivos nós remotos, já que
	uma aplicação cliente pode interagir com diversos atores em diferentes nós.

	\item \lstinline{AMQPRemoteSupport}: É a implementação que tornamos acessível 
	via \lstinline{Actor.remote}. Essa classe é responsável por concentrar as 
	responsabilidades definidas nas classes e feições acima listadas para prover o suporte
	remoto via \english{message broker} AMQP.
\end{itemize}

O modo como os novos componentes se relacionam com as pontes AMQP e com as classes do
Akka é mostrado na figura \ref{fig:atores-remotos-amqp-colaboracao}.

\begin{figure}[!h]
	\centering
	\includegraphics[scale=.60]{remote-actor-amqp-colaboracao} 
 	\caption{Relacionamento entre os componentes para atores remotos com AMQP.}
  	\label{fig:atores-remotos-amqp-colaboracao}
\end{figure}

A definição das feições para suporte a atores remotos do Akka utiliza assinaturas
de métodos baseadas na identificação do hospedeiro e na porta. Para não quebrar a compatibilidade 
em nossa implementação e nem alterar a interface dos métodos do Akka, optamos por criar internamente 
uma ponte servidora e um servidor remoto identificado por um nome construído com base nos valores de \lstinline{host} e 
\lstinline{port} informados. O nome das pontes servidoras e dos servidores remotos seguem o padrão \lstinline{host@port}. 
Além disso, o construtor da classe \lstinline{RemoteActorRef} do Akka recebe como parâmetros
o hospedeiro e a porta. Optamos por manter a compatibilidade e não mudar esse construtor.
Como o projeto Akka possui desenvolvimento ativo, acreditamos que existe
uma grande possibilidade de mudança na interface dos componentes
do módulo de atores remotos, de modo a tornar essa interface independente da
camada de transporte utilizada.

\section{Integração com o Akka}
\index{Atores Remotos com AMQP!integração Akka}
\label{sec:atores_remotos_amqp:integracao_akka}

Uma vez definidos os componentes dentro da estrutura do Akka, é necessário que 
a biblioteca do Akka faça uso deles, de modo que a instância referenciada por
\lstinline{Actor.remote} seja uma instância de \lstinline{AMQPRemoteSupport}.
Ademais, devemos informar as configurações que nosso suporte espera, como por exemplo,
as políticas de armazenamento e compartilhamento de canais. As alterações necessárias
para a integração do nosso novo suporte com a biblioteca de atores do Akka são apresentadas
nas seções a seguir.

\subsection{Alterações no arquivo akka.conf}

Além de alterar o valor para a camada de suporte para atores remotos no arquivo 
\lstinline{akka.conf}, optamos por adicionar novas propriedades para a configuração do 
suporte que implementamos, como os dados
para conexão com o \english{message broker}, a política de armazenamento e de compartilhamento
de conexões entre canais. Uma outra propriedade importante que adicionamos foi a 
definição do identificador a ser utilizado na criação de diferentes 
\lstinline{AMQPRemoteClient}s (e consequentemente de \lstinline{ClientAMQPBridge}s). 
O novo valor para a camada de suporte para atores remotos (propriedade \lstinline{layer}) e as novas propriedades são 
exemplificados pelo seguinte fragmento de arquivo de configuração:

\begin{lstlisting}[frame=tb, numbers=none, caption={Novas propriedades do arquivo akka.conf.}]
remote {
	...
	layer = "akka.remote.amqp.AMQPRemoteSupport"
	amqp {
		broker {
			host = "192.168.0.121"
			port = 5673
			virtualhost = "/actor_host"
			username = "actor_admin"
			password = "actor_admin"
		}
		policy {
			storage {        	 
				mode = "EXCLUSIVE_PERSISTENT"
				client_id {
					suffix = "MYPLACE"
        	 	}
        	}
        	connection {
            	server = "ONE_CONN_PER_NODE"
            	client = "ONE_CONN_PER_NODE"
			}
		}		
	}
	...
}
\end{lstlisting}

\subsubsection{Observações}

Pelo fato do arquivo \lstinline{akka.conf} ser único por JVM, a maneira pelo qual
é feita a configuração das propriedades remotas impõe algumas restrições.
Com o Akka em execução em uma JVM, podemos criar diversos servidores remotos nessa JVM,
cada um com um nome diferente. A criação de um servidor remoto ocorre em consequência de
chamadas \lstinline{Actor.remote.start(host, port)}, como a ilustrada na listagem 
\ref{lst:remote-server1}. Todos os clientes remotos criados numa mesma JVM
utilizam o mesmo identificador de cliente, independentemente dos nomes dos servidores remotos
aos quais os clientes estão conectados.

Contudo, essa restrição não impede a criação dos objetos
no \english{message broker}. Para exemplificar, vamos considerar o
caso em que, numa mesma JVM, são criados dois clientes remotos para
servidores remotos cujos nomes são \lstinline{node1} e \lstinline{node2}.
Os objetos (fila e \english{binding}) criados por esses clientes remotos
têm o sufixo \lstinline{node1.<id>} e \lstinline{node2.<id>}, respectivamente.	
Um outro detalhe importante é que, pelo fato da classe 
\lstinline{AMQPRemoteClientModule} manter um registro com os clientes remotos, 
não há a possibilidade de, na mesma JVM, ser criada mais de uma instância de 
\lstinline{AMQPRemoteClient} para um mesmo servidor remoto.

As propriedades para configuração da política de armazenamento
são utilizadas tanto para os servidores quanto para os clientes remotos. Configurações 
divergentes entre JVMs podem levar aos seguintes cenários:

\begin{enumerate}
	\item A JVM onde foi iniciado um servidor remoto utiliza uma configuração
	persistente e alguma das JVMs com um cliente remoto define uma configuração
	transiente. Esse não é um caso muito problemático, já que os objetos criados
	pelo servidor não dependem dos objetos criados pelos clientes. Como objetos 
	definidos como transientes só são removidos quando o \english{message broker}
	é desligado, o problema se limita à devolução de eventuais mensagens que 
	ainda estivessem na fila.
	
	\item O servidor remoto possui uma configuração
	transiente e algum de seus clientes possui uma configuração persistente. Esse cenário é
	oposto ao anterior e é mais problemático, já que quando a \english{exchange} do servidor
	é removida todas as suas associações também são removidas, porém as filas persistentes
	não são. Devemos analisar esse cenário sob duas ópticas diferentes: \entry{(i)} 
	Óptica da criação dos objetos:
	como a biblioteca Java do RabbitMQ faz uma verificação da existência de um objeto
	antes de tentar fazer a sua criação (\ref{sec:entidades-via-broker-amqp-gerenciamento-conexoes}),
	não há problemas. A associação da fila persistente com a \english{exchange}
	recém criada acontecerá durante a inicialização do módulo do cliente remoto;
	\entry{(ii)} Óptica da aplicação: Eventuais mensagens não consumidas pelo servidor
	remoto são devolvidas.	
\end{enumerate}

As configurações referentes ao compartilhamento da conexão entre os canais de leitura e
escrita são definidas separadamente para os clientes e servidores remotos. A divergência
nas configurações entre um cliente remoto em um nó e um servidor remoto em outro nó
pode acontecer sem problemas, já que o impacto será no volume de dados que trafega
pela conexão.

\subsection{Segurança}

Com o intuito de prevenir conexões em servidores remotos de clientes em JVMs não autorizados,
o Akka deixa como opção de configuração exigir que somente clientes autorizados
possam interagir com os atores. A autorização é feita com um \english{cookie} de segurança,
um segredo compartilhado por todas as JVMs cujos atores podem trocar mensagens entre si.
O \english{cookie} de segurança é definido no arquivo \lstinline{akka.conf}, na seção \lstinline{remote}. O uso do
\english{cookie} é opcional e deve ser exigido, quando necessário, pelo servidor remoto, por meio
de uma propriedade em seu arquivo \lstinline{akka.conf}.

O valor do \english{cookie} é parte do envelope para mensagens remotas definido no Akka
(listagem \ref{lst:proto-remote-message}). Em nossa implementação mantivemos
o suporte a \english{cookies}. Caso um servidor remoto exija \english{cookies}, as mensagens oriundas 
de clientes remotos não autorizados não serão processadas. Um 
cliente remoto não autorizado receberá uma mensagem de resposta indicando a 
necessidade de autorização.

Quando utilizamos um \english{message broker} AMQP, a segurança depende muito de 
quem possui as informações para acesso ao \english{virtual host} onde
estão criadas as filas e \english{exchanges}.
Com o uso das filas definidas no \english{message broker} como repositório 
intermediário das mensagens, qualquer entidade que possua os dados necessários para acessar
o \english{virtual host} onde foram criadas as filas pode registrar outros
consumidores (salvo no caso de filas com acesso
exclusivo). Uma fila com mais de um consumidor pode ser interessante
quando se deseja fazer um monitoramento do volume ou até do conteúdo das
mensagens. No caso de haver mais de um consumidor em uma fila, uma cópia da mensagem
é entregue a cada consumidor. Um consumidor mal intencionado não tem a possibilidade 
de ``roubar'' uma mensagem, fazendo com que ela não seja recebida por seu destinatário legítimo, nem mesmo 
alterar a integridade de uma mensagem.

\subsection{Alteração no formato do envelope das mensagens remotas}

Para que o servidor remoto pudesse identificar qual o remetente de uma mensagem,
foi necessária uma pequena alteração no envelope da mensagem. Esse envelope passa a incluir um campo 
não obrigatório para o identificador do cliente.
O formato do envelope com a alteração é mostrado na listagem 
\ref{lst:proto-remote-message-amqp}. Cabe ressaltar que o novo campo não era necessário na implementação original
de transporte com o Netty, que consegue obter do \english{socket} qual o endereço
do cliente remoto.

\begin{lstlisting}[frame=tb, caption={Formato do envelope para mensagens remotas com identificador do cliente.}, 
label={lst:proto-remote-message-amqp}]
message RemoteMessageProtocol {
  required UuidProtocol uuid = 1;
  required ActorInfoProtocol actorInfo = 2;
  required bool oneWay = 3;
  optional MessageProtocol message = 4;
  optional ExceptionProtocol exception = 5;
  optional UuidProtocol supervisorUuid = 6;
  optional RemoteActorRefProtocol sender = 7;
  repeated MetadataEntryProtocol metadata = 8;
  optional string cookie = 9;
  optional string remoteClientId = 10; // identificador do cliente
}
\end{lstlisting}

\section{Fluxo de envio das mensagens}

Parte do fluxo do envio de uma mensagem a um ator remoto com a nova camada de transporte
continua acontecendo em sete passos, como descrito na seção \ref{sec:atores_remotos_akka_fluxo}.
O processo de envio começa com o \english{proxy} local 
embrulhando a mensagem e adicionando a ela informações de cabeçalho necessárias para 
o envio e posterior processamento. Antes da mensagem ser repassada para o seriador,
o \lstinline{AMQPRemoteSupport} 
adiciona o identificador do cliente na mensagem (campo na linha $11$ 
da listagem \ref{lst:proto-remote-message-amqp}). 

O seriador continua sendo o responsável por converter a informação 
recebida em um vetor de \english{bytes} para que o transporte possa ocorrer. Uma vez que a 
informação esteja no formato a ser transportado, o \english{proxy} usa uma 
implementação de \lstinline{RemoteSupport} (que na figura \ref{fig:remote-actor-message-flow-amqp} é 
uma instância de \lstinline{AMQPRemoteSupport}) para enviar a mensagem ao \lstinline{RemoteSupport} 
que está no lado do servidor.

Os passos $3$ (transporte da mensagem do \lstinline{ClientBootstrap} para
o \lstinline{ServerBootstrap}) e $4$ (recebimento da mensagem pelo \lstinline{ServerBootstrap} e 
repasse para o \english{handler}) acontecem de modo diferente em relação a implementação com Netty. 
Pelo fato de utilizarmos as pontes AMQP definidas no capítulo \ref{cap:estrutura-troca-mensagens-amqp},
o passo $3$ se resume em enviar uma mensagem à \english{exchange} associada a ponte utilizando
o a chave de roteamento da ponte servidora. O \english{message broker}, então, roteia a mensagem para 
a fila criada pela ponte servidora. Ainda que o \english{message broker} tente entregar a mensagem para o 
consumidor da fila o quanto antes, a mensagem pode ficar armazenada caso o consumidor não esteja pronto
para fazer o recebimento da mensagem. O passo $4$ se resume ao consumo da mensagem enviada
e no repasse para a implementação de \lstinline{MessageHandler} utilizada na ponte servidora.
Vale lembrar que, após o recebimento de um mensagem remota, ocorre um envio exatamente igual a 
um envio local. O envio local de uma mensagem leva tempo $O(1)$, que é o tempo 
gasto para colocar uma mensagem na fila de um ator.

\begin{figure}[!h]
		\includegraphics[scale=.80]{remote-actor-message-flow-amqp} 
 		\caption{Fluxo de um envio assíncrono de mensagem entre atores com AMQP.}
  		\label{fig:remote-actor-message-flow-amqp}
\end{figure}

Assim como na implementação com Netty, os envios feitos via métodos \lstinline{!!} e 
\lstinline{!!!}, também possuem um passo a mais do que os mostrados na figura 
\ref{fig:remote-actor-message-flow-amqp}. Entre os passos $2$ e $3$, é colocada no mapa de resultados 
futuros uma referência que instância de \lstinline{CompletableFuture} criada pela chamada ao método !! ou !!!. 
A mensagem de resposta para um envio feito via \lstinline{!!} ou \lstinline{!!!} faz o caminho inverso. 
Essa mensagem é enviada para a mesma \english{exchange} empregada pela ponte cliente que fez o envio, 
porém utilizando o identificador do cliente remoto como parte da chave de roteamento. Assim, o \english{message broker}
pode fazer o roteamento da mensagem para a fila do cliente remoto.
