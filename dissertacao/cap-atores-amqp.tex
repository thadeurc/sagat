\chapter{Atores Remotos com o Padrão AMQP}
\index{Atores Remotos com AMQP}
\label{cap:atores_remotos_amqp}

Apresentamos neste capítulo nossa implementação de atores remotos que utilizam
o padrão AMQP como meio de transporte para troca de mensagens. Nossa 
implementação utiliza a implementação de atores remotos do projeto Akka apresentada
no capítulo \ref{cap:atores_akka}. Na seção \ref{sec:atores_remotos_amqp:novos_componentes}
apresentamos os novos componentes que criamos dentro da estrutura do Akka e
na seção \ref{sec:atores_remotos_amqp:integracao_akka} como fizemos a integração dos
novos componentes com a implementação existente.

\section{Novos componentes}
\index{Atores Remotos com AMQP!componentes}
\label{sec:atores_remotos_amqp:novos_componentes}

A implementação de atores remotos do projeto Akka define uma camada intermediária
que desacopla a definição dos componentes para transporte das mensagens a atores
remotos, como apresentado na seção \ref{sec:atores_remotos_akka}. 

Para que a envios remotos fosse possível com um \english{message broken} AMQP, tivemos
que criar novos componentes para a camada de implementação com base nas classes
e \english{traits} que definem a interface remota (figura \ref{fig:remote-actor-colaboracao}).
Utilizamos a estrutura apresentada no capítulo \ref{cap:estrutura-troca-mensagens-amqp} 
como suporte para a implementação dos novos componentes do Akka. 
Os novos componentes são:

\begin{itemize}
	\item \lstinline$AMQPRemoteServer$: É uma classe utilizada no lado do servidor onde
	estão os atores remotamente acessíveis. Essa classe implementa os métodos abstrados
	de um \lstinline$MessageHandler$ e é responsável pelo recebimento de mensagens,
	desseriação e encaminhamento para os atores que estão em seu registro. 
	A classe também é responsável por enviar eventuais mensagens de resposta para os 
	remetentes, seja como consequência de envios feitos via \lstinline$!!$ e \lstinline$!!!$, 
	ou ainda mensagens para atores supervisores. Tanto no recebimento, como no envio de mensagens 
	a classe utiliza um módulo separado para seriação e desseriação de mensagens. Existe um 
	relacionamento bidirecional um para um entre um \lstinline$AMQPRemoteServer$ e uma ponte 
	servidora;
			
	\item \lstinline$AMQPRemoteServerModule$: É uma \english{trait} que extende 
	a \english{trait} \lstinline$RemoteServerModule$ e define um nó onde atores
	são registrados para ficarem acessíveis remotamente. Essa implementação 
	mantém o registro desses atores e possui uma relação 
	bidirecional um para um com um \lstinline$AMQPRemoteServer$. As mensagens recebidas pelo 
	\lstinline$AMQPRemoteServer$ são encaminhadas para os atores residentes nesse módulo;

	\item \lstinline$AMQPRemoteClient$:	É uma classe utilizada no lado do cliente
	onde ficam os \english{proxies} dos atores remotos. A classe mantém o registro de 
	atores que são supervisores de atores remotos, além de também manter um registro para 
	resultados futuros. Assim como a classe \lstinline$AMQPRemoteServer$, essa classe também 
	implementa os métodos abstratos de um \lstinline$MessageHandler$ e é também é responsável
	pelo recebimento de mensagens, desseriação e encaminhamento para os atores ou
	resultados futuros que estão em seu registro. O principal papel da classe é
	fazer o envio das mensagens após a seriação para o \english{message broker}. 
	Existe uma relação bidirecional um para um entre um \lstinline$AMQPRemoteClient$
	e uma ponte cliente. A classe ainda é responsável por manter um identificador
	que deve ser único entre todos os clientes do mesmo servidor remoto. Esse identificador
	é utilizado na criação da instância da ponte cliente;
	
	\item \lstinline$AMQPRemoteClientModule$: É uma \english{trait} que extende
	a \english{trait} \lstinline$RemoteClientModule$. Essa é uma \english{trait}
	que tem um papel complementar a \lstinline$AMQPRemoteServerModule$ e seu
	papel principal é definir uma interface para envios de mensagens a atores
	remotos via \lstinline$AMQPRemoteClient$. Ademais, a \english{trait}
	mantém ainda um registro de \lstinline$AMQPRemoteClient$, que são utilizados
	para enviar as mensagens para seus respectivos nós remotos, já que
	uma aplicação cliente pode interagir com diversos atores em diferentes nós;

	\item \lstinline$AMQPRemoteSupport$: É a implementação que tornamos acessível 
	via \lstinline$Actor.remote$. Essa classe é responsável por concentrar as 
	responsabilidades definidas nos módulos acima listados para prover o suporte
	remoto via \english{message broker} AMQP.
\end{itemize}

%% mostrar código aonde?!
\begin{figure}[!h]
 		\centering
	\includegraphics[scale=.60]{remote-actor-amqp-colaboracao} 
 		\caption{Relacionamento entre os componentes para atores remotos com AMQP.}
  	\label{fig:atores-remotos-amqp-colaboracao}
\end{figure}

A definição das \english{traits} para suporte a atores remotos do Akka define assinaturas
de métodos baseadas em \english{host} e porta. Para não quebrar a compatibilidade em nossas
implementações e nem alterar a interface dos métodos, optamos por criar internamente 
o nome do nó com base nos valores informados para \english{host} e porta. O padrão
utilizado é \lstinline$host@porta$. 

Como mencionado seção \ref{sec:atores_locais}, \lstinline$ActorRef$s
guardam o endereço do local onde o ator foi criado. Pelo fato de não haver associação
entre o endereço definido e uma \english{socket}, e de os valores para \english{host}
e porta serem recebidos no construtor da classe, optamos por manter a compatibilidade e
não mudar nem o construtor e nem o atributo. Em nossa implementação, o valor
do atributo \lstinline$homeAddress$ não é utilizado.

Pelo fato do projeto Akka possui um desenvolvimento ativo, acreditamos que existe
uma grande possibilidade de haver uma mudança na interface dos componentes
do módulo de atores remotos, de modo que haja um desacomplamento entre sua interface
e as implementações da camada de transporte.

\section{Integração com o Akka}
\index{Atores Remotos com AMQP!integração Akka}
\label{sec:atores_remotos_amqp:integracao_akka}

Uma vez que definimos os componentes dentro da estrutura do Akka, é necessário que 
a biblioteca do Akka faça uso deles, de modo que a instância referenciada por
\lstinline$Actor.remote$ seja uma instância de \lstinline$AMQPRemoteSupport$.

O arquivo \lstinline$akka.conf$ possui é o ponto de entrada para todas as configurações
que são parametrizadas de todos os módulos do projeto Akka (o formato do arquivo difere
dos arquivos para configurações de propriedades baseados em chaves e valores. O projeto
Akka utiliza uma biblioteca chamada Configgy \cite{configgy} que define um formato
mais idiomático para arquivos de configurações). Existe uma seção
específica para as configurações correspondentes aos atores remotos. Na distribuição
padrão, boa parte das propriedades para a configuração de atores remotos são relacionadas ao JBoss
Netty, como por exemplo o tipo nível de compressão, tamanho da janela da mensagem e
tempo limite de espera pelo cliente para se conectar. Contudo, existem algumas propriedades
que são mais gerais, como por exemplo se a comunicação deve ser autenticada via \english{cookies}
pré-definidos, qual o \english{cookie} de segurança a ser utilizado e ainda qual a classe que deve
ser utilizada como implementação da camada de suporte para atores remotos.

Os dados informados no arquivo \lstinline$akka.conf$, uma vez que foram lidos ficam acessíveis
em objetos de acordo com o contexto que fazem parte. Por exemplo, as propriedades relacionadas
aos atores remotos estão organizadas em objetos dentro do módulo \lstinline$RemoteShared$.
Existe ainda uma classe auxíliar que é utilizada para acessar os módulos dos sub-projetos
do Akka via reflexão chamada de \lstinline$ReflectiveAccess$. Nossa nova camada de
implementação para o transporte de mensagens entre atores remotos é instanciada nessa
classe.

\subsection{Alterações no arquivo de akka.conf}

Além de alterar o valor para a camada de suporte para atores remotos, optamos por adicionar
novas propriedades para a configuração do suporte que implementamos, como os dados
para conexão com o \english{broker}, a política de armazenamento e de compartilhamento
de conexões entre canais. Uma outra propriedade importante que adicionamos foi a 
definição do identificador a ser utilizado na criação de diferentes 
\lstinline$AMQPRemoteClient$s (e consequentemente de \lstinline$ClientAMQPBridge$s). 
O novo valor para a camada de suporte para atores remotos e as novas propriedades são 
listadas a seguir:

\begin{lstlisting}[frame=none, numbers=none]
remote {
	...
	layer = "akka.remote.amqp.AMQPRemoteSupport"
	amqp {
		policy {
			storage {        	 
				mode = "EXCLUSIVE_PERSISTENT"
				client_id {
					suffix = "MYPLACE"
        	 	}
        	}
        	connection {
            	server = "ONE_CONN_PER_NODE"
            	client = "ONE_CONN_PER_NODE"
			}
		}
		broker {
			host = "192.168.0.121"
			virtualhost = "/actor_host"
			username = "actor_admin"
			password = "actor_admin"
		}
	}
	...
}
\end{lstlisting}


Pelo fato arquivo \lstinline$akka.conf$ ser único por JVM, a maneira pelo qual
é feita a configuração das propriedades remotas impõe algumas restrições.
Com o Akka em execução em uma JVM, podemos criar diversos servidores remotos,
cada um com um nome de nó diferente. Também podemos criar clientes
remotos, um para cada servidor remoto. Poderiamos ainda ter em uma JVM
uma combinação dos dois cenários, com servidores remotos e clientes para
servidores remotos. 

\subsubsection{Restrições}

Todos os clientes remotos que forem criados na JVM, independente
do nome do servidor remoto utilizam o mesmo identificador de cliente.
Contudo, essa restrição não impedimende a criação dos objetos
no \english{message broker}. Para exemplificar, podemos analizar o
caso onde dois clientes remotos são criados em uma JVM para os
servidores remotos cujos nomes são \lstinline$node1$ e \lstinline$node2$.
Os objetos criados pelos primeiro cliente remoto terão o sufixo
\lstinline$client.node1.<id>$ e \lstinline$client.node2.<id>$.	
Um outro detalhe importante é que, pelo fato de classe 
\lstinline$AMQPRemoteClientModule$ manter um registro dos clientes remotos, 
não há a possibilidade de na mesma JVM ser criado mais de uma instância de 
\lstinline$AMQPRemoteClient$ para um mesmo servidor remoto.

As propriedades para configuração da política de armazenamento
são utilizadas para ambos os servidores e clientes remotos. Configurações 
divergentes entre JVMs podem levar aos seguintes cenários:

\begin{enumerate}
	\item A JVM onde foi iniciado um servidor remoto utiliza uma configuração
	persistente e alguma das JVMs com um cliente remoto define uma configuração
	transiente: Esse não é um caso muito problemático, já que os objetos criados
	pelo servidor não dependem dos objetos criados pelos clientes. Como os objetos 
	definidos como transientes só são removidos quando o \english{message broker}
	é desligado, o problema se limita a perda de eventuais mensagens que 
	ainda não haviam sido consumidas e estavam na fila;
	
	\item Um cenário oposto ao anterior, onde o servidor remoto possui uma configuração
	transiente e algum de seus clientes uma configuração persistente: Esse é 
	um cenário mais problemático, já que quando a \english{exchange} do servidor
	é removida todas as suas associações também são removidas, porém as filas persistentes
	não. Esse cenário ter duas ópticas diferentes. Pela óptica da criação dos objetos,
	a biblioteca Java do RabbitMQ faz uma verificação da existência de um objeto
	antes de tentar fazer a sua criação (\ref{sec:entidades-via-broker-amqp-gerenciamento-conexoes}),
	logo não há problemas, já que a associação da fila persistente com a \english{exchange}
	recém criada acontecerá durante a execução da inicialização do módulo do cliente remoto.
	A segunda óptica é a da aplicação. Eventuais mensagens não consumidas pelo servidor
	remoto serão perdidas.	
\end{enumerate}

As configurações relacionadas ao compartilhamento da conexão entre os canais de leitura e
escrita são definidas separadamente para os clientes e servidores remotos. A divergência
nas configurações entre um cliente remoto em um nó e um servidor remoto em outro nó
pode acontecer sem problemas, já que o impacto será no volume de dados trafegado
na conexão.

\subsection{Segurança}

Com o intuito de previnir conexões em servidores remotos de clientes não autorizados,
na implementação com o JBoss Netty, existe a possibilidade de se exigir que seja enviado
um valor para que o cliente que está tentando se conectar seja autorizado a interagir com
os atores. Esse valor é chamado de \english{secure cookie} e é definido no arquivo 
\lstinline$akka.conf$ na seção \lstinline$remote$. O mecanismo utilizado para 
autorização é parte do Akka e não possui relação com o JBoss Netty. Habilitar o uso de 
autorização é algo opcional e deve ser exigido pelo servidor remoto. A propriedade
utilizada para forçar o uso de \english{cookie} na comunicação é definida dentro de
\lstinline$remote { server { ... } }$.

O valor do \english{cookie} é parte do protocolo remoto definido no Akka, mostrado
na listagem \ref{lst:proto-remote-message} no capítulo \ref{cap:atores_akka}. Pelo
fato de o uso do \english{cookie} ser definido no protocolo remoto, podemos 
continuar fazendo seu uso em nossa implementação. Mensagens oriundas de clientes
que não possuem autorização nos servidores remotos, não são processadas e o
cliente remoto remetente recebe uma mensagem de resposta com indicando a falta
de autorização.

Com o uso das filas definidas no \english{message broker} como repositório 
intermediário das mensagens, caso não se esteje utilizando filas com acesso
exclusivo, qualquer entidade que possua os dados necessários para acessar
o \english{virtual host} onde estão criadas as filas pode registrar outros
consumidores. Uma fila com mais de um consumidor pode ser interessante
quando se deseja fazer um monitoramento do volume ou até do conteúdo das
mensagens. No caso de haver mais de um consumidor em uma fila, uma cópia da mensagem
é entregue a cada consumidor. Não é possível, portanto, um consumidor
mal intencionado ``roubar'' ou mesmo alterar a integride das mensagens.

Com o uso de um \english{message broker} AMQP, a segurança depende muito de 
quem possui as informações para acesso ao \english{virtual host} onde
estão criadas as filas e \english{exchanges}.

\subsection{Alterações no protocolo}

Para que o servidor remoto pudesse identificar qual o remetente de uma mensagem recebida,
foi necessária uma pequena alteração no protocolo remoto. A implementação de transporte
feita com o JBoss Netty consegue identificar na \english{socket} qual o endereço
do a entidade remota que está se conectada. O protocolo utilizado para definir uma mensagem
remota passa a incluir um parâmetro não mandatório para que o identificador do cliente
possa ser identificado. O protocolo com a alteração é mostrado na listagem 
\ref{lst:proto-remote-message-amqp}. Essa alteração implicou em
alterações no objeto \ref{RemoteActorSerialization}. Esse objeto é o responsável por 
fabricar uma instância com as informações a serem seriadas. O método 
\lstinline$createRemoteMessageProtocolBuilder$ foi sobrecarregado e passou
a receber o identificador do cliente como parâmetro. 

A alteração apresentada na listagem \ref{lst:proto-remote-message-amqp} não seria 
necessária caso o protocolo definisse um identificador para o nó remoto responsável 
pelo envio da mensagem. 

\begin{lstlisting}[frame=tb, caption={Protocolo para mensagens remotas com identificador do cliente.}, 
label={lst:proto-remote-message-amqp}]
message RemoteMessageProtocol {
  required UuidProtocol uuid = 1;
  required ActorInfoProtocol actorInfo = 2;
  required bool oneWay = 3;
  optional MessageProtocol message = 4;
  optional ExceptionProtocol exception = 5;
  optional UuidProtocol supervisorUuid = 6;
  optional RemoteActorRefProtocol sender = 7;
  repeated MetadataEntryProtocol metadata = 8;
  optional string cookie = 9;
  optional string remoteClientId = 10; // identificador do cliente
}
\end{lstlisting}


\section{Fluxo das mensagens}

O fluxo é mostrado na figura \ref{fig:remote-actor-message-flow-amqp}.

\begin{figure}[!h]
% 		\centering
		\includegraphics[scale=.80]{remote-actor-message-flow-amqp} 
 		\caption{Fluxo de um envio assíncrono de mensagem entre atores com AMQP.}
  		\label{fig:remote-actor-message-flow-amqp}
\end{figure}