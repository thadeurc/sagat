\chapter{Troca de mensagens entre entidades remotas via broker AMQP}
\index{Estrutura}
\label{cap:estrutura-troca-mensagens-amqp}

Apresentamos nesse capítulo a estrutura que definimos para a troca de mensagens 
entre entidades remotas via \english{message broker} AMQP. A estrutura apresentada
neste capítulo foi utilizada como suporte para o desenvolvimento dos novos componentes 
da camada de implementação para transporte de mensagens entre atores remotos do projeto Akka 
(figura \ref{fig:remote-actor-colaboracao}). Entretanto, 
antes de apresentar a estrutura que definimos, comentamos brevemente algumas 
características de entidades conectadas ponto-a-ponto via \english{sockets}
que são afetadas ou deixam de fazer sentido com a nova abordagem.

\section{Entidades conectadas ponto-a-ponto via \english{sockets}}
\index{Estrutura!ponto-a-ponto}
\label{sec:entidades-ponto-a-ponto}

Em uma transferência de mensagens entre duas entidades conectadas 
ponto-a-ponto por \english{sockets} TCP ou UDP, ambas as entidades devem conhecer
detalhes sobre a conexão e sobre o formato das mensagens que são enviadas. 
O fato de não haver uma entidade intermediando a troca de mensagens permite que 
uma das entidades identifique uma eventual desconexão da outra, ou ainda que uma 
entidade conheça o endereço do nó hospedeiro onde está a outra entidade. Nos casos em que as 
entidades estão em nós que não fazem parte de uma rede interna,
a informação de localidade pode não indicar exatamente o nó real da entidade, 
mas o endereço de alguma porta de ligação (\english{gateway}). 

A comunicação entre entidades conectadas ponto-a-ponto via \english{sockets} tem a seguinte característica:
cada \english{socket} utiliza exclusivamente uma porta para aceitar as conexões remotas, criando uma relação um 
para um entre portas e entidades. Para a numeração de portas, os protocolos TCP e UDP
utilizam inteiros de $16$ bits sem sinal, limitando o número de
portas a $65536$ ($0$ -- $65535$)\cite{tcp}. Ademais, algumas portas que são utilizadas 
para serviços comuns, como por exemplo servidores de correio eletrônico, 
possuem numeração fixa definida pela IANA (\english{Internet Assigned Numbers Authority})
e não podem ser empregadas por outros serviços.

%Este tipo de abordagem não implica no uso de armazenamento intermediário das mensagens. Uma
%mensagem enviada de uma entidade para outra, até poderia ser armazenada pela entidade que 
%recebe a mensagem, mas não pelo mecanismo de transporte. Fica a cargo da entidade que recebe 
%a mensagem implementar o armazenamento temporário, caso haja necessidade.

\subsection{Atores remotos conectados ponto-a-ponto}
\label{subsec:atores-remotos-ponto-a-ponto}

É indesejável que o número de portas disponíveis em um nó limite a quantidade
de atores remotos que podem ser criados no nó. Assim, uma implementação de atores remotos 
deve, de alguma maneira, permitir que múltiplos atores sejam
associados a uma porta.

Na implementação de atores remotos do Akka apresentada na seção 
\ref{sec:atores_remotos_akka}, vimos que os atores são agrupados por endereço
do nó hospedeiro e da porta e ficam registrados no \lstinline{RemoteServerModule}. 
Vimos também, na seção \ref{sec:atores_locais}, que atores são identificáveis, 
o que permite que eles sejam localizados no \lstinline{RemoteServerModule} 
para que possam receber as mensagens. Ainda que a implementação de atores 
remotos do Akka agrupe os atores, evitando que o número de atores fique
limitado pelo número de portas disponíveis, um \lstinline{RemoteClientModule} 
possui conhecimento do hospedeiro e da porta ao qual está conectado.
Além disso, o \lstinline{RemoteServerModule} que recebe uma mensagem pode obter
o hospedeiro e a porta do \lstinline{RemoteClientModule} remetente.

A implementação de atores remotos de Erlang não usa portas explicitamente. 
Cada máquina virtual Erlang possui um nome associado. O nome de uma máquina virtual é definido 
durante a ativação da máquina virtual, por meio de um parâmetro na linha de comando.
Diversas máquinas virtuais podem estar em execução em um determinado hospedeiro e são unicamente identificadas
por \lstinline{name@host}. O nome de uma máquina virtual é utilizado,
juntamente com a informação do hospedeiro, para especificar onde um ator remoto deve ser criado.
Em outras palavras, pode-se criar um ator remoto numa máquina virtual especificada por
\lstinline{name@host}. 

\section{Entidades conectadas via \english{message broker} AMQP}
\index{Estrutura!message broker amqp}
\label{sec:entidades-via-broker-amqp}

A substituição de um mecanismo ponto-a-ponto por um mecanismo baseado em AMQP 
naturalmente introduz novas características à interação entre as entidades. Elas deixam 
de estar conectadas diretamente, já que o \english{message broker} passa a ser 
o componente central de conexão entre todas as entidades. Funcionalidades 
baseadas na comunicação ponto-a-ponto, como por exemplo a detecção de desconexão, 
ainda que possíveis, não são triviais. O \english{message broker} passa a ser o responsável 
por abrir uma porta para que as demais entidades possam se conectar e é responsável por fazer o gerenciamento de
múltiplas conexões nesta porta. 

Rotulações de entidades por hospedeiro e porta ou por 
nome e hospedeiro deixam de fazer sentido. Tais rotulações tornam-se redundantes, pois
as entidades passam a ser identificadas somente por seus nomes.
Para poder receber mensagens, cada nova entidade que entrar no sistema deve 
criar uma fila no \english{message broker} e associá-la a uma \english{exchange}.
Uma entidade que desempenhe o papel de servidora deve antes criar essa \english{exchange}.
Por outro lado, uma entidade que desempenhe o papel de cliente faz o \english{binding} de 
sua fila na \english{exchange} criada por alguma entidade servidora. Podemos fazer uma analogia 
da \english{exchange} com um \english{server socket}. Tarefas administrativas como a 
criação de \english{virtual hosts}, a criação de usuários e a definição das permissões dos 
usuários não são de responsabilidade das entidades. Essas tarefas devem ter sido executadas previamente.

O suporte ao desenvolvimento dos novos componentes da camada de implementação
de transporte remoto do projeto Akka é dado com a ajuda de alguns componentes intermediários. 
Esses componentes intermediários formam uma ponte entre a nova camada de transporte remoto e
a biblioteca Java do \english{message broker} RabbitMQ.

\subsection{Pontes AMQP}
\index{Estrutura!message broker amqp!pontes}
\label{sec:entidades-via-broker-amqp-bridges}

O módulo \lstinline{AMQPBridge} é responsável por fornecer classes que agem como pontes de comunicação
para o \english{message broker}. Juntas, suas classes definem uma interface
com funcionalidades básicas para troca de mensagens como envios, recebimentos, 
tratamento de mensagens rejeitadas e suporte a múltiplas entidades cliente conectadas a uma
entidade servidora. O módulo \lstinline{AMQPBridge} contém as seguintes classes:

\begin{itemize}
	\item \lstinline{AMQPBridge}: É a classe abstrata que define o comportamento básico
	de uma entidade conectada a um \english{message broker} AMQP. O construtor de \lstinline{AMQPBridge}
	recebe como argumentos o nome que identifica a ponte e uma conexão para um \english{message broker} 
	AMQP. Essa classe define ainda o padrão de nomeação utilizado na criação dos objetos,
	como mostra a listagem \ref{lst:amqp-bridge}. A classe possui também um objeto acompanhante que
	define métodos para a criação de instâncias das subclasses de \lstinline{AMQPBridge}.

	\item \lstinline{MessageHandler}: É a feição que define os métodos a serem
	invocados quando mensagens forem recebidas ou envios feitos pela entidade forem 
	rejeitados pelo \english{message broker}.
	
	\item \lstinline{ServerAMQPBridge}: É uma das duas subclasses de \lstinline{AMQPBridge} e
	define o comportamento para entidades que atuam como servidoras. 
	Além dos métodos herdados, essa classe ainda define o método \lstinline{setup}. Esse
	método recebe como argumento uma implementação de \lstinline{MessageHandler} e os
	parâmetros com as configurações da fila e da \english{exchange} que serão criadas
	durante a execução do método, como mostrado na listagem \ref{lst:amqp-server-bridge}.	

	\item \lstinline{ClientAMQPBridge}: É a outra subclasse de \lstinline{AMQPBridge} e
	define o comportamento para entidades que atuam como clientes. Essa
	classe tem em seu construtor um parâmetro adicional em relação à classe \lstinline{ServerAMQPBridge}.
	O parâmetro \lstinline{id} é utilizado para a identificação do cliente. A identificação é necessária 
	para compôr a chave de roteamento que 
	associa a fila que essa ponte irá criar no método \lstinline{setup}, com
	a \english{exchange} correspondente. A definição dessa classe é mostrada na 
	listagem \ref{lst:amqp-client-bridge}.
\end{itemize}

\begin{lstlisting}[frame=tb, caption={Classe AMQPBridge do módulo AMQPBridge.scala.}, label={lst:amqp-bridge}]
abstract class AMQPBridge(val name: String, 
                          val connection: SupervisedConnectionWrapper) {
  require(name != null)
  require(connection != null)
    
  lazy val inboundExchangeName = "actor.exchange.in.%s".format(name)
  lazy val inboundQueueName    = "actor.queue.in.%s".format(name)
  lazy val outboundQueueName   = "actor.queue.out.%s".format(name)
  lazy val routingKeyToServer  = "to.server.%s".format(name)

  def sendMessageTo(message: Array[Byte], to: String): Unit
  def shutdown: Unit = { ... }
}
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Classe ServerAMQPBridge do módulo AMQPBridge.scala.}, label={lst:amqp-server-bridge}]
class ServerAMQPBridge(name: String, 
					   connection: SupervisedConnectionWrapper) 
					   		extends AMQPBridge(name, connection){
 
  def setup(handler: MessageHandler, 
  			exchangeParams: ExchangeConfig.ExchangeParameters,
            queueParams: QueueConfig.QueueParameters): ServerAMQPBridge = {
    connection.serverSetup(
      RemoteServerSetup(handler,
        ServerSetupInfo(exchangeParams, queueParams,
                        exchangeName = inboundExchangeName,
                        queueName    = inboundQueueName,
                        routingKey   = routingKeyToServer))
    )
    this
  }
 ...
}
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Classe ClientAMQPBridge do módulo AMQPBridge.scala.}, label={lst:amqp-client-bridge}]
class ClientAMQPBridge(name: String, 
						connection: SupervisedConnectionWrapper, 
							id: String) extends AMQPBridge(name, connection) {
  
  def setup(handler: MessageHandler, queueParams: QueueConfig.QueueParameters): ClientAMQPBridge = {
    connection.clientSetup(
      RemoteClientSetup(handler,
        ClientSetupInfo(config = queueParams, 
        				name = outboundQueueName + id, 
        				exchangeToBind = inboundExchangeName, 
        				routingKey = "client.%s.%s".format(name,id)))
    )
    this
  }
...
}
\end{lstlisting}

Definimos também um módulo auxiliar chamado \lstinline{AMQP}. Esse módulo possui algumas 
classes com configurações pré-definidas para os objetos a serem criados no \english{message broker}. 
A enumeração \lstinline{StorageAndConsumptionPolicy} define um 
conjunto de valores para políticas de armazenamento e de consumo. 
A enumeração é composta pela combinação da enumeração \lstinline{QueueConfig} 
e \lstinline{ExchangeConfig}. Essas duas enumerações definem as configurações específicas 
e detalhadas para filas e \english{exchanges}, respectivamente. 
A combinação dos seus valores dão semântica às seguintes políticas:

\begin{enumerate}
	\item \lstinline{DURABLE}: Define uma configuração no qual os objetos criados são duráveis,
	ou seja, continuam a existir caso o \english{message broker} seja reiniciado.
	
	\item \lstinline{TRANSIENT}: Define uma configuração no qual os objetos criados são transientes,
	ou seja, deixam de existir caso o \english{message broker} ser reiniciado.
	
	\item \lstinline{EXCLUSIVE_AUTODELETE}: Define uma configuração no qual os objetos estão
	atrelados ao ciclo de vida da aplicação que os criou. Os objetos são removidos
	pelo \english{message broker} quando a conexão em que os objetos foram criados
	é fechada. Ademais, as filas criadas por essa configuração possuem acesso exclusivo
	a um único consumidor. O consumidor fica atrelado ao canal em que a criação da 
	fila ocorreu.
\end{enumerate}

Mostramos na figura \ref{fig:bridges-broker-all-together} como ficaria, da perspectiva
do \english{message broker}, a criação
de uma ponte servidora de nome \lstinline{node1} com duas pontes clientes associadas
a ela. A \english{exchange} e a fila que foram criadas pela ponte servidora estão 
marcadas em preto. Pela figura \ref{fig:bridges-broker-all-together}, podemos notar 
como a \english{exchange} definida pela ponte servidora tem o papel de ponto central
para envio de mensagens para todas as filas criadas para o nó \lstinline{node1}. Podemos
notar também como os padrões definidos para os nomes na classe \lstinline{AMQPBrigde} 
(listagem \ref{lst:amqp-bridge}) são utilizados na criação dos objetos.
A ponte servidora define a fila de entrada de mensagens. As pontes clientes definem as filas
de saída de mensagens. As mensagens roteadas para as filas de saída,
são as mensagens de resposta vindas da ponte servidora. Devemos observar que a ponte servidora
precisa do identificador de uma ponte cliente para poder lhe enviar uma mensagem.

\vspace{1ex}
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.7]{bridges-broker-all-together} 
  	\caption{Estrutura para troca de mensagens via message broker AMQP.}
  	\label{fig:bridges-broker-all-together}
\end{figure}

Segundo a especificação do padrão AMQP \cite{amqp}, as implementações 
de \english{brokers} devem suportar ao menos $256$ filas por \english{virtual host}. 
Contudo, a recomendação é que não haja imposição de limites que não pela disponibilidade 
de recursos. A especificação também menciona que o número mínimo de \english{exchanges} por
\english{virtual host} é de $16$, e faz a mesma observação quanto a não imposição
de limite que não seja pela disponibilidade de recursos. A implementação RabbitMQ
utilizada neste trabalho deixa as limitações a cargo da quantidade de recursos
do sistema hospedeiro. 


\subsection{Gerenciamento de conexões e canais}
\index{Estrutura!message broker amqp!gerenciamento de conexões}
\label{sec:entidades-via-broker-amqp-gerenciamento-conexoes}

O módulo \lstinline{ConnectionPoolSupervisor} é responsável por encapsular os detalhes 
da interação com o \english{message broker}. Como mostrado na subseção \ref{subsec:amqp-rabbit-api}, o envio
de comandos e recebimentos de mensagens com o RabbitMQ acontece por meio de canais
que são abertos em uma conexão. Esses canais não oferecem proteção para acesso concorrente,
deixando a cargo da aplicação fazer a proteção.

A principal missão desse módulo é prover uma implementação segura para acesso concorrente 
aos canais e conexões abertos com o RabbitMQ. Além disso, o módulo
ainda define uma interface simples e clara para as pontes AMQP, abstraindo
toda a responsabilidade em relação à interação com o \english{message broker}. 

Para que os canais possam ser acessados concorrentemente de modo seguro, optamos por
encapsulá-los em atores Akka. A ideia de encapsular o acesso aos canais em atores foi inspirada
na implementação de um dos módulos adicionais do projeto Akka. O módulo AMQP do projeto
Akka abstrai a criação de consumidores e produtores como atores, além de também abstrair
a criação de objetos no \english{message broker}.

A classe \lstinline{SupervisedConnectionWrapper} define uma conexão supervisionada, expondo 
uma interface muito simples com apenas quatro métodos. Os métodos dão suporte a funcionalidades básicas 
para envios de mensagens, fechamento da conexão e configuração, como mostrado na listagem \ref{lst:amqp-supervised}. 
Nessa listagem podemos notar também que o construtor da classe recebe como argumento 
três atores, sendo o primeiro ator um ator referente a conexão, o segundo um ator referente 
ao canal utilizado para recebimento de mensagens (canal de leitura), e por último, o ator referente 
ao canal utilizado para o envio de mensagens (canal de escrita). Esses atores são os responsáveis por
executar efetivamente as ações, já que a classe \lstinline{SupervisedConnectionWrapper}
delega aos atores todas as ações via envios síncronos ou assíncronos de mensagens.

\begin{lstlisting}[frame=tb, caption={Classe SupervisedConnectionWrapper.}, label={lst:amqp-supervised}]
class SupervisedConnectionWrapper(connection: ActorRef, 
									readChannel: ActorRef, writeChannel: ActorRef){
  def close() { ... }
  
  def clientSetup(setupInfo: RemoteClientSetup) { ... }

  def serverSetup(setupInfo: RemoteServerSetup) { ... }

  def publishTo(exchange: String, routingKey: String, 
					message: Array[Byte]) { ... }
}
\end{lstlisting}

As principais classes do módulo \lstinline{ConnectionPoolSupervisor} são:

\begin{itemize}
	\item \lstinline{BridgeConsumer}: É uma implementação de um consumidor padrão
	de mensagens. Essa implementação estende a classe \lstinline{DefaultConsumer}
	do RabbitMQ, e utiliza a implementação do \lstinline{MessageHandler} para a
	notificação de eventos como mensagens recebidas ou mensagens rejeitadas.
	
	\item \lstinline{ChannelActor}: É a feição que define o comportamento inicial
	de um ator responsável por um canal genérico.
	
	\item \lstinline{ReadChannelActor}: É a classe que define o comportamento inicial
	de um ator responsável por um canal de leitura, utilizado para o recebimento de
	mensagens.

	\item \lstinline{WriteChannelActor}: É a classe que define o comportamento inicial
	de um ator responsável por um canal de escrita, utilizado para o envio de mensagens.

	\item \lstinline{ConnectionActor}: É a classe que define o comportamento inicial
	de um ator responsável pela conexão e abertura de canais com o \english{message broker}.
    Uma outra responsabilidade desse ator é supervisionar os atores que lhe
	solicitaram a abertura de canais.
	
	\item \lstinline{AMQPSupervisor}: É a feição que define o comportamento
	padrão a ser utilizado por um ator que será responsável por supervisionar os
	atores de conexão. Essa feição define ainda métodos que interagem
	com a fábrica de conexões do RabbitMQ para a criação de novas conexões.
	
	\item \lstinline{AMQPConnectionFactory}: É a classe raiz da hierarquia
	de supervisão. Essa classe herda de \lstinline{AMQPSupervisor} e
	define o despachador para todos os atores que estarão direta ou indiretamente
	sob supervisão. A classe possui ainda um objeto companheiro que define
	métodos para a criação dos atores de canais e conexões.
	
	\item \lstinline{ConnectionSharePolicy}: É a enumeração que define a política
	de compartilhamento de uma conexão. A enumeração possui apenas dois valores
	que indicam se os canais de escrita e de leitura devem ser abertos na mesma
	conexão, ou se em conexões diferentes. O uso de uma conexão por canal
	permite que a alta atividade em um canal não impacte o outro.		
\end{itemize}

O módulo possui ainda diversas classes menores (\english{case classes}) que são utilizadas
para definir as mensagens que cada ator aceita em sua função \lstinline{receive},
como por exemplo as mensagens \lstinline{RemoteServerSetup} e \lstinline{ServerSetupInfo} 
utilizadas na listagem \ref{lst:amqp-server-bridge}. Um outro exemplo são as mensagens  
\lstinline{RemoteClientSetup} e \lstinline{ClientSetupInfo} utilizadas 
na listagem \ref{lst:amqp-client-bridge}. A figura \ref{fig:amqpbridge-classes-basic} mostra
como os módulos \lstinline{AMQP}, \lstinline{AMQPBrigde} e \lstinline{ConnectionPoolSupervisor} estão
relacionados.

\vspace{1ex}
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.7]{amqpbridge-classes-basic} 
  	\caption{Módulos de acesso ao broker AMQP.}
  	\label{fig:amqpbridge-classes-basic}
\end{figure}

\subsection{O processo de criação dos objetos no \english{message broker}}
\index{Estrutura!message broker amqp!criação dos objetos}
\label{sec:entidades-via-broker-amqp-criacao-dos-objetos}

A criação de objetos como filas e \english{exchanges} no \english{message broker}
é iniciado nas pontes AMQP. O método \lstinline{setup} das classes \lstinline{ServerAMQPBridge} e
\lstinline{ClientAMQPBridge} serve como ponto de entrada para a criação e configuração
dos objetos. A criação de uma ponte AMQP é feita via métodos definidos 
no objeto \lstinline{AMQPBridge} e depende da criação de uma conexão supervisionada. 

A conexão supervisionada é criada pelo objeto \lstinline{AMQPConnectionFactory}. 
Para que essa conexão seja criada, é necessário que os atores que encapsulam a conexão 
e os canais também sejam criados. A primeira instância a ser criada 
é a do ator responsável pela conexão. A criação do ator de conexão é ilustrada na figura 
\ref{fig:new-connection-actor} e acontece em quatro passos:

\begin{enumerate}
	\item uma instância de \lstinline{ConnectionActor} é criada e inicializada;
	
	\item o ator é ligado (\lstinline{link}) ao ator supervisor\footnote{A classe 
	\lstinline{AMQPConnectionFactory} é o ator supervisor de todos os atores de conexão.};
	
	\item a mensagem \lstinline{Connect} é enviada sincronamente para o ator;
	
	\item a mensagem \lstinline{Connect} é processada pelo ator. Seu processamento leva
	a solicitação de uma nova conexão para a fábrica de conexões do RabbitMQ.
	Dependendo do tipo de política definida para o compartilhamento da conexão entre os canais de 
	leitura e escrita, o passo $4$ é executado duas vezes.
	
\end{enumerate}


\vspace{1ex}
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{new-connection-actor} 
  	\caption{Passos para a criação do ator de conexão.}
  	\label{fig:new-connection-actor}
\end{figure}

Uma vez que o ator de conexão foi criado, são criados os atores
responsáveis pelo canal de leitura e pelo canal de escrita. 
A criação do ator responsável pelo canal de leitura acontece é ilustrada
na figura \ref{fig:new-channel-actor} e acontece em seis passos:

\begin{enumerate}
	\item uma instância de \lstinline{ReadChannelActor} é criada e inicializada;
	
	\item o ator é ligado (\lstinline{link}) ao ator supervisor, que neste caso
	é o ator de conexão recém criado;
	
	\item a mensagem \lstinline{StartReadChannel} é enviada sincronamente para o ator;
	
	\item a mensagem \lstinline{StartReadChannel} é processada pelo ator (seu processamento faz
	um envio síncrono da mensagem \lstinline{ReadChannelRequest} para o ator de conexão que foi
	definido como supervisor);
	
	\item o ator de conexão solicita um novo canal à sua conexão de leitura;

	\item o novo canal é enviado como resposta para \lstinline{ReadChannelRequest}.
\end{enumerate}


\vspace{1ex}
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{new-channel-actor} 
  	\caption{Passos para a criação do ator do canal de leitura.}
  	\label{fig:new-channel-actor}
\end{figure}

O processo para criação do ator responsável pelo canal de escrita é bem semelhante,
com diferenças nas mensagens enviadas nos passos $3$ e $4$.
São utilizadas as mensagens \lstinline{StartWriteChannel} e \lstinline{WriteChannelRequest}, respectivamente. 
No passo $5$, o novo canal é solicitado para a conexão de escrita. As conexões de escrita e de leitura,
se referem à mesma instância no caso de uma política de compartilhamento de conexões.

É importante destacar que todos os parâmetros de 
configurações utilizados para a criação de uma conexão, como por exemplo a política
de compartilhamento de conexões e o endereço do \english{message broker}, são lidos de 
um arquivo de propriedades. Os detalhes sobre esse arquivo são apresentados no capítulo
\ref{cap:atores_remotos_amqp}.

Uma vez que os atores de conexão e de canais foram criados, a ponte que está sendo
criada tem seu método \lstinline{setup} executado. A execução do método \lstinline{setup}
tem diferentes passos para cada tipo de ponte. A execução do método \lstinline{setup} da classe 
\lstinline{ServerAMQPBridge} é ilustrada na figura \ref{fig:server-amqp-bridge-setup} e 
acontece em oito passos:

\begin{enumerate}
	\item o método \lstinline{setup} da classe \lstinline{SupervisedConnection}
	é invocado;
	
	\item a mensagem \lstinline{RemoteServerSetup} é enviada para o canal de escrita
	com as configurações dos objetos a serem criados;
	
	\item o processamento da mensagem \lstinline{RemoteServerSetup} leva a criação
	de uma \english{exchange} direta com a configuração de durabilidade solicitada;
	
	\item a implementação de \lstinline{MessageHandler} informada é utilizada na
	associação do tratador de mensagens rejeitadas (\english{return listener});
	
	\item a mensagem \lstinline{RemoteServerSetup} é enviada para o canal de leitura
	com as configurações dos objetos a serem criados;
	
	\item o processamento da mensagem \lstinline{RemoteServerSetup} leva a criação
	de uma fila com a configuração de durabilidade solicitada;
	
	\item o \english{binding} entre a fila recém criada e a \english{exchange}
	criada no passo $3$ é definido;
	
	\item a implementação de \lstinline{MessageHandler} informada é utilizada na
	associação do consumidor na fila criada no passo $6$.	
\end{enumerate}

\vspace{1ex}
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{server-amqp-bridge-setup} 
  	\caption{Passos de configuração da classe ServerAMQPBridge.}
  	\label{fig:server-amqp-bridge-setup}
\end{figure}

Vale lembrar que a criação de \english{exchanges} e filas pela biblioteca Java do RabbitMQ
verifica a existência do objeto antes de sua criação. Caso já exista um objeto de mesmo
nome e com as mesmas características, o objeto não é recriado e a execução prossegue
normalmente. Podemos notar que os passos são divididos entre os
canais. O canal de leitura fica responsável por definir a fila e associar o consumidor
padrão, algo que se torna mandatório por conta de podermos utilizar o consumidor 
como único e exclusivo da fila.

A execução do método \lstinline{setup} da classe \lstinline{ClientAMQPBridge} 
é ilustrada na figura \ref{fig:client-amqp-bridge-setup} e acontece em sete passos:

\begin{enumerate}
	\item o método \lstinline{setup} da classe \lstinline{SupervisedConnection}
	é invocado;
	
	\item a mensagem \lstinline{RemoteClientSetup} é enviada para o canal de escrita
	com as configurações dos objetos a serem criados;
		
	\item a implementação de \lstinline{MessageHandler} informada é utilizada na
	associação do tratador de mensagens rejeitadas;
	
	\item a mensagem \lstinline{RemoteClientSetup} é enviada para o canal de leitura
	com as configurações dos objetos a serem criados;
	
	\item o processamento da mensagem \lstinline{RemoteClientSetup} leva a criação
	de uma fila que rotulamos como ``fila de saída'' que possui a configuração 
	de durabilidade solicitada;
	
	\item o \english{binding} entre a fila recém criada e a \english{exchage}
	definida pela ponte servidora correspondente é criado;
	
	\item a implementação de \lstinline{MessageHandler} informada é utilizada na
	associação do consumidor na fila criada no passo $5$.	
\end{enumerate}

\vspace{1ex}
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{client-amqp-bridge-setup} 
  	\caption{Passos de configuração da classe ClientAMQPBridge.}
  	\label{fig:client-amqp-bridge-setup}
\end{figure}

O Akka mantém um registro com todos os atores em execução. Nesse registro é possível 
localizar um ator por seu identificador e até mesmo
interromper a execução de todos os atores do registro. Para evitar efeitos colaterais entre
as interações do registro de atores do Akka com a nossa implementação, optamos por remover
a hierarquia que definimos do registro do Akka. Isso acontece após a inicialização de cada
ator via método \lstinline{Actor.registry.unregister(actor)}. Nossa hierarquia de
atores, por sua vez, pode ter sua execução interrompida via método 
\lstinline{AMQPConnectionFactory.shutdownAll}.


\subsection{Envio e recebimento de mensagens via pontes AMQP}
\index{Estrutura!message broker amqp!envios e recebimentos via pontes}
\label{sec:entidades-via-broker-amqp-envios-recebimentos}

O envio de mensagens de uma ponte cliente para uma ponte servidora acontece na invocação 
do método \lstinline{sendMessageToServer} da classe \lstinline{ClientAMQPBridge}. A
execução do método é ilustrada na figura \ref{fig:bridge-send-message-flow} e acontece em
quatro passos:

\begin{enumerate}
	\item o método \lstinline{sendMessageToServer} foi invocado por alguma classe que deseja
	enviar uma mensagem;
	
	\item o método \lstinline{publishTo} da classe \lstinline{SupervisedConnectionWrapper}
	é invocado (a invocação do método utiliza como argumentos a mensagem a ser enviada,
	o nome da \english{exchange} que foi criada com base no nome da ponte e o nome do 
	\english{binding} entre a \english{exchange} e a fila de entrada da ponte servidora);
	
	\item o método \lstinline{publishTo} faz um envio assíncrono da mensagem 
	\lstinline{BasicPublish} ao ator responsável pelo canal de escrita (a mensagem
	\lstinline{BasicPublish} possui informações sobre detalhes do envio a ser executado
	como por exemplo, se o envio deve ser mandatório e o consumo imediato);	
	
	\item o método \lstinline{basicPublish} é invocado na classe \lstinline{Channel} do 
	RabbitMQ como resultado do processamento da mensagem \lstinline{BasicPublish} (os 
	argumentos utilizados para execução do método são os que foram passados junto à
	mensagem \lstinline{BasicPublish}).
\end{enumerate}

\vspace{1ex}
\begin{figure}[hbtp]
	\centering
	\includegraphics[scale=0.5]{bridge-send-message-flow} 
  	\caption{Passos do envio de mensagens de um cliente via pontes AMQP.}
  	\label{fig:bridge-send-message-flow}
\end{figure}

Optamos por fazer envios mandatórios, porém sem consumo imediato. Isso significa que
a fila de destino deve obrigatoriamente existir no momento do envio, mas a mensagem não 
precisa ser consumida no momento do depósito na fila. O trecho de código que executa o
passo $4$ é mostrado na listagem \ref{lst:basic-publish}. Os valores para as variáveis
\lstinline{mandatory} e \lstinline{immediate} são respectivamente \lstinline{true} e 
\lstinline{false}. Caso ocorra um envio massivo de mensagens, o consumo imediato das mensagens 
pode não ser possível, acarretando na devolução de mensagens para o remetente.
Decidimos por não forçar um consumo imediato para que não sobrecarregar 
as implementações dos consumidores, minimizando a possibilidade de rejeições de mensagens. 

Ainda assim, caso uma mensagem seja rejeitada e devolvida, o método 
\lstinline{handleRejected} do \lstinline{MessageHandler} é invocado para que alguma ação 
seja tomada com a mensagem rejeitada. Mensagens podem ser rejeitadas por basicamente dois motivos:
\entry{(i)} uma mensagem não pode ser roteada para uma fila pois a chave de roteamento
utilizada no envio não está associada à \english{exchange}; \entry{(ii)} uma mensagem foi depositada
em alguma fila, porém a fila foi removida. Nesse caso, todas as mensagens são devolvidas
aos seus respectivos remetentes.

O envio de mensagens de uma ponte servidora para uma ponte cliente é similar ao mostrado
na figura \ref{fig:bridge-send-message-flow}. A diferença está no nome do \english{binding}
que é utilizado. O nome do \english{binding} utilizado é definido com base no identificador do cliente.

\begin{lstlisting}[frame=tb, numbers=none, caption={Envio de mensagem mandatória e não imediata.}, label={lst:basic-publish}]
... 
case BasicPublish(exchange, routingKey, mandatory, immediate, message) => 
{
	channel.foreach {
		ch => ch.basicPublish(exchange, routingKey, mandatory, immediate, null, message)
	}
}
...
\end{lstlisting}

O processo de roteamento da mensagem acontece como explicado na sessão 
\ref{subsec:amqp-modelo-envios}. A mensagem é enviada
para a \english{exchange} relacionada a \lstinline{ClientAMQPBridge}. 
O identificador do remetente 
(atributo \lstinline{id} da listagem \ref{lst:amqp-client-bridge}) deve ser enviado
como parte da mensagem e esse envio é de responsabilidade do criador da mensagem. 
Essa identificação será utilizada como argumento do método \lstinline{sendMessageTo} 
no caso de haver uma mensagem de resposta. O recebimento de uma mensagem por uma ponte 
servidora é ilustrado na figura \ref{fig:bridge-message-flow} e acontece em três passos:

\begin{enumerate}
	\item o \english{message broker} repassa a mensagem ao canal de leitura;
	
	\item o método \lstinline{handleDelivery} da classe \lstinline{BridgeConsumer}
	é invocado;
	
	\item o método \lstinline{handleReceived} da implementação de \lstinline{MessageHandler}
	(definida durante a configuração da ponte servidora) é executado pelo \lstinline{BridgeConsumer}
	para que a mensagem possa ser processada.
\end{enumerate}

\vspace{1ex}
\begin{figure}[!h]
	\centering
	\includegraphics[scale=0.5]{bridge-message-flow} 
  	\caption{Passos para recebimento de mensagens via pontes AMQP.}
  	\label{fig:bridge-message-flow}
\end{figure}

Devemos recordar que a execução do método \lstinline{handleReceived}
deve devolver um valor booleano. Esse valor indica se o recebimento deve ser confirmado  
para então a mensagem ser removida da fila pelo \english{message broker}. Os passos utilizados
para o recebimento de uma mensagem por uma ponte cliente são idênticos aos ilustrados
na figura \ref{fig:bridge-message-flow}.

