\chapter{Introdução}
\label{cap:introducao}        

A proposta deste trabalho é explorar a potencial sinergia entre duas classes de sistemas 
de \english{software} baseados em troca de mensagens. A primeira classe, usada em ambientes 
corporativos, compreende os sistemas de \english{middleware} orientados a mensagens (MOMs)
e os \english{message brokers}. A segunda, voltada para a criação de programas concorrentes,
é composta pelas implementações do modelo de atores.

\section{Troca de mensagens em ambientes corporativos}

Sistemas de \english{middleware} orientados a mensagens
trabalham com troca assíncrona de mensagens. As mensagens enviadas são armazenadas 
e mantidas em filas até que o destinatário esteja pronto para fazer o recebimento e 
processamento. Em todo envio de mensagem há uma entidade que desempenha o papel de 
produtor (remetente) e outra que desempenha o papel de consumidor (destinatário) da mensagem. 
Não existe vínculo entre esses papéis e os papéis de cliente (usuário de um serviço) 
e servidor (provedor de um serviço), tradicionalmente usados em sistemas baseados 
em \english{remote procedure call} (RPC), já que ambos enviam e recebem mensagens. 
No contexto de MOMs, os papéis de servidor ou cliente são definidos pela semântica da
troca de mensagens. Uma entidade pode estar atuando ora como provedora de um serviço, 
ora como cliente de um serviço. Portanto, os termos ``cliente'' e ``servidor'', não são
aplicáveis nesta classe de sistemas do mesmo modo como são aplicáveis em sistemas baseados em RPC.

MOMs formam uma base que simplifica o desenvolvimento de aplicações distribuídas, permite 
interoperabilidade com baixo acoplamento e provê suporte para o tratamento robusto de 
erros em caso de falhas. Eles são frequentemente apresentados como uma tecnologia que pode 
mudar a maneira com que sistemas distribuídos são construídos \cite{alonso}. 

A garantia da entrega de mensagens é uma das características mais importantes dos MOMs.
Filas transacionais são utilizadas para garantir que mensagens recebidas pelo 
MOM sejam salvas de modo persistente. A remoção de uma mensagem de uma fila transacional
ocorre somente após a confirmação do seu recebimento pelo destinatário. 
No caso de avarias no sistema, mensagens
previamente salvas pelo MOM e que não tiveram seu recebimento confirmado não são perdidas.
Uma vez que o sistema tenha sido restabelecido, essas mensagens podem ser entregues aos seus
destinatários. A retirada de uma mensagem de uma fila transacional ocorre como parte de uma transação atômica que pode incluir também outras operações, como envios de mensagens e atualizações 
em bancos de dados, bem como outras retiradas de mensagens.

MOMs tradicionalmente estabelecem ligações ponto-a-ponto entre sistemas,
sendo um tanto inflexíveis no que diz respeito ao roteamento e filtragem de mensagens. 
\english{Message brokers} são descendentes diretos de MOMs que eliminam essas limitações. 
Eles agem como intermediários e provêm maior flexibilidade para roteamento e filtragem, 
além de permitirem que se adicione lógica de negócios ao processamento
de mensagens no nível do próprio \english{middleware}. 

Os protocolos usados por \english{message brokers} variam de produto para produto.
A especificação de Java \english{Messaging Service} (JMS) define uma API padrão 
para que programas Java possam interagir com \english{message brokers}. Boa parte dos 
\english{message brokers} têm implementações do padrão JMS. Dentre os mais conhecidos, podemos 
destacar JBoss Messaging \cite{jboss-messaging}, IBM Websphere MQ \cite{ibm-mqseries} 
(mais conhecido como MQ Series) e Apache Active MQ \cite{apache-activemq}. 

O padrão AMQP \cite{amqp} (\english{Advanced Message Queuing Protocol}) é uma proposta recente 
de padronização de um protocolo para \english{message brokers}. Foi criada por um conjunto de 
empresas (Red Hat, JPMorgan Chase, Cisco Systems, entre outras), com o objetivo de viabilizar 
tanto o desenvolvimento quanto a disseminação de um protocolo padrão para esse tipo de sistema.

\section{Modelos não convencionais de programação concorrente}
Nos últimos anos, o aumento da velocidade de \english{clock} passou a
não acompanhar mais o aumento de transistores em processadores por questões físicas, 
como aquecimento e dissipação, alto consumo de energia e vazamento de corrente elétrica. 
Por conta dessas e de outras limitações, a busca por ganhos de capacidade de processamento 
levou à construção de processadores com múltiplos núcleos (\english{multicore}).

Um dos principais impactos que processadores \english{multicore} causam no desenvolvimento 
de programas está relacionado com o modo com que programas são escritos. Para usufruírem de ganhos 
de desempenho com esses processadores, programas precisam ser escritos de forma 
concorrente \cite{sutter-free-lunch-is-over}, uma tarefa que não é simples. A maioria das 
linguagens de programação e dos ambientes de desenvolvimento não são
adequados para a criação de programas concorrentes \cite{sutter-concurrent-revolution}.

A abordagem convencional ao desenvolvimento de programas concorrentes é baseada
em travas e variáveis condicionais. Em linguagens orientadas a objetos, como Java e C\#, 
cada instância implicitamente possui sua própria trava, e travamentos podem acontecer em 
blocos de código marcados como sincronizados. Essa abordagem não permite que travas sejam
compostas de maneira segura, criando situações propensas a bloqueios e 
impasses (\english{deadlocks}). A composição de travas é necessária quando há
mais de uma instância envolvida na ação a ser executada de modo exclusivo. Existem ainda 
outras dificuldades no uso de travas, como esquecimento de se obter a trava de alguma 
instância, obtenção excessiva de travas, obtenção de travas de instâncias	 
erradas, obtenção de travas em ordem errada, manutenção da consistência do sistema na 
presença de erros, esquecimento de sinalização em variáveis de condição ou de se testar 
novamente uma condição após o despertar de um estado de espera \cite{sj:bc}. Essas 
dificuldades mostram que a abordagem convencional, baseada em travas,
é inviável para uma programação concorrente modular, e ajudaram a impulsionar a pesquisa de
abordagens alternativas à programação concorrente convencional.

Dois modelos de programação concorrente não convencionais vem ganhando espaço recentemente. 
O primeiro deles é a memória transacional implementada por \english{software} 
(\english{software transactional memory}, ou STM) \cite{STM}, um mecanismo de controle 
de concorrência análogo às transações de bancos de dados. O controle de acesso à memória 
compartilhada é responsabilidade da STM. Cada transação é um trecho de código que executa 
uma série atômica de operações de leitura e escrita na memória compartilhada.		

O segundo modelo não convencional de programação concorrente é o modelo de atores. 
Atores \cite{Agha86} são definidos como agentes computacionais que possuem uma caixa de
correio e um comportamento. Uma vez que o endereço da caixa de correio de um ator é conhecido, 
mensagens podem ser adicionadas à caixa para processamento assíncrono. No modelo de atores,
o envio de uma mensagem é desacoplado do processamento da mensagem pelo ator.

\section{A linguagem Scala}

Scala \cite{scala-overview} é uma linguagem moderna, que possui tipagem estática e inferência de tipos
e que unifica os paradigmas de programação funcional e orientado a objetos. Vem sendo 
desenvolvida desde $2001$ no laboratório de métodos de programação da EPFL 
(\english{École Polytechnique Fédérale de Lausanne}). O código escrito em Scala pode ser 
compilado para execução tanto na JVM 
(\english{Java Virtual Machine}) quanto na CLR (\english{Common Language Runtime}).
A criação da linguagem Scala foi impulsionada pela necessidade de um bom suporte
para o desenvolvimento de sistemas por componentes e escaláveis. 

A linguagem foi desenvolvida para interoperar bem tanto com Java quanto com C\#, e adota
parte da sintaxe dessas linguagens, além de compartilhar
a maioria dos operadores básicos, tipos de dados e estruturas de controle. 
Contudo, para atingir seus objetivos, Scala abre mão de algumas convenções enquanto 
adiciona novos conceitos. Algumas de suas características são:

\begin{itemize}
	\item Scala possui certa semelhança com Java e C\#, de modo que tanto programas
	escritos em Scala podem utilizar bibliotecas escritas em Java ou C\#, quanto o
	inverso.
	
	\item Scala possui um modelo uniforme para objetos, em que todo valor é um objeto
	e toda operação é um método.
	
	\item Scala é uma linguagem funcional e todas as funções são valores de
	primeira classe. No contexto de linguagens de programação, valores de primeira
	classe são entidades que podem ser criadas em tempo de execução, utilizadas 
	como parâmetros, devolvidas por uma função, ou ainda atribuídas a variáveis.
	
	\item Scala permite construções via extensão de classes e combinações de feições
	(\english{traits}). Feições possuem definições de métodos e campos assim
	como uma classe abstrata, porém não definem construtores. São
	importantes unidades para reuso de código em Scala, já que classes ou objetos podem
	ser combinados (\english{mixin}) com diversas feições.
	
	\item Scala permite a decomposição de objetos via casamento de padrões.
	
	\item Scala possui suporte ao tratamento de XML (\english{extended markup language}) 
	na própria sintaxe da linguagem.
	
	\item Scala não possui o conceito de membros de classes estáticos. A linguagem
	possui o conceito de \english{singleton object}, que representa uma instância
	única de uma classe. \english{Singleton objects} definidos com a construção
	\lstinline{object} ao invés de \lstinline{class}. Um \english{singleton object} que
	tenha o mesmo nome que uma classe é denominado objeto acompanhante 
	(\english{companion object}) dessa classe.
	
	\item Scala possui suporte a \english{currying}, que em conjunto com as funções de ordem
	superior, permite a criação de novas estruturas de controle.
\end{itemize}

Optamos por desenvolver este trabalho em Scala tanto pela linguagem ser executável 
na JVM e interoperar naturalmente com Java, como por suas características
proverem facilidades para a implementação de atores.

\section{Objetivos}
\label{sec:objetivo}

Este trabalho teve como objetivo criar uma implementação em Scala do modelo de atores que use 
o padrão AMQP para o transporte de mensagens entre atores remotos. Geramos um protótipo 
baseado na implementação do modelo de atores do projeto Akka. Substituímos o mecanismo
de transporte do Akka por um que utiliza um \english{message broker} AMQP. 

\section{Contribuições}
\label{sec:contribucoes}

As principais contribuições deste trabalho são as seguintes:

\begin{itemize}  
  \item uma implementação do modelo de atores que é escrita em Scala e utiliza um \english{message broker} 
  AMQP como mecanismo de transporte de mensagens entre atores remotos;

  \item uma camada de abstração para acesso à biblioteca de conexão do \english{message broker} AMQP. 
  Criada para dar suporte ao nosso protótipo, essa camada foi implementada com atores e
  sua principal motivação é prover acesso concorrente seguro aos serviços oferecidos pela biblioteca
  de conexão do \english{message broker}.
\end{itemize}

\section{Organização do Trabalho}
\label{sec:organizacao_trabalho}

No Capítulo \ref{cap:atores}, apresentamos o modelo de atores, sua semântica e algumas
das implementações do modelo. No Capítulo \ref{cap:atores_akka}, analisamos em maiores 
detalhes a implementação do modelo de atores feita no projeto Akka. No Capítulo
\ref{cap:amqp}, apresentamos as camadas do padrão AMQP, mencionamos algumas das implementações
desse protocolo e examinamos algumas das principais classes da biblioteca 
para clientes Java da implementação utilizada neste trabalho. 
No capítulo \ref{cap:estrutura-troca-mensagens-amqp}, apresentamos a camada de abstração
criada para prover acesso concorrente seguro às classes de comunicação da biblioteca para clientes
Java da implementação de AMQP que utilizamos. No capítulo \ref{cap:atores_remotos_amqp}, apresentamos nossa implementação 
de atores remotos que utiliza a camada de abstração descrita no capítulo \ref{cap:estrutura-troca-mensagens-amqp}.
No Capítulo \ref{cap:resultados} apresentamos uma comparação de desempenho entre a implementação 
original de atores remotos do projeto Akka e o protótipo desenvolvido neste trabalho. No Capítulo 
\ref{cap:trab-relacionados} apresentamos alguns trabalhos que possuem relação com nosso trabalho.

Finalmente, no Capítulo \ref{cap:conclusoes}, apresentamos sugestões para pesquisas futuras 
e discutimos as conclusões obtidas neste trabalho. 

