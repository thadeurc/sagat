%% ------------------------------------------------------------------------- %%
\chapter{Atores}
\label{cap:atores}

Apresentamos neste capítulo informações sobre o modelo de atores (seção \ref{sec:atores-modelo}),
um breve histórico sobre alguns estudos relacionados (seção \ref{sec:atores-historico}),
a computação em um sistema de atores (seção \ref{sec:atores-computacao}) e por fim
algumas referências para implementações (seção \ref{sec:atores-implementacoes}).

\section{Breve histórico}
\label{sec:atores-historico}
\index{Atores!Histórico}

O modelo de atores foi originalmente proposto por Carl Hewitt em $1971$ \cite{hewitt:71}. 
O termo ator foi originalmente utilizado para descrever entidades ativas que analizavam 
padrões para iniciar atividades. O conceito de atores passou então a ser explorado pela 
comunidade científica e em $1973$, a noção de atores se aproximou do conceito de agentes existente
na área de inteligência artificial distribuída, por possuírem intenções, recursos,
monitores de mensagem e um agendador \cite{Hewitt:1973}.

Em $1975$, Irene Greif desenvolveu um modelo abstrato de atores orientado 
a eventos, onde cada ator armazenava eventos locais para que se pudesse analizar 
a relação causal entre os eventos. Baker e Hewitt formalizaram um conjunto
de axiomas para computação concorrente em $1977$. Desse estudo surgiu uma propriedade 
importante onde a ordem em que eventos são gerados deve ser obedecida a fim de prever 
violações de causalidade. No mesmo ano, Hewitt apresentou um estudo sobre como o 
entendimento dos padrões de troca de mensagens entre atores, pode ajudar na definição de 
estruturas de controle. Esse estudo demonstrou o uso do estilo de passagem de continuações
no modelo de atores.	

O conceito de guardião foi definido em $1978$ por Attardi e Hewitt. Um guardião é 
uma entidade que regula o uso de recursos compartilhados. Guardiões incorporam 
explitamente a noção de estado e são responsáveis por agendar o acesso e fazer a 
proteção dos recursos. Hewitt e Atkinson definiram em $1979$ um conceito relacionado ao 
de guardião denominado seriador (\english{serializer}). Um seriador age como um monitor, 
porém, ao invés de aguardar sinais explícitos de processos, seriadores procuram ativamente 
por condições que permitam que processos em espera possam voltar a ser executados. 
Em $1987$, Henry Lieberman implementou em Lisp a linguagem Act1 \cite{Lieberman:1987}, 
uma linguagem de atores com guardiões, seriadores e atores chamados de ``trapaceiros'' 
(\english{rock-bottom}). Atores trapaceiros são atores que podem burlar as regras do modelo
de atores para, por exemplo, usar dados primitivos e funções da linguagem usada em sua
implementação.

Gul Agha definiu em $1986$ um sistema simples de transição para atores. Em seu trabalho foi
desenvolvido o conceito de configurações, recepcionistas e atores externos. 
Atores recepcionistas são atores que ocultam a existência outros atores de um
sistema de atores, agindo como intermediários no recebimento das mensagens. 
O uso de atores recepcionistas permite uma forma de encapsulamento, já que eles acabam 
agindo como interface para atores externos. Esse modelo foi implementado na linguagem Acore 
por Carl Manning em $1987$, e na linguagem Rosette por Tomlinson e outros em $1989$.

\section{Modelo}
\label{sec:atores-modelo}
\index{Atores!Modelo}
O modelo de atores é um modelo para programação concorrente em sistemas distribuídos, 
que foi apresentado como uma das possíveis alternativas ao uso de memória compartilhada e travas. 
Atores são agentes computacionais autônomos e concorrentes que possuem uma fila de mensagens
e um comportamento \cite{Agha86}.

O modelo define que toda interação entre atores deve acontecer via trocas assíncronas
de mensagens. Uma vez que o endereço da fila de mensagens de um ator é conhecido, 
mensagens podem ser enviadas ao ator. As mensagem enviadas são armazenadas para processamento 
assíncrono, desacoplando o envio de uma mensagem do seu processamento. 

Toda computação em um sistema de atores é resultado do processamento de uma mensagem. 
Cada mensagem recebida por um ator é mapeada em uma $3$-tupla que consiste de:

\begin{enumerate}
	\item um conjunto finito de envios de mensagens para atores cujas filas
	tenham seus endereços conhecidos (um desses atores pode ser o próprio ator destinatário
	da mensagem que está sendo processada);
	
	\item um novo comportamento, que será usado para processar a próxima mensagem
	recebida;
	
	\item um conjunto finito de criações de novos atores.
\end{enumerate}

Um ator que recebe mensagens faz o processamento individual de cada mensagem em 
uma execução atômica. Cada execução atômica consiste no conjunto de todas as ações 
tomadas para processar a mensagem em questão, não permitindo intercalações no 
processamento de duas mensagens.

Em um sistema de atores, envios de mensagens (também chamados de comunicações) são
encapsulados em tarefas. Uma tarefa é uma $3$-tupla que consiste em um identificador
único, o endereço da fila do ator destinatário e a mensagem. A configuração
de um sistema de atores é definida pelos atores que o sistema contém e pelo conjunto
de tarefas não processadas. É importante ressaltar que o endereço da fila de mensagens 
na tarefa deve ser válido, ou seja, ele deve ter sido previamente
comunicado. Há três maneiras de um ator ao receber uma mensagem \emph{m}, passar
a conhecer um destinatário no qual o ator pode enviar uma mensagem:

\begin{enumerate}
	\item O ator já conhecia o endereço da fila do destinatário antes
		do recebimento da mensagem \emph{m};

	\item O endereço fila estava presente na mensagem \emph{m};
	
	\item Um novo ator foi criado como resultado do processamento da mensagem \emph{m}.
\end{enumerate}

Um aspecto importante que faz parte o modelo de atores é existência de igualdade durante a
execução (\english{fairness}). Sem essa propriedade, um sistema de atores teria ambos a garantia 
de entrega e a componibilidade comprometida \cite{Agha98afoundation}.
No contexto de atores, garantia de entrega signfica que
uma mensagem que foi depositada na fila de mensagens de um ator, não deve ficar armazenada
indefinidamente sem ser eventualmente repassada para o ator fazer o seu processamento. 
A ordem de chegada de mensagens obedece uma ordem linear, e fica a cargo da implementação
do modelo arbitrar em casos de conflito onde duas mensagens sejam recebidas no mesmo momento.
O modelo assume uma entrega enventual, pois podem ocorrer casos onde o ator esteja em um estado 
não propício a receber novas mensagens, com por exemplo, estar executando um laço infinito ou
alguma operação ilegal. Vale destacar que a garantia de entrega de mensagens não assume que 
as mensagens entregues tenham um processamento semanticamente significativo. O processamento de 
uma mensagem depende do do ator. Alguns atores poderiam, por exemplo, optar por descartar 
todas as mensagens recebidas. 

Gul Agha, em sua definição da semântica do modelo de atores \cite{Agha86}, 
afirma que ``em qualquer rede real de agentes computacionais, não é possível prever quando uma 
mensagem enviada por um agente será recebida por outro''. A afirmação é enfatizada para redes 
dinâmicas, onde novos agentes podem ser criados ou destruídos, e reconfigurações como migrações 
de agentes para diferentes nós podem acontecer. Em sua conclusão, Agha afirma que um modelo 
realista deve assumir que a ordem de recebimento das mensagens não é determinística, mas sim 
arbitrária e desconhecida. O não determinismo na ordem de recebimento das mensagens pelo ator não 
interefe na garantia de entrega de mensagens.

O comportamento de um ator define como o ator irá processar a próxima mensagem recebida.
Ao processar uma mensagem, o ator deve definir o comportamento substituto que será utilizado para
processar a próxima mensagem que lhe for entregue. Mostramos na figura \ref{fig:atores-estado}
a máquina de estados de um ator processando uma mensagem recebida e definindo seu novo 
comportamento. Nessa figura, o ator $A$ com comportamento inicial é $B_1$ retira a mensagem 
$m_1$ de sua fila e faz o processamento da mensagem. Para esse exemplo, o processamento da 
mensagem $m_1$ resultou na criação de um novo ator $A'$, com comportamento inicial $B_{1'}$, 
e no envio da mensagem $m_{1'}$ do ator $A$ para o ator $A'$. O ator $A$ passa a ter o 
comportamento $B_2$, que será usado no processamento da mensagem $m_2$. Vale ressaltar que o 
comportamento substituto não precisa necessariamente ser diferente do comportamento anterior. 
Por exemplo, os comportamentos $B_1$ e $B_2$ podem ser comportamentos idênticos.

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics{ator-state-machine} 
  	\caption{Máquina de estados de um ator.}
  	\label{fig:atores-estado}
\end{figure}

No modelo de atores, a real localicação de um ator não afeta a interação com outros atores. 
Os atores que um ator conhece podem estar distribuídos em diferentes núcleos de um processador,
ou mesmo em nós diferente em uma rede de computadores. A transparência da localidade
abstrai a infra-estrutura e permite que programas sejam desenvolvidos de modo distribuído,
ou seja, sem que a real localização de seus atores seja conhecida. Duas consequências diretas da  
transparência da localidade são o encapsulamento do estado do ator e
a capacidade de se mover atores entre os diferentes nós de uma rede de computadores. 

Apesar de o modelo ser bem explícito e claro em relação a interação ser via troca de mensagens e
dizer que o estado de um ator não deve ser compartilhado, implementações 
poderiam permitir que o estado interno de um ator fosse acessado diretamente por outro ator. 
Por exemplo, um ator em sua pilha de execução fazer invocação de algum método do outro ator. 
Mesmo que a interface de um ator não permita o compartilhamento do seu estado interno que não
seja via troca de mensagens, as mensagens enviadas podem expor um compartilhamento indesejado
caso não sejam imutáveis e passadas por cópia. 

Mobilidade é definida como a habilidade de se poder mover uma computação de um nó para outro,
e pode ser classificada como mobilidade fraca ou mobilidade forte. Mobilidade fraca é a 
habilidade de tranferir código entre nós, enquanto que mobilidade forte é definida como a 
habilidade de tranferir ambos o código e o estado da execução \cite{Fuggetta:1998}. Em um
sistema baseado em atores, mobilidade fraca permite que atores que não tenham mensagens em suas
filas e não estão fazendo processamento algum sejam tranferidos para outros nós.

Pelo fato de o modelo de atores prover transparência de localidade e encapsulamento, a mobilidade
se torna natural. Mover atores entre diferentes nós em um sistema de atores é uma necessidade
importante para se obter um melhor desempenho, tolerância a falhas e sistemas reconfiguráveis 
\cite{Panwar:1994}. 

A semântica padrão do modelo de atores apresentada nesta seção objetiva proporcionar
uma arquitetura modular e componível \cite{Agha98afoundation} e um melhor desempenho para 
sistemas concorrentes e distribuídos, em particular para situações onde as aplicações
precisem de escalabilidade \cite{Kim95}.

\section{Implementações}
\index{Atores!Implementações}
\label{sec:atores-implementacoes}
%% comtentar do paper do actor frameworks for the jvm platform. Dizer que nele
%% ficam ex
Karmani e Agha argumentam as vantagens da preservação dessas propriedades e 
fazem uma comparação de algumas implementações para a JVM em \cite{karmani2009}.



\section{Computações em um Sistema de Atores}
\index{Atores!Computação}
\label{sec:atores-computacao}
%% aqui eu acho legal dar um exemplo? jogar fora? colocar metade do que esta em cima aqui dentro?
%% poderia escrever um ator em erlang ou scala que fosse um contador - o exemplo que dei no
%% techday