%% ------------------------------------------------------------------------- %%
\chapter{Atores}
\label{cap:atores}

O modelo de atores é um modelo para programação concorrente em sistemas distribuídos, 
que foi apresentado como uma das possíveis alternativas ao uso de memória compartilhada e travas. 
Atores são agentes computacionais autônomos e concorrentes que possuem uma caixa de correio 
e um comportamento \cite{Agha86}.

\section{Breve histórico}
\label{sec:atores-historico}
\index{Atores!Histórico}

O modelo de atores foi originalmente proposto por Carl Hewitt em $1971$ \cite{hewitt:71}. 
O termo ator foi originalmente utilizado para descrever entidades ativas que analizavam 
padrões para iniciar atividades. O conceito de atores passou então a ser explorado pela 
comunidade científica e, em $1973$, a noção de atores se aproximou do conceito de agentes existente
na área de inteligência artificial distribuída por possuírem intenções, recursos,
monitores de mensagem e um agendador \cite{Hewitt:1973}.

Em $1975$, Irene Greif desenvolveu um modelo abstrato de atores orientado 
a eventos, onde cada ator armazenava eventos locais para que se pudesse analizar 
a relação causal entre os eventos. Baker e Hewitt formalizaram um conjunto
de axiomas para computação concorrente em $1977$. Desse estudo surgiu uma propriedade 
importante onde a ordem que os eventos são gerados deve ser obedecida a fim de prever 
violações de causalidade. No mesmo ano, Hewitt apresentou um estudo sobre como o 
entendimento dos padrões de troca de mensagens entre atores pode ajudar na definição de 
estruturas de controle. Esse estudo demonstrou o uso do estilo de passagem de continuações
no modelo de atores.	

O conceito de guardião foi definido em $1978$ por Attardi e Hewitt. Um guardião é 
uma entidade que regula o uso de recursos compartilhados. Guardiões incorporam 
explitamente a noção de estado e são responsáveis por agendar o acesso e fazer a 
proteção dos recursos. Hewitt e Atkinson definirão em $1979$ um conceito relacionado ao 
de guardião denominado seriador (\english{serializer}). Um seriador age como um monitor, 
porém, ao invés de aguardar sinais explícitos de processos, seriadores procuram ativamente 
por condições que permitam que processos em espera possam voltar a ser executados. 
Em $1987$, Henry Lieberman implementou em Lisp a linguagem Act1 \cite{Lieberman:1987}, 
uma linguagem de atores com guardiões, seriadores e atores chamados de ``trapaceiros'' 
(\english{rock-bottom}). Atores trapaceiros são atores que podem burlar as regras do modelo
de atores para, por exemplo, usar dados primitivos e funções da linguagem usada para a sua
implementação.

Gul Agha definiu em $1986$ um sistema simples de transição para atores. Em seu trabalho foi
desenvolvido o conceito de configurações, recepcionistas e atores externos. Esse modelo
foi implementado na linguagem Acore por Carl Manning em $1987$, e na linguagem
Rosette por Tomlinson e outros em $1989$.

\section{O Modelo}
\label{sec:atores-modelo}
\index{Atores!Modelo}

%% tem q falar de encapsulamento, comentar de recepcionistas 

O modelo define que a interação dos atores deve acontecer via trocas assíncronas
de mensagens. Uma vez que o endereço da caixa de correio de um ator é conhecido, 
mensagens podem ser enviadas para processamento assíncrono, desacoplando o envio
de uma mensagem do seu processamento.
Toda computação em um sistema de atores é resultado do processamento de uma mensagem. 
Cada mensagem recebida por um ator é mapeada em uma $3$-tupla que consiste de:

\begin{enumerate}
	\item um conjunto finito de envios de mensagens para atores cujas caixas de correio
	têm endereços conhecidos (um desses atores pode ser o próprio ator destinatário
	da mensagem que está sendo processada);
	
	\item um novo comportamento, que será usado para processar a próxima mensagem
	recebida;
	
	\item um conjunto finito de criações de novos atores.
\end{enumerate}

O ator que recebe as mensagens faz o processamento individual de cada mensagem em 
uma execução atômica. Cada execução atômica consiste no conjunto de todas as ações 
tomadas para processar a mensagem em questão, não permitindo intercalações no processamento 
de duas mensagens.

Gul Agha, em sua definição da semântica do modelo de atores \cite{Agha86}, diz que 
``em qualquer rede real de agentes computacionais, não de pode prever quando uma mensagem 
enviada por um agente será recebida por outro''. A afirmação é enfatizada para redes dinâmicas, 
onde novos agentes podem ser criados ou destruídos, e reconfigurações como migrações de agentes
para diferentes nós podem acontecer. Sua conclusão afirma que um modelo realista deve assumir
que a ordem de recebimento das mensagens não é determinística, mas sim arbitrária e desconhecida.

%% fairness - comentar qual tipo que ele adota no modelo
%% falar sobre o behavior e mostrar a maquina de processamento do ator
%% historico?


O modelo faz referência a garantia de entrega de mensagens, definindo que toda mensagem enviada 
deve ser depositada na caixa de correio do ator destinatário. O não determinismo na ordem de 
recebimento das mensagens pelo ator não interefe na garantia de entrega de mensagens.  
Vale destacar que a garantia de entrega de mensagens não assume que mensagens na caixa de 
correio tenham um processamento semanticamente significativo, já que o processamento de 
uma mensagem depende do comportamento definido no ator. Por exemplo, alguns atores poderiam 
optar por descartar todas as mensagens recebidas. 



\section{Computações em um Sistema de Atores}
\index{Atores!Computação}
\label{sec:atores-computacao}
%% aqui eu acho legal dar um exemplo? jogar fora? colocar metade do que esta em cima aqui dentro?

\section{Implementações}
\index{Atores!Implementações}
\label{sec:atores-implementacoes}
O modelo de atores provê uma semântica padrão com um conjunto de propriedades
a serem preservadas nas implementações do modelo, cujo objetivo é proporcionar
uma arquitetura modular e componível \cite{Agha98afoundation} e um melhor 
desempenho \cite{Kim95}. Apresentamos a seguir quatro propriedades, como 
encapsulamento, agendamento equalitário de execuções (\english{fair scheduling}), 
transparência da localidade do ator e mobilidade de atores entre nós em uma rede.
Karmani e Agha argumentam as vantagens da preservação dessas propriedades e 
fazem uma comparação de algumas implementações para a JVM em \cite{karmani2009}.