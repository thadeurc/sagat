%% ------------------------------------------------------------------------- %%
\chapter{Atores}
\label{cap:atores}

Apresentamos neste capítulo o modelo de atores. Na seção 
\ref{sec:atores-historico} apresentamos um breve histórico com alguns estudos
relacionados ao modelo. Na seção \ref{sec:atores-modelo} apresentamos a semântica
do modelo de atores e por fim, citamos na seção \ref{sec:atores-implementacoes} algumas
de suas implementações, além de apresentamos um exemplo de computação
em um sistema de atores.

\section{Breve histórico}
\label{sec:atores-historico}
\index{Atores!Histórico}

O modelo de atores foi originalmente proposto por Carl Hewitt em $1971$ \cite{hewitt:71}. 
O termo ator foi originalmente utilizado para descrever entidades ativas que analizavam 
padrões para iniciar atividades. O conceito de atores passou então a ser explorado pela 
comunidade científica e em $1973$, a noção de atores se aproximou do conceito de agentes existente
na área de inteligência artificial distribuída, por possuírem intenções, recursos,
monitores de mensagem e um agendador \cite{Hewitt:1973}.

Em $1975$, Irene Greif desenvolveu um modelo abstrato de atores orientado 
a eventos, onde cada ator armazenava os eventos locais para que fosse possível analizar 
a relação causal entre os eventos. Baker e Hewitt formalizaram um conjunto
de axiomas para computação concorrente em $1977$. Desse estudo surgiu uma propriedade 
importante: a ordem em que eventos são gerados deve ser obedecida a fim de prever 
violações de causalidade. No mesmo ano, Hewitt apresentou um estudo sobre como o 
entendimento dos padrões de troca de mensagens entre atores pode ajudar na definição de 
estruturas de controle. Esse estudo demonstrou o uso do estilo de passagem de continuações
no modelo de atores.	

O conceito de guardião foi definido em $1978$ por Attardi e Hewitt. Um guardião é 
uma entidade que regula o uso de recursos compartilhados. Guardiões incorporam 
explitamente a noção de estado e são responsáveis por agendar o acesso e fazer a 
proteção dos recursos. Hewitt e Atkinson definiram em $1979$ um conceito relacionado ao 
de guardião denominado seriador (\english{serializer}). Um seriador age como um monitor, 
porém, ao invés de aguardar sinais explícitos de processos, seriadores procuram ativamente 
por condições que permitam que processos em espera possam voltar a ser executados. 
Em $1987$, Henry Lieberman implementou em Lisp a linguagem Act1 \cite{Lieberman:1987}, 
uma linguagem de atores com guardiões, seriadores e atores chamados de ``trapaceiros'' 
(\english{rock-bottom}). Atores trapaceiros são atores que podem burlar as regras do modelo
de atores para, por exemplo, usar dados primitivos e funções da linguagem usada em sua
implementação.

Gul Agha definiu em $1986$ um sistema simples de transição para atores. Em seu trabalho foi
desenvolvido o conceito de configurações, recepcionistas e atores externos. 
Atores recepcionistas são atores que ocultam a existência outros atores de um
sistema de atores, agindo como intermediários no recebimento das mensagens. 
O uso de atores recepcionistas permite uma forma de encapsulamento, já que eles acabam 
agindo como interface para atores externos. Esse modelo foi implementado na linguagem Acore 
por Carl Manning em $1987$, e na linguagem Rosette por Tomlinson e outros em $1989$.

\section{Modelo}
\label{sec:atores-modelo}
\index{Atores!Modelo}
O modelo de atores é um modelo para programação concorrente em sistemas distribuídos, 
que foi apresentado como uma das possíveis alternativas ao uso de memória compartilhada e travas. 
Atores são agentes computacionais autônomos e concorrentes que possuem uma fila de mensagens
e um comportamento \cite{Agha86}.

O modelo define que toda interação entre atores deve acontecer via trocas assíncronas
de mensagens. Uma vez que o endereço da fila de mensagens de um ator é conhecido, 
mensagens podem ser enviadas ao ator. As mensagem enviadas são armazenadas para processamento 
assíncrono, desacoplando o envio de uma mensagem do seu processamento. 

Toda computação em um sistema de atores é resultado do processamento de uma mensagem. 
Cada mensagem recebida por um ator é mapeada em uma $3$-tupla que consiste de:

\begin{enumerate}
	\item um conjunto finito de envios de mensagens para atores cujas filas
	tenham seus endereços conhecidos (um desses atores pode ser o próprio ator destinatário
	da mensagem que está sendo processada);
	
	\item um novo comportamento, que será usado para processar a próxima mensagem
	recebida;
	
	\item um conjunto finito de criações de novos atores.
\end{enumerate}

Um ator que recebe mensagens faz o processamento individual de cada mensagem em 
uma execução atômica. Cada execução atômica consiste no conjunto de todas as ações 
tomadas para processar a mensagem em questão, não permitindo intercalações no 
processamento de duas mensagens.

Em um sistema de atores, envios de mensagens (também chamados de comunicações) são
encapsulados em tarefas. Uma tarefa é uma $3$-tupla que consiste em um identificador
único, o endereço da fila do ator destinatário e a mensagem. A configuração
de um sistema de atores é definida pelos atores que o sistema contém e pelo conjunto
de tarefas não processadas. É importante ressaltar que o endereço da fila de mensagens 
na tarefa deve ser válido, ou seja, ele deve ter sido previamente
comunicado. Há três maneiras de um ator ao receber uma mensagem \emph{m}, passar
a conhecer um destinatário no qual o ator pode enviar uma mensagem:

\begin{enumerate}
	\item O ator já conhecia o endereço da fila do destinatário antes
		do recebimento da mensagem \emph{m};

	\item O endereço fila estava presente na mensagem \emph{m};
	
	\item Um novo ator foi criado como resultado do processamento da mensagem \emph{m}.
\end{enumerate}

Um aspecto importante que faz parte o modelo de atores é existência de igualdade durante a
execução (\english{fairness}). Sem essa propriedade, um sistema de atores teria ambos a garantia 
de entrega e a componibilidade comprometida \cite{Agha98afoundation}.
No contexto de atores, garantia de entrega significa que
uma mensagem que foi depositada na fila de mensagens de um ator, não deve ficar armazenada
indefinidamente sem ser eventualmente repassada para o ator fazer o seu processamento. 
A ordem de chegada de mensagens obedece uma ordem linear, e fica a cargo da implementação
do modelo arbitrar em casos de conflito onde duas mensagens sejam recebidas no mesmo momento.
O modelo assume uma entrega eventual, pois podem ocorrer casos onde o ator esteja em um estado 
não propício a receber novas mensagens, com por exemplo, estar executando um laço infinito ou
alguma operação ilegal. A garantia de entrega de mensagens não assume que 
as mensagens entregues tenham um processamento semanticamente significativo. O processamento de 
uma mensagem depende do comportamento definido no ator. 
Alguns atores poderiam, por exemplo, optar por descartar todas as mensagens recebidas. 

Gul Agha, em sua definição da semântica do modelo de atores \cite{Agha86}, 
afirma que ``em qualquer rede real de agentes computacionais, não é possível prever quando uma 
mensagem enviada por um agente será recebida por outro''. A afirmação é enfatizada para redes 
dinâmicas, onde novos agentes podem ser criados ou destruídos, e reconfigurações como migrações 
de agentes para diferentes nós podem acontecer. Em sua conclusão, Agha afirma que um modelo 
realista deve assumir que a ordem de recebimento das mensagens não é determinística, mas sim 
arbitrária e desconhecida. O não determinismo na ordem de recebimento das mensagens pelo ator não 
interefe na garantia de entrega de mensagens.

O comportamento de um ator define como o ator irá processar a próxima mensagem recebida.
Ao processar uma mensagem, o ator deve definir o comportamento substituto que será utilizado para
processar a próxima mensagem que lhe for entregue. Mostramos na figura \ref{fig:atores-estado}
a máquina de estados de um ator processando uma mensagem recebida e definindo seu novo 
comportamento. Nessa figura, o ator $A$ com comportamento inicial $B_1$ retira a mensagem 
$m_1$ de sua fila e faz o processamento da mensagem. Para esse exemplo, o processamento da 
mensagem $m_1$ resultou na criação de um novo ator $A'$, com comportamento inicial $B_{1'}$, 
e no envio da mensagem $m_{1'}$ do ator $A$ para o ator $A'$. O ator $A$ passa a ter o 
comportamento $B_2$, que será usado no processamento da mensagem $m_2$. Vale ressaltar que o 
comportamento substituto não precisa ser necessariamente diferente do comportamento anterior. 
Por exemplo, os comportamentos $B_1$ e $B_2$ podem ser comportamentos idênticos.

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics{ator-state-machine} 
  	\caption{Máquina de estados de um ator.}
  	\label{fig:atores-estado}
\end{figure}

No modelo de atores, a real localicação de um ator não afeta a interação com outros atores. 
Os atores que um ator conhece podem estar distribuídos em diferentes núcleos de um processador,
ou mesmo em nós diferente em uma rede de computadores. A transparência da localidade
abstrai a infra-estrutura e permite que programas sejam desenvolvidos de modo distribuído,
ou seja, sem que a real localização de seus atores seja conhecida. Duas consequências diretas da  
transparência da localidade são o encapsulamento do estado do ator e
a capacidade de se mover atores entre os diferentes nós de uma rede de computadores. 

Apesar de o modelo ser bem explícito e claro em relação a interação ser via troca de mensagens e
dizer que o estado de um ator não deve ser compartilhado, implementações 
poderiam permitir que o estado interno de um ator fosse acessado diretamente por outro ator. 
Por exemplo, um ator em sua pilha de execução fazer a invocação de algum método de outro ator. 
Mesmo que a interface de um ator não permita o compartilhamento do seu estado interno que não
seja via troca de mensagens, as mensagens enviadas podem expor um compartilhamento indesejado
caso não sejam imutáveis e passadas por cópia. 

Mobilidade é definida como a habilidade de se poder mover uma computação de um nó para outro,
e pode ser classificada como mobilidade fraca ou mobilidade forte. Mobilidade fraca é a 
habilidade de tranferir código entre nós, enquanto que mobilidade forte é definida como a 
habilidade de tranferir ambos o código e o estado da execução \cite{Fuggetta:1998}. Em um
sistema baseado em atores, mobilidade fraca permite que atores que não tenham mensagens em suas
filas e não estão fazendo processamento algum sejam tranferidos para outros nós.

Pelo fato de o modelo de atores prover transparência de localidade e encapsulamento, a mobilidade
se torna natural. Mover atores entre diferentes nós em um sistema de atores é uma necessidade
importante para se obter um melhor desempenho, tolerância a falhas e sistemas reconfiguráveis 
\cite{Panwar:1994}. 

A semântica padrão do modelo de atores apresentada nesta seção objetiva proporcionar
uma arquitetura modular e componível \cite{Agha98afoundation} e um melhor desempenho para 
sistemas concorrentes e distribuídos, em particular para situações onde as aplicações
precisem de escalabilidade \cite{Kim95}.

\section{Implementações}
\index{Atores!Implementações}
\label{sec:atores-implementacoes}

O modelo de atores pode estar disponível em um linguagem de programação seja fazendo parte
da estrutura da linguagem, como uma biblioteca embutida em sua distribuição ou ainda como uma 
biblioteca separada da distribuição padrão. 

\subsection{Linguagens baseadas no modelo de atores}

Linguagens como Axum \cite{axum-lang-overview}, SALSA \cite{SALSA2001}, Ptolemy \cite{Lee03} e
Erlang \cite{PROG_ERLANG07} são exemplos de linguagens baseadas no modelo
de atores, onde o suporte é dado via primitivas da estrutura da própria linguagem.
Apresentamos a seguir algumas informações sobre essas linguagem.

\subsubsection{Axum}
\index{Atores!Implementações!Axum}
Axum (anteriormente conhecida como Maestro) é uma linguagem experimental orientada a objetos
\footnote{O projeto está em uma encubadora de projetos.} criada pela Microsoft 
Corporation para o desenvolvimento de sistemas concorrentes na plataforma .Net \cite{axum-lang-overview}. 
A criação da linguagem tem como motivação permitir que sistemas modelados como 
componentes que interajam entre si, possam ser traduzidos naturalmente na linguagem.
Pelo fato de ser uma linguagem da plataforma .Net, Axum pode fazer uso e ser utilizada
por outras linguagem da plataforma, como VB.Net, C\# e F\#.

Nessa linguagem, o termo ator é substituído pelo termo agente (\english{agent}). Agentes
são executados como \english{threads} dentro da CLR (\english{Common Language Runtime}) 
e são definidos com o uso da palavra chave \english{agent}. A troca de
mensagens é feita através de canais. Os canais são responsáveis por definir os tipos de dados
que trafegam entre neles com o uso das palavras chaves \english{input} e \english{output}. 
Canais possuem duas extremidades, a extremidade implementadora
(\english{implementing end}) e a extremidade de uso (\english{using end}). Agentes que implementam
o comportamento da extremidade implementadora de um canal, passam a agir como um servidor de 
mensagens do canal. A extremidade de uso do canal é visível e deve ser utilizada por 
outros agentes para fazer o envio de mensagens. 

A linguagem possui ainda o conceito de domínio. Domínios são definidos com a palavra chave 
\english{domain} e permitem que agentes definidos dentro de um domínio compartilhem informações
de um modo diferente. Uma instância de domínio pode ter atributos que são usados para 
compartilhamento seguro e controlado de informações.

Apesar da linguagem ter seu desenvolvimento interrompido na versão $0.3$ no início
de $2011$, segundo os seus autores os conceitos implementados na linguagem deverão ser portados 
para as linguagens C\# e Visual Basic \cite{axum}.

\subsubsection{SALSA}
\index{Atores!Implementações!SALSA}

SALSA (\english{Simple Actor Language System and Architecture} é uma linguagem que foi criada
em meados de $2001$ no \english{Rensselaer Poytechnic Institute} para facilitar o desenvolvimento 
de sistemas abertos com requisitos de serem dinamicamente reconfiguráveis. SALSA é uma linguagem
concorrente e orientada a objetos que implementa a semântica do modelo de atores. A linguagem
possui um pré-processador que converte o código fonte escrito SALSA para código fonte Java. Esse
que por sua vez pode ser, com a biblioteca de atores SALSA, compilado para \english{bytecode} Java
para ser executado sobre a JVM.

A linguagem possui algumas primitivas para a criação, uso e organização dos atores. A primitiva
\english{behavior} é análoga a palavra chave \english{class} de Java, e é utilizada para definir
os métodos que definem o comportamento do ator. Assim como é permitido na hierarquia de classes
em Java, onde não existe herança múltipla e classes podem implementar zero ou muitas 
\english{interfaces}, \english{behaviors} seguem a mesma regra. O \english{behavior} 
\lstinline$salsa.language.UniversalActor$ é análogo a classe \lstinline$java.lang.Object$, e todos os
\english{behaviors} o estendem direta ou indiretamente. A primitiva \lstinline$<-$ é utilizada
para enviar uma mensagem a um ator.

A implementação de atores da linguagem utiliza o objeto \lstinline$salsa.language.Actor$
como ator base que estende the \lstinline$java.lang.Thread$, criando uma relação onde 
cada ator executa em uma \english{thread}. Cada ator possui uma fila de mensagens onde
as mensagens enviadas ficam armazenadas até que o método \lstinline$run$ as retire
para que o método correspondente seja executado via reflexão. 

Além de prover a implementação da semântica do modelo de atores, a 
linguagem introduz ainda três abstrações para facilitar a coordenação das interações 
assíncronas entre os atores:

\begin{enumerate}
	\item Continuações com passagem de \english{token} (\english{Token-passing continuations}): 
	envios de mensagens para atores resultam em invocações de métodos. Esses métodos podem retornar
	valores que precisarão ser repassados a outros atores. Os valores de retorno são definidos como
	\english{tokens}. Essa abstração permite que uma mensagem enviada a um ator contenha uma 
	referência para o ator que irá consumir \english{token}, como mostrado no exemplo a seguir:
	
	\begin{center}
		\lstinline$gerente <- aprovacao1(500) @ gerente2 <- aprovacao2(token)$ \\
		\lstinline$@ diretor <- aprovacaoFinal(token)$
	\end{center}
	
	Nesse exemplo, o \lstinline$gerente$ processa a mensagem \lstinline$aprovacao1(500)$ e seu retorno,
	quando computado, é passado como \lstinline$token$ no envio da mensagem para o ator
	\lstinline$gerente2$. Apesar de o \lstinline$diretor3$ também receber como argumento
	da ação a lhe ser enviada \english{token}, o valor recebido será o resultado da
	computação do \lstinline$gerente2$. A palavra \english{token} é uma palavra chave e seu valor
	é associado no contexto do último \english{token} passado. Ainda nesse exemplo, utilizamos
	a primitiva \lstinline$@$ para indicar que desejamos utilizar a continuação com passagem
	de \english{token}.
				
	\item Continuações de junção (\english{Join continuations}): atores podem receber vetores
	com \english{tokens} recebidos de diversos atores. Essa abstração permite que os 
	\english{tokens} sejam agrupados para que o ator que os está recebendo só execute quando
	todos os \english{tokens} aguardados forem recebidos. Por exemplo:
	
	\begin{center}
		\lstinline$join(gerente <- aprovacao1(500), gerente2 <- aprovacao2(500))$ \\
		\lstinline$@ diretor <- aprovacaoFinal(500)$
	\end{center}
	
	Nesse exemplo, os dois atores \lstinline$gerente1$ e \lstinline$gerente2$ fazem suas aprovações
	em paralelo e, somente quando os dois tiverem dado suas aprovações, o ator \lstinline$diretor$
	irá receber a mensagem de \lstinline$aprovacaoFinal$. 

	\item Continuações de primeira classe (\english{First-class continuations}):
\end{enumerate}

Varela e Agha apresentaram um estudo da linguagem SALSA em um contexto de computação na internet,
utilizando nomeação universal, comunicação remota e migração de atores em \cite{SALSA2001}.

\subsubsection{Ptolemy}
\index{Atores!Implementações!Ptolemy}
salgo sobre ptolemy

\subsubsection{Erlang}
\index{Atores!Implementações!Erlang}

Erlang é uma linguagem funcional, com tipagem dinâmica e executada por 
uma máquina virtual Erlang. Voltada para o desenvolvimento de sistemas distribuídos de 
larga escala e tempo real, foi desenvolvida nos laboratórios da Ericsson no período 
de $1985$ à $1997$ \cite{erlang:97}. 

A linguagem em si, embora bem enxuta, possui características interessantes para simplificar o 
desenvolvimento de sistemas concorrentes. Exemplos de tais características são: variáveis de 
atribuição única, casamento de padrões e um conjunto de primitivas que inclui \english{spawn} 
para criação de atores, \english{send} e \english{!} para o envio de mensagens, \english{receive} 
para o recebimento de mensagens e \english{link} para a definição de adjacências entre atores. 
Ademais a linguagem dá suporte a hierarquias de supervisão entre atores e troca quente de 
código (\english{hotswap}).

Em Erlang, atores são processos ultra leves criados dentro de uma máquina virtual. 
Embora Erlang implemente o modelo de atores, sua literatura e suas bibliotecas não 
utilizam o termo ``ator'' (\english{actor}). O termo utilizado é ``processo'' (\english{process}).
A criação, destruição e troca de mensagens entre atores é extremamente rápida. Num teste feito 
em um computador com $512MB$ de memória, com um processador de $2.4GHz$  Intel Celeron rodando 
Ubuntu Linux, a criação de $20000$ processos levou em média $3.5\mu s$ de tempo de CPU por 
ator e $9.2\mu s$ de tempo de relógio por ator \cite{PROG_ERLANG07}.

Com a possibilidade de se criar uma quantidade considerável de atores, o uso de uma hierarquia 
de supervisão torna-se extremamente importante. No que diz respeito ao tratamento de erros em 
atores filhos, as primitivas existentes na linguagem dão suporte a três abordagens:
\begin{enumerate}
	\item Não se tem interesse em saber se um ator filho foi terminado normalmente ou não; 
	
	\item caso um ator filho não tenha terminado normalmente, o ator criador também é 
		  terminado; 

	\item caso um ator filho não tenha terminado normalmente, o ator criador é 
		  notificado e pode fazer o controle de erros da maneira que julgar mais apropriada. 
\end{enumerate}

Em Erlang é possível criar atores em nós remotos (\english{remote spawn}). Vale ressaltar 
que o código do ator deve estar acessível na máquina virtual onde o ator irá ser executado, 
pois não há suporte para carga remota de código. Uma vez que alguns detalhes de infra-estrutura 
foram observados\footnote{As máquinas virtuais Erlang necessitam se autenticar umas com as outras.},
a troca de mensagens entre atores remotos acontece de maneira transparente. No processo de 
envio, as mensagens trafegam com o uso de \english{sockets} TCP e UDP.


%% comtentar do paper do actor frameworks for the jvm platform. Dizer que nele
%% ficam ex
%Karmani e Agha argumentam as vantagens da preservação dessas propriedades e 
%fazem uma comparação de algumas implementações para a JVM em \cite{karmani2009}.



\subsection{Computações em um Sistema de Atores}
\index{Atores!Computação}
\label{sec:atores-computacao}
%% aqui eu acho legal dar um exemplo? jogar fora? colocar metade do que esta em cima aqui dentro?
%% poderia escrever um ator em erlang ou scala que fosse um contador - o exemplo que dei no
%% techday