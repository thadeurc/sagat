%% ------------------------------------------------------------------------- %%
\chapter{Atores}
\index{Atores}
\label{cap:atores}

Apresentamos neste capítulo o modelo de atores. Na seção \ref{sec:atores-modelo} 
apresentamos a semântica do modelo de atores. Na seção \ref{sec:atores-historico} 
apresentamos um breve histórico com alguns estudos relacionados ao modelo. Por fim
na seção \ref{sec:atores-implementacoes}, apresentamos algumas das implementações
do modelo.

\section{Modelo}
\label{sec:atores-modelo}
\index{Atores!modelo}

O modelo de atores é um modelo para programação concorrente em sistemas distribuídos, 
que foi apresentado como uma das possíveis alternativas ao uso de memória compartilhada e travas. 
Atores são agentes computacionais autônomos e concorrentes que possuem uma fila de mensagens
e um comportamento \cite{Agha86}.

O modelo define que toda interação entre atores deve acontecer via trocas assíncronas
de mensagens. Uma vez que o endereço da fila de mensagens de um ator é conhecido, 
mensagens podem ser enviadas ao ator. As mensagem enviadas são armazenadas para processamento 
assíncrono, desacoplando o envio de uma mensagem do seu processamento. 

Toda computação em um sistema de atores é resultado do processamento de uma mensagem. 
Cada mensagem recebida por um ator é mapeada em uma $3$-tupla que consiste de:

\begin{enumerate}
	\item Um conjunto finito de envios de mensagens para atores cujas filas
	tenham seus endereços conhecidos (um desses atores pode ser o próprio ator destinatário
	da mensagem que está sendo processada);
	
	\item Um novo comportamento, que será usado para processar a próxima mensagem
	recebida;
	
	\item Um conjunto finito de criações de novos atores.
\end{enumerate}

Um ator que recebe mensagens faz o processamento individual de cada mensagem em 
uma execução atômica. Cada execução atômica consiste no conjunto de todas as ações 
tomadas para processar a mensagem em questão, não permitindo intercalações no 
processamento de duas mensagens.

Em um sistema de atores, envios de mensagens (também chamados de comunicações) são
encapsulados em tarefas. Uma tarefa é uma $3$-tupla que consiste em um identificador
único, o endereço da fila do ator destinatário e a mensagem. A configuração
de um sistema de atores é definida pelos atores que o sistema contém e pelo conjunto
de tarefas não processadas. É importante ressaltar que o endereço da fila de mensagens 
na tarefa deve ser válido, ou seja, ele deve ter sido previamente
comunicado. Há três maneiras de um ator ao receber uma mensagem \emph{m}, passar
a conhecer um destinatário no qual o ator pode enviar mensagens:

\begin{enumerate}
	\item O ator já conhecia o endereço da fila do destinatário antes
		do recebimento da mensagem \emph{m};

	\item O endereço da fila estava presente na mensagem \emph{m};
	
	\item Um novo ator foi criado como resultado do processamento da mensagem \emph{m}.
\end{enumerate}

Um aspecto importante que faz parte o modelo de atores é existência de igualdade durante a
execução (\english{fairness}). Sem essa propriedade, um sistema de atores teria ambos a garantia 
de entrega e a componibilidade comprometida \cite{Agha98afoundation}.
No contexto de atores, garantia de entrega significa que
uma mensagem que foi depositada na fila de mensagens de um ator, não deve ficar armazenada
indefinidamente sem ser eventualmente repassada para o ator fazer o seu processamento. 
A ordem de chegada de mensagens obedece uma ordem linear, e fica a cargo da implementação
do modelo arbitrar no caso de conflitos, caso duas mensagens sejam recebidas no mesmo momento.
O modelo assume uma entrega eventual, pois podem ocorrer casos onde o ator esteja em um estado 
não propício a receber novas mensagens, como por exemplo, estar executando um laço infinito ou
alguma operação ilegal. A garantia de entrega de mensagens não assume que 
as mensagens entregues tenham um processamento semanticamente significativo. O processamento de 
uma mensagem depende do comportamento definido no ator. 
Por exemplo, um tipo de atores poderia optar por descartar todas as mensagens recebidas. 

Gul Agha, em sua definição da semântica do modelo de atores \cite{Agha86}, 
afirma que ``em qualquer rede real de agentes computacionais, não é possível prever quando uma 
mensagem enviada por um agente será recebida por outro''. A afirmação é enfatizada para redes 
dinâmicas, onde novos agentes podem ser criados ou destruídos, e reconfigurações como migrações 
de agentes para diferentes nós podem acontecer. Em sua conclusão, Agha afirma que um modelo 
realista deve assumir que a ordem de recebimento das mensagens não é determinística, mas sim 
arbitrária e desconhecida. O não determinismo na ordem de recebimento das mensagens pelo ator não 
interefe na garantia de entrega das mensagens.

O comportamento de um ator define como o ator irá processar a próxima mensagem recebida.
Ao processar uma mensagem, o ator deve definir o comportamento substituto que será utilizado para
processar a próxima mensagem que lhe for entregue. Mostramos na figura \ref{fig:atores-estado}
a máquina de estados de um ator processando uma mensagem recebida e definindo seu novo 
comportamento. Nessa figura, o ator $A$ com comportamento inicial $B_1$ retira a mensagem 
$m_1$ de sua fila e a processa. Para esse exemplo, o processamento da 
mensagem $m_1$ resultou na criação de um novo ator $A'$, com comportamento inicial $B_{1'}$, 
e no envio da mensagem $m_{1'}$ do ator $A$ para o ator $A'$. O ator $A$ passa a ter o 
comportamento $B_2$, que será usado no processamento da mensagem $m_2$. Vale ressaltar que o 
comportamento substituto não precisa ser necessariamente diferente do comportamento anterior. 
Por exemplo, os comportamentos $B_1$ e $B_2$ podem ser comportamentos idênticos.

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics{ator-state-machine} 
  	\caption{Máquina de estados de um ator.}
  	\label{fig:atores-estado}
\end{figure}

No modelo de atores, a real localização de um ator não afeta a interação com outros atores. 
Os atores que um ator conhece podem estar distribuídos em diferentes núcleos de um processador,
ou mesmo em diferentes nós de uma rede de computadores. A transparência da localidade
abstrai a infra-estrutura e permite que programas sejam desenvolvidos de modo distribuído,
sem que a real localização de seus atores seja conhecida. Duas consequências diretas da  
transparência da localidade são o encapsulamento do estado do ator e
a capacidade de se mover atores entre os diferentes nós de uma rede de computadores. 

Apesar de o modelo ser bem explícito e claro em relação a interação ser via troca de mensagens e
dizer que o estado de um ator não deve ser compartilhado, implementações 
poderiam permitir que o estado interno de um ator fosse acessado diretamente por outro ator. 
Por exemplo, um ator em sua pilha de execução fazer a invocação de algum método de outro ator. 
Mesmo que a interface de um ator não permita o compartilhamento do seu estado interno que não
seja via troca de mensagens, mensagens enviadas poderiam expor um compartilhamento indesejado
de estado. O uso de mensagens imutáveis e passadas via cópia é uma abordagem mais apropriada
para evitar um compartilhamento indesejado de memória.

Mobilidade é definida como a habilidade de se poder mover uma computação de um nó para outro,
e pode ser classificada como mobilidade fraca ou mobilidade forte. Mobilidade fraca é a 
habilidade de se transferir código entre nós, enquanto que mobilidade forte é definida como a 
habilidade de se transferir ambos o código e o estado da execução \cite{Fuggetta:1998}. Em um
sistema baseado em atores, mobilidade fraca permite que atores que não possuem mensagens em suas
filas e não estão fazendo processamento algum sejam transferidos para outros nós.

Pelo fato de o modelo de atores prover transparência de localidade e encapsulamento, a mobilidade
se torna natural. Mover atores entre diferentes nós em um sistema de atores é uma necessidade
importante para se obter um melhor desempenho, tolerância a falhas e sistemas reconfiguráveis 
\cite{Panwar:1994}. 

A semântica padrão do modelo de atores apresentada nesta seção objetiva proporcionar
uma arquitetura modular e componível \cite{Agha98afoundation}, e um melhor desempenho para 
sistemas concorrentes e distribuídos, em particular para situações onde as aplicações
precisem de escalabilidade \cite{Kim95}.

\section{Breve histórico}
\label{sec:atores-historico}
\index{Atores!histórico}

O modelo de atores foi originalmente proposto por Carl Hewitt em $1971$ \cite{hewitt:71}. 
O termo ator foi originalmente utilizado para descrever entidades ativas que analizavam 
padrões para iniciar atividades. O conceito de atores passou então a ser explorado pela 
comunidade científica e em $1973$, a noção de atores se aproximou do conceito de agentes existente
na área de inteligência artificial distribuída, por possuírem intenções, recursos,
monitores de mensagens e um agendador \cite{Hewitt:1973}.

Em $1975$, Irene Greif desenvolveu um modelo abstrato de atores orientado 
a eventos onde cada ator guardava um histórico dos seus eventos. O objetivo do estudo
era analizar a relação causal entre os eventos. Baker e Hewitt formalizaram um conjunto
de axiomas para computação concorrente em $1977$. Desse estudo surgiu uma propriedade 
importante: a ordem em que eventos são gerados deve ser obedecida a fim de prever 
violações de causalidade. No mesmo ano, Hewitt apresentou um estudo sobre como o 
entendimento dos padrões de troca de mensagens entre atores pode ajudar na definição de 
estruturas de controle. Esse estudo demonstrou o uso do estilo de passagem de continuações
no modelo de atores.	

O conceito de guardião foi definido em $1978$ por Attardi e Hewitt. Um guardião é 
uma entidade que regula o uso de recursos compartilhados. Guardiões incorporam 
explitamente a noção de estado e são responsáveis por agendar o acesso e fazer a 
proteção dos recursos. Hewitt e Atkinson definiram em $1979$ um conceito relacionado ao 
de guardião denominado seriador (\english{serializer}). Um seriador age como um monitor, 
porém, ao invés de aguardar sinais explícitos vindos dos processos, seriadores procuram ativamente 
por condições que permitam que processos em espera possam voltar a ser executados. 
Em $1987$, Henry Lieberman implementou em Lisp a linguagem Act1 \cite{Lieberman:1987}, 
uma linguagem de atores com guardiões, seriadores e atores chamados de ``trapaceiros'' 
(\english{rock-bottom}). Atores trapaceiros são atores que podem burlar as regras do modelo
de atores para, por exemplo, fazer uso dados primitivos e funções da linguagem usada em sua
implementação.

Gul Agha definiu em $1986$ um sistema simples de transição para atores. Em seu trabalho foi
desenvolvido o conceito de configurações, recepcionistas e atores externos. 
Atores recepcionistas são atores que ocultam a existência de outros atores em um
sistema de atores, agindo como intermediários no recebimento das mensagens. 
O uso de atores recepcionistas permite uma forma de encapsulamento, já que eles acabam 
agindo como interface para atores externos. Esse modelo foi implementado na linguagem Acore 
por Carl Manning em $1987$, e na linguagem Rosette por Tomlinson e outros em $1989$.

\section{Implementações}
\index{Atores!implementações}
\label{sec:atores-implementacoes}

O suporte ao modelo de atores pode estar disponível em uma linguagem de programação, seja 
fazendo parte da estrutura da linguagem, como uma biblioteca embutida em sua distribuição ou 
ainda como uma biblioteca separada da distribuição padrão. Apresentamos na sub-seção 
\ref{sec:atores-linguagens}  algumas linguagens de programação baseadas no modelo de atores, 
e que possuem primitivas que facilitam a criação de sistemas baseados em atores. 
Apresentamos na sub-seção \ref{sec:atores-bibliotecas} algumas bibliotecas que adicionam o 
suporte ao modelo de atores a linguagens mais gerais.

\subsection{Linguagens}
\index{Atores!implementações!linguagens}
\label{sec:atores-linguagens}

Linguagens como Axum \cite{axum-lang-overview}, SALSA \cite{SALSA2001} e
Erlang \cite{PROG_ERLANG07} são exemplos de linguagens baseadas no modelo
de atores. Nessas linguagens, o suporte é dado via primitivas na estrutura da linguagem.

\subsubsection{Axum}
\index{Atores!implementações!linguagens!Axum}

Axum (anteriormente conhecida como Maestro) é uma linguagem experimental orientada a 
objetos\footnote{O projeto está em uma encubadora de projetos.} criada pela Microsoft 
Corporation para o desenvolvimento de sistemas concorrentes na plataforma .Net \cite{axum-lang-overview}. 
A criação da linguagem teve como motivação permitir que sistemas modelados como 
componentes que interajem entre si, pudessem ser traduzidos naturalmente para código.
Pelo fato de ser uma linguagem da plataforma .Net, Axum pode interagir com outras linguagens 
da plataforma, como VB.Net, C\# e F\#.

Em Axum, o termo ``ator'' é substituído pelo termo ``agente'' (\english{agent}). Agentes
são executados como \english{threads} dentro da CLR (\english{Common Language Runtime}) 
e são definidos com o uso da palavra-chave \lstinline$agent$. A troca de
mensagens é feita via canais. Os canais são responsáveis por definir os tipos de dados
que trafegam neles com o uso das palavras-chaves \lstinline$input$ e \lstinline$output$. 
Canais possuem duas extremidades, a extremidade implementadora
(\english{implementing end}) e a extremidade de uso (\english{using end}). Agentes que implementam
o comportamento da extremidade implementadora de um canal, passam a agir como servidores de 
mensagens de seus respectivos canais. A extremidade de uso do canal é visível e deve ser utilizada por 
outros agentes para fazer o envio de mensagens. 

A linguagem possui ainda o conceito de domínio. Domínios são definidos com a palavra-chave 
\lstinline$domain$ e permitem que agentes definidos dentro de um domínio compartilhem informações
de um modo diferente. Uma instância de domínio pode ter atributos que são usados para 
compartilhamento seguro e controlado de informações.

Apesar da linguagem ter seu desenvolvimento interrompido na versão $0.3$ no início
de $2011$, segundo os seus autores os conceitos implementados na linguagem poderão ser portados 
para as linguagens C\# e Visual Basic \cite{axum}.

\subsubsection{SALSA}
\index{Atores!implementações!linguagens!SALSA}

SALSA (\english{Simple Actor Language System and Architecture}) é uma linguagem que foi criada
em meados de $2001$ no \english{Rensselaer Polytechnic Institute} para facilitar o desenvolvimento 
de sistemas abertos dinamicamente reconfiguráveis. SALSA é uma linguagem
concorrente e orientada a objetos que implementa a semântica do modelo de atores. A linguagem
possui um pré-processador que converte o código fonte escrito em SALSA para código fonte Java. Esse
que por sua vez pode ser compilado para \english{bytecode}
e ser executado sobre a JVM.

A linguagem possui algumas primitivas para a criação, uso e organização dos atores. A primitiva
\lstinline$behavior$ é equivalente a palavra-chave \code{class} de Java, e é utilizada para definir
os métodos que definem o comportamento do ator. Assim como na hierarquia de classes
em Java, onde não existe herança múltipla e classes podem implementar zero ou muitas 
\english{interfaces}, \english{behaviors} seguem a mesma regra. O \english{behavior}
\lstinline$salsa.language.UniversalActor$ é análogo a classe \lstinline$java.lang.Object$, e todos os
\english{behaviors} o extendem direta ou indiretamente. A primitiva \lstinline$<-$ é utilizada
para enviar uma mensagem a um ator.

A implementação de atores da linguagem utiliza o objeto \lstinline$salsa.language.Actor$
como ator base que extende \lstinline$java.lang.Thread$, criando uma relação onde 
cada ator executa em uma \english{thread}. Cada ator possui uma fila de mensagens onde
as mensagens recebidas ficam armazenadas até que o método \lstinline$run$ as retire
para que o método correspondente seja executado via reflexão. 

Além de prover a implementação da semântica do modelo de atores, a 
linguagem introduz ainda três abstrações para facilitar a coordenação das interações 
assíncronas entre os atores:

\begin{enumerate}
	\item Continuações com passagem de \english{token} (\english{Token-passing continuations}): 
	Envios de mensagens para atores resultam em invocações de métodos. Esses métodos podem retornar
	valores que precisarão ser repassados a outros atores. Os valores de retorno são definidos como
	\english{tokens}. Essa abstração permite que uma mensagem enviada a um ator contenha uma 
	referência para o ator que irá consumir o \english{token}, como mostrado no exemplo a seguir:
	
	\begin{center}
		\lstinline$gerente <- aprovacao1(500) @ gerente2 <- aprovacao2(token)$ \\
		\lstinline$@ diretor <- aprovacaoFinal(token);$
	\end{center}
	
	Nesse exemplo, \lstinline$gerente$ processa a mensagem \lstinline$aprovacao1(500)$ e seu retorno,
	quando computado, é passado como \lstinline$token$ no envio da mensagem para o ator
	\lstinline$gerente2$. A palavra \english{token} é uma palavra-chave e seu valor é associado 
	no contexto do último \english{token} passado. O ator \lstinline$diretor$ recebe como argumento
	o resultado da computação do ator \lstinline$gerente2$. Ainda nesse exemplo, utilizamos
	a primitiva \lstinline$@$ para indicar que desejamos utilizar a continuação com passagem
	de \english{token};
				
	\item Continuações de junção (\english{Join continuations}): Atores podem receber vetores
	com \english{tokens} recebidos de diversos atores. Essa abstração permite que os 
	\english{tokens} sejam agrupados para que o ator que os está recebendo só execute mediante
	a todos os \english{tokens} aguardados terem sido recebidos. Por exemplo:
	
	\begin{center}
		\lstinline$join(gerente <- aprovacao1(500), gerente2 <- aprovacao2(500))$ \\
		\lstinline$@ diretor <- aprovacaoFinal(500);$
	\end{center}
	
	Nesse exemplo, os dois atores \lstinline$gerente1$ e \lstinline$gerente2$ fazem suas aprovações
	em paralelo e, somente quando os dois tiverem dado suas aprovações, o ator \lstinline$diretor$
	irá receber a mensagem de \lstinline$aprovacaoFinal$;

	\item Continuações de primeira classe (\english{First-class continuations}): Essa abstração
	é análoga à funções de ordem superior, onde funções podem receber outras funções. No caso
	da linguagem SALSA, a abstração permite que continuações sejam passadas como parâmetro
	para outras continuações. O processamento da mensagem pode optar por delegar o restante do 
	processamento à continuação recebida, por exemplo em chamadas recursivas. 
	No processamento de uma mensagem, a continuação recebida como parâmetro é acessada 
	pela palavra-chave \lstinline$currentContinuation$.
	
\end{enumerate}

\subsubsection{Erlang}
\label{sec:atores-linguagens-erlang}
\index{Atores!implementações!linguagens!Erlang}

Erlang é uma linguagem funcional, com tipagem dinâmica e executada por 
uma máquina virtual Erlang. Voltada para o desenvolvimento de sistemas distribuídos de 
larga escala e tempo real, foi desenvolvida nos laboratórios da Ericsson no período 
de $1985$ à $1997$ \cite{erlang:97}. 

A linguagem em si, embora bem enxuta, possui características interessantes para simplificar o 
desenvolvimento de sistemas concorrentes. Exemplos de tais características são: variáveis de 
atribuição única, casamento de padrões e um conjunto de primitivas que inclui \lstinline$spawn$
para criação de atores, \lstinline$send$ e \lstinline$!$ para o envio de mensagens, \lstinline$receive$
para o recebimento de mensagens e \lstinline$link$ para a definição de adjacências entre atores. 
Ademais a linguagem dá suporte a hierarquias de supervisão entre atores e troca quente de 
código (\english{hotswap}).

Em Erlang, atores são processos ultra leves criados dentro de uma máquina virtual. 
Embora Erlang implemente o modelo de atores, sua literatura e suas bibliotecas não 
utilizam o termo ``ator'' (\english{actor}), mas sim o termo ``processo'' (\english{process}).
A criação, destruição e troca de mensagens entre atores é extremamente rápida. Num teste feito 
em um computador com $512MB$ de memória, com um processador de $2.4GHz$  Intel Celeron rodando 
Ubuntu Linux, a criação de $20000$ processos levou em média $3.5\mu s$ de tempo de CPU por 
ator e $9.2\mu s$ de tempo de relógio por ator \cite{PROG_ERLANG07}. Esses números mostram que
a criação dos atores é rápida e que com pouca memória, muitos atores podem ser criados.

Com a possibilidade de se criar uma quantidade considerável de atores, o uso de uma hierarquia 
de supervisão torna-se extremamente importante. No que diz respeito ao tratamento de erros em 
atores filhos, as primitivas existentes na linguagem dão suporte a três abordagens:
\begin{enumerate}
	\item Não se tem interesse em saber se um ator filho foi terminado normalmente ou não; 
	
	\item Caso um ator filho não tenha terminado normalmente, o ator criador também é 
		  terminado; 

	\item Caso um ator filho não tenha terminado normalmente, o ator criador é 
		  notificado e pode fazer o controle de erros da maneira que julgar mais apropriada. 
\end{enumerate}

Em Erlang é possível criar atores em nós remotos (\english{remote spawn}). Vale ressaltar 
que o código do ator deve estar acessível na máquina virtual onde o ator irá ser executado, 
pois não há suporte para carga remota de código. Uma vez que alguns detalhes de infra-estrutura 
foram observados (as máquinas virtuais Erlang necessitam se autenticar umas com as outras),
a troca de mensagens entre atores remotos acontece de maneira transparente. No processo de 
envio, as mensagens trafegam com o uso de \english{sockets} TCP e UDP.

\subsection{Bibliotecas}
\index{Atores!implementações!bibliotecas}
\label{sec:atores-bibliotecas}

Diversas linguagens de programação possuem suporte ao modelo de atores via bibliotecas. Essas
bibliotecas disponibilizam arcabouços para desenvolvimento de sistemas concorrentes baseados
no modelo de atores. Listamos a seguir algumas linguagens e referências para algumas de suas
bibliotecas:

\begin{itemize}
	\item C++: Act++ \cite{act93}, Thal \cite{Kim:1997} e Theron \cite{theron2011};

	\item Smalltalk: Actalk \cite{actalk89};

	\item Python: Parley \cite{parley} e Stackless Python \cite{stackless};

	\item Ruby: Stage \cite{Sillito:2008} e a biblioteca de atores presente na distribuição 
	Rubinius\footnote{Rubinius é uma implementação da linguagem Ruby que possui 
	uma máquina virtual escrita em C++.} \cite{rubinius};

	\item .Net: Asynchronous Agent Library \cite{AAL} e Retlang \cite{retlang};

	\item Java: Akka \cite{akka}, Kilim \cite{kilim}, Jetlang \cite{jetlang} e Actor Foundry
	\cite{foundry};

	\item Scala: Scala Actors \cite{scala-actors}, Akka \cite{akka} e Scalaz \cite{scalaz}.
	
\end{itemize}

Pelo fato de nosso trabalho ter sido desenvolvido sobre a JVM, mais especificamente na linguagem
Scala, optamos por não comparar todas as bibliotecas listas anteriormente para não nos distanciarmos
do escopo deste trabalho. Karmani e Agha fizeram uma análise comparativa entre alguns 
arcabouços de atores para a JVM e os apresentaram em \cite{karmani2009}. Nessa análise, eles 
fizeram comparações considerando a implementação da semântica de execução e das abstrações. 

Apresentamos a seguir informações sobre as bibliotecas de atores que foram consideras como opções
e analizadas para o desenvolvimento do nosso trabalho.

\subsubsection{A biblioteca de atores de Scala}

A distribuição de Scala inclui uma biblioteca de atores inspirada pelo suporte a atores de  
Erlang. 

Nesta biblioteca os atores foram projetados como objetos baseados em \english{threads} 
Java e possuem métodos como \lstinline$send$, \lstinline$!$, \lstinline$receive$, além de 
outros métodos como \lstinline$act$ e \lstinline$react$. Cada ator possui uma caixa de correio 
para o recebimento e armazenamento temporário das mensagens. O processamento de uma mensagem 
é feito por um bloco \lstinline$receive$ declarado dentro do método \lstinline$act$. 

No método \lstinline$receive$ são definidos os padrões a serem casados com as mensagens 
que o ator processa e as ações associadas. 
A primeira mensagem que casar com qualquer dos padrões é removida da caixa de correio e a 
ação correspondente é executada. Caso não haja casamento com nenhum dos padrões, o ator é suspenso.

Atores são executados em um \english{thread pool}\footnote{Idealmente o tamanho do 
\english{thread pool} corresponde ao número de núcleos do processador.} que cresce conforme a demanda. 
É importante ressaltar que o uso do método \lstinline$receive$
fixa o ator à \english{thread} que o está executando, limitando superiormente a quantidade
de atores pelo número de \english{threads} que podem ser criadas. É recomendado o uso do método 
\lstinline$react$ ao invés do método \lstinline$receive$ sempre que possível, já que um ator 
que não está em execução cede sua \english{thread} para que ela execute outro ator.
Do ponto de vista de funcionalidade, o método \lstinline$receive$ é bloqueante e pode retornar 
valores, enquanto que o método \lstinline$react$, além de não retornar valores, faz com que o ator
passe a reagir aos eventos (recebimentos de mensagens). As implicações práticas no uso de 
\lstinline$react$ em relação ao \lstinline$receive$ da perspectiva de codificação
são: o uso da estrutura de controle \lstinline$loop$ ao invés de laços tradicionais, 
para indicar que o ator deve continuar reagindo após o processamento de 
uma mensagem (o uso dos laços tradicionais bloqueariam a \english{thread}); o ator
ser responsável por invocar eventuais métodos após o processamento de uma mensagem 
\cite{scala-actors}.	

Além de métodos para envio de mensagens equivalentes às primitivas de Erlang, a biblioteca de atores
de Scala implementa métodos adicionais, que facilitam o tratamento de algumas necessidades 
específicas. Esses métodos são: \lstinline$!?$ faz envio síncrono e aguarda uma resposta 
dentro de um tempo limite especificado; \lstinline$!!$ faz o envio assíncrono da 
mensagem e recebe um resultado futuro correspondente a uma resposta. 
        
O suporte a atores remotos faz parte da biblioteca, porém com algumas restrições em comparação 
com os atores de Erlang. Nesta biblioteca, atores remotos são atores remotamente acessíveis.
já que não é possível a criação de um ator em um nó que não seja o local, ou seja, 
\english{remote spawns} não são possíveis. Os atores são acessíveis remotamente 
via \english{proxies}. Para obter uma referência a um ator remoto, um cliente faz uma busca  
em um determinado nó (uma JVM identificada por um par com endereço do hospedeiro e a porta), utilizando 
como chave o nome sob o qual o ator foi registrado. Esta abordagem, apesar de soar restritiva, 
evita um problema importante que é a necessidade de carga remota da classe do ator 
(\english{remote class loading}) e torna desnecessário o uso de interfaces remotas como em 
Java RMI. O tráfego das mensagens é feito via seriação padrão Java através de \english{sockets} TCP.

\subsubsection{O projeto Akka}

O projeto Akka é composto por um conjunto de módulos escritos em 
Scala\footnote{O projeto disponibiliza também uma versão de suas APIs voltada para aplicações Java.}, 
que implementam uma plataforma voltada para o desenvolvimento de aplicações escaláveis 
e tolerantes a falhas. Na versão $1.0$, suas principais características são: 
uma nova biblioteca de atores locais e remotos, suporte a STM, hierarquias de supervisão e 
uma combinação entre atores e STM (\english{``transactors''}) que da suporte a fluxos de mensagens 
baseados em eventos transacionais, assíncronos e componíveis. Akka oferece ainda, uma série de 
módulos adicionais para integração com outras tecnologias.

A biblioteca de atores do projeto Akka é totalmente independente da que é parte da distribuição 
de Scala, apesar de também seguir as idéias de Erlang. O comportamento dos atores Akka no 
recebimento de mensagens inesperadas (que não casam com nenhum dos padrões especificados em um 
\lstinline$receive$) é diferente dos atores de Erlang e Scala, onde o ator é suspenso. No caso 
de atores Akka, tais mensagens provocam o lançamento de exceções.
	
O suporte a atores remotos do projeto Akka é bem mais completo do que o oferecido pela biblioteca 
de atores de Scala e será discutido no capítulo \ref{cap:atores_akka}. Assim como a 
biblioteca de atores de Scala, o Akka oferece métodos para diferentes tipos de envio de mensagens:
\lstinline$!!$ semelhante ao método \lstinline$!?$ da biblioteca de atores de Scala, no qual o
remetente fica bloqueado aguardando uma resposta durante um tempo limite; \lstinline$!!!$ 
semelhante ao método \lstinline$!!$ da biblioteca de atores de Scala, que devolve um resultado
futuro ao remetente.

No que diz respeito à seriação das mensagens para um ator remoto, o Akka oferece as 
seguintes opções: JSON \cite{json}, Protobuf \cite{protobuf}, SBinary \cite{sbinary} e seriação
Java padrão. O transporte das mensagens é feito via \english{sockets} TCP, com o auxílio do JBoss 
Netty \cite{jboss-netty}, um arcabouço para comunicação assíncrona dirigido a eventos e baseado 
em \english{sockets}. Esse arcabouço oferece facilidades para compressão de mensagens, 
que são utilizados pelo Akka.

Optamos por utilizar a implementação de atores do projeto Akka para o desenvolvimento deste
trabalho. Tomamos como base a versão $1.0$ do Akka por ser a última versão estável 
disponível quando iniciamos o desenvolvimento. Nossa escolha pela implementação de atores
do projeto Akka foi motivada pelos fatores a seguir:

\begin{itemize}
	\item Ter código aberto;
	
	\item Ser escrito em Scala;
	
	\item Possuir uma implementação mais completa de atores remotos em relação
	às demais implementações que observamos; 
	
	\item A implementação de atores remotos possuir certa disposição para novas 
	implementações de transportes;
	
	\item Ter grande volume de atividade na comunidade de usuários e de desenvolvedores;

	\item Estar com desenvolvimento ativo;
	
	\item Ser não apenas um projeto, mas sim de um produto que foi criado
	com objetivos comerciais\footnote{
	A distribuição do Akka faz parte da \english{Typesafe Stack}, uma plataforma
	para desenvolvimento de sistemas concorrentes e escaláveis da empresa Typesafe}.
\end{itemize}

Os principais detalhes da implementação da biblioteca de atores feita no projeto são apresentados no 
capítulo \ref{cap:atores_akka}.
