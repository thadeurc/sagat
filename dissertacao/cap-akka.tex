%% ------------------------------------------------------------------------- %%
\chapter{Atores no projeto Akka}
\label{cap:atores_akka}
Os atores do Akka podem ser locais ou remotos. O termo ``ator local'' é usado
para denotar um ator que pode receber mensagens apenas de atores residentes
na mesma máquina virtual. Por outro lado, um ator remoto pode receber mensagens
de quaisquer outros atores, inclusive daqueles residentes em outras máquinas virtuais.
Em outras palavras, o termo ``ator remoto'' é um sinônimo de ``ator remotamente acessível''.

Nas próximas duas seções examinaremos a implementação de atores do projeto Akka. 
Mostraremos a criação e o uso de atores locais ou remotos, bem como o fluxo de uma 
mensagem (envio, tráfego e processamento da mensagem) tanto no caso local como no remoto.
        
\section{Atores locais}
\index{Akka!Atores locais}

A definição de atores locais acontece por meio de extensões da 
\english{trait} \lstinline$akka.actor.Actor$ provendo uma implementação para o 
método \code{receive} como mostrado na listagem \ref{lst:def-actor}. 
A definição de um ator descreve o comportamento inicial que o
ator terá. A ator propriamente dito (que possui a infraestrutura provida
pelo arcabouço) é uma instância de \lstinline$akka.actor.ActorRef$. \lstinline$ActorRef$s
são imutáveis, seriáveis, identificáveis e possuem um relacionamento único com a 
definição do ator. 

A \english{trait} \lstinline$Actor$ tem em sua declaração uma referência para o
\lstinline$ActorRef$ que é acessível pela referência \lstinline$self$. No caso de
atores locais, \lstinline$self$ referencia uma instância de \lstinline$akka.actor.LocalActorRef$.
Com essa referência, a classe que define o comportamento do ator pode alterar as definições
padrão providas pelo arcabouço e utilizar métodos, por exemplo, para responder ou encaminhar 
mensagens recebidas, acessar as referências para um ator supervisor ou atores que estejam
sobre supervisão.

\begin{lstlisting}[frame=tb, caption={Classe SampleActor.}, label={lst:def-actor}]
class SampleActor(val name: String) extends akka.actor.Actor {
  def this() = this("No name")

  def receive = {
    case "hello" => println("%s received hello".format(name))
    case          _ => println("%s received unknown".format(name))
  }
}
\end{lstlisting}

Atores são criados pelo método \lstinline$actorOf$ do objeto \lstinline$akka.actor.Actor$
como mostrado na listagem \ref{lst:actorOf1}. Nessa listagem a instância do ator é criada
com base no tipo da classe via invocação por reflexão do construtor padrão da classe.
O método \lstinline$actorOf$ é sobrecarregado para permitir que uma função sem 
argumentos e com tipo de retorno \lstinline$Actor$, possa ser utilizada como alternativa ao
construtor padrão na criação do ator, como mostrado na listagem \ref{lst:actorOf2}. 

Nas duas listagens tivemos que chamar explicitamente o método 
\lstinline$start$ para inicializar o ator. Os atores do projeto Akka possuem um conjunto de estados
simples, bem definido e linear. Um ator logo após sua criação está no estado chamado de ``novo'' 
e ainda não pode receber mensagens. Após a chamada do método \lstinline$start$, o ator passa ao 
estado ``iniciado'' e está apto a receber mensagens. Uma vez que o método \lstinline$exit$ é 
invocado, o ator passa ao estado de ``desligado'' e não pode mais executar ação alguma.

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via construtor padrão.}, label={lst:actorOf1}]
  val theActor = Actor.actorOf[SampleActor].start
  theActor ! "hello"
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via função de inicialização.}, label={lst:actorOf2}]
  val function = {
    // some other actions here
    new SampleActor("John")
  }
  val theActor = Actor.actorOf(function).start
  theActor ! "hello"
\end{lstlisting}

As mensagens que são enviadas para um ator são colocada sincronamente 
na fila de mensagens do ator, levando tempo $O(1)$. As mensagens enfileiradas são então 
despachadas assincronamente para a função parcial definida no bloco \lstinline$receive$, 
como mostrado na figura \ref{fig:local-actor-message}. 

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics{local-actor-message} 
  	\caption{Envio e despacho de mensagens para atores locais.}
  	\label{fig:local-actor-message}
\end{figure}

\subsubsection{Despachadores}

O despachador de um ator é uma entidade que possui um papel importante. O despachador permite a 
configuração do tipo da fila do ator e a semântica de despachamento das mensagens. As filas 
dos atores podem ser duráveis ou transientes e ter seu tamanho limitado superiormente ou não. O Akka
permite que despachadores específicos sejam definidos, porém possui em sua distribuição os quatro 
despachadores listados a seguir:

\begin{itemize}
	\item Despachador impulsionado por eventos: 
	O despachador é definido na classe \lstinline$akka.dispatch.ExecutorBasedEventDrivenDispatcher$
	e é normalmente compartilhado por diversos atores de diferentes
	tipos, já que ele utiliza um \english{thread pool} para agendar as ações de despachamento.
	É o despachador mais flexível em termos de configurações, já que permite que
	parâmetros do \english{thread pool} e da fila de mensagens sejam configurados;

	%, como quantidade máxima e mínima de \english{threads},
	%sejam configurados, e da fila, como limite de mensagens, durabilidade e políticas para
	%rejeição sejam configurados;

	\item Despachador impulsionado por eventos com balanceamento de processamento:
	O despachador é definido na classe \lstinline$akka.dispatch.ExecutorBasedEventDrivenWorkStealingDispatcher$
	e é semelhante ao despachador anterior, já que também é impulsionado por eventos. 
	Esse despachador deve ser usado em atores do mesmo tipo já que permite que
	atores que não estão processando mensagens possam ``roubar'' mensagens das filas dos atores
	que estão sobrecarregados, permitindo o balanceamento do processamento das mensagens entre
	os atores;
	
	\item Despachador quente: 
	O despachador é definido na classe \lstinline$akka.dispatch.HawtDispatcher$ e é inspirado no 
	\english{Grand Central Dispacher} do Mac OS X \cite{apple-gcd}. Esse despachador 
	define um \english{thread pool} cujo tamanho é ajustado ao automaticamente
	para minimizar a quantidade de \english{threads} concorrentes e inativas
	\footnote{Idealmente a quantidade de \english{threads} corresponde ao número de núcleos disponíveis.}.
	A grande diferença desse despachador é a capacidade de agrupar diversos eventos gerados pela
	aplicação, por exemplo diversas mensagens recebidas, gerando uma única tarefa assíncrona;		
	
	\item Despachador impulsionado por \english{threads}:  
	O despachador é definido na classe \lstinline$akka.dispatch.ThreadBasedDispatcher$ e
	é o mais simples de todos os dispachadores, já que associa uma \english{thread} para 
	cada ator. O uso desse despachador implica no ator
	utilizar filas transientes. É importante ressaltar que internamente é utilizado uma fila
	que faz o bloqueio da \english{thread} que está tentando adicionar um elemento, caso o limite
	superior da fila tenha sido atingido (para o caso onde há um limite informado). 		
\end{itemize}

Por padrão, atores são associados ao despachador global impulsionado por eventos. A 
configuração padrão do despachador define uma fila transiente sem limite máximo de mensagens. 
Caso seja necessário definir um outro despachador para um ator, a definição deve acontecer 
antes de o ator ser inciado via método \lstinline$self.dispatcher$. 

\subsubsection{Envios de respostas}

Envios de mensagens podem gerar mensagens de resposta ao remetente. Os métodos para
envios de mensagens capturam implicitamente uma cópia da referência da entidade que está 
fazendo o envio. A referência é enviada junto com a mensagem para que o ator destinatário 
possa eventualmente enviar uma mensagem de resposta.

O ator destinatário pode responder a uma mensagem via método \lstinline$self.reply$. 
A execução do método de resposta nada mais é que um envio de mensagem como já apresentado.
Envios de mensagens feitos via métodos \lstinline$!!$ e \lstinline$!!!$ são 
considerados como feitos por ``remetentes futuros''. Uma vez que o ator enviou
a mensagem de resposta, a mensagem não é coloca em uma fila de mensagens assim como
acontece para atores, mas é utilizada para indicar no resultado futuro que a computação 
foi completada. 

Envios de mensagens não são limitados somente a atores. Qualquer objeto
ou classe pode enviar uma mensagem a um ator. Podemos notar que o código da listagem 
\ref{lst:actorOf1} não está definido em um ator. O ator que está para enviar a mensagem
de resposta pode verificar se há um remetente definido associado a mensagem recebida, 
porém existe um modo alternativo e mais simples. O método \lstinline$seld.reply_?$ faz o 
envio ao remetente somente no caso em que há um remetente definido, devolvendo o valor 
boleano \english{true} para indicar se houve envio, ou \english{false} caso contrário.
                
\section{Atores remotos}
\index{Akka!Atores remotos}
\label{sec:atores_remotos_akka}

No contexto de um envio de mensagem para um ator remoto, o termo cliente se refere à 
entidade que está enviando a mensagem. O termo servidor denota o processo (máquina virtual) 
no qual reside o ator remoto. Atores remotamente acessíveis possuem as mesmas características
de atores locais no que diz respeito ao recebimento e despachamento de mensagens. Atores
locais e remotos diferem basicamente na criação e no envio de mensagens. A infra-estrutura 
de atores remotos utiliza os seguintes elementos:
	
\begin{itemize}	
	\item \lstinline$RemoteServerModule$: É uma \english{trait} que define as responsabilidades
	do componente usado no lado do servidor. Suas implementações têm como
	responsabilidade manter registrados os atores, bem como encaminhar a eles as mensagens 
	recebidas de clientes remotos. Cada \code{RemoteServerMobule} é associado a um \english{host} 
	e a uma porta TCP. Um mesma máquina virtual pode conter múltiplos \code{RemoteServerModule}s;

	\item \lstinline$RemoteClientModule$: É uma \english{trait} que define as responsabilidades
	do componente usado no lado do cliente. Suas implementações têm como responsabilidade 
	visível oferecer uma interface para obtenção de referências a atores remotos. 
	Oferece também suporte em tempo de execução para a infra-estrutura de atores do lado do 
	cliente, provendo uma série de serviços não vísiveis para o usuário, tais como
	seriação de mensagens, envio de mensagens para atores remotos,
	conversão de ator local em ator remoto e intermediação de 
	mensagens de resposta vindas do \code{RemoteServerModule}, no caso envios via \lstinline$!!$
	ou \lstinline$!!!$;

	\item \lstinline$RemoteSupport$: É acessível via \lstinline$Actor.remote$. Essa
	classe abstrata é responsável por concentrar as responsabilidades definidas para os
	módulos remotos do cliente e do servidor e ser um ponto único de suporte remoto;

	\item \lstinline$RemoteActorRef$: É uma classe equivalente a \lstinline$LocalActorRef$, porém
	utiliza o suporte remoto para fazer envio das mensagens.
\end{itemize}

A implementação de atores remotos do Akka, implementa os componentes de suporte remoto com o
auxílio do JBoss Netty. Apresentamos na figura \ref{fig:remote-actor-colaboracao} como os 
componentes se relacionam. Dividimos a figura em duas partes, sendo a camada de interface remota
que é a que a implementação interage diretamente, e a camada de implementação. A camada
de implementação é associada com a implementação em tempo de execução, sendo que outras 
implementações podem criadas e utilizadas.

\vspace{1ex}
\begin{figure}[hbtp]
 	\centering
	\includegraphics[scale=.75]{remote-actor-colaboracao} 
  	\caption{Relacionamento entre os componentes remotos.}
  	\label{fig:remote-actor-colaboracao}
\end{figure}
	
A figura \ref{fig:remote-actor-diagram} mostra os elementos acima descritos e os 
relacionamentos entre esses elementos. A criação de atores remotos pelo cliente é 
análoga a de atores locais, salvo o fato de se informar o \english{host} e porta 
de um \code{RemoteServer} já em execução. A listagem \ref{lst:subclass-actor-remote} 
mostra a criação por meio de uma sub-classe de \code{RemoteActor}. Vale destacar que, 
nesta listagem, o valor de \code{myRemoteActor} (linha $12$) é um \english{proxy} local 
para o ator remoto. Outra possibilidade é criar um ator local e posteriormente convertê-lo
em remoto, por meio de uma chamada ao método \code{makeRemote(host, port)} 
(listagem \ref{lst:make-remote-of-local-actor}). Tal chamada deve ocorrer anteriormente
à ativação do ator via chamada ao método \code{start}.
       	
A criação de atores remotos pelo servidor, por sua vez, é exatamente igual a de atores 
locais, mostram as listagens \ref{lst:subclass-actor} e \ref{lst:anonym-actor}. 
Depois de criar o ator localmente, basta registrá-lo em um \code{RemoteServer} 
ou \code{RemoteNode}, como mostra a listagem \ref{lst:registering-actor}. 
A maneira com que o cliente remoto busca pelo ator e envia uma mensagem pode ser
vista na listagem \ref{lst:using-remote-actor}.
        
Quando um cliente envia uma mensagem a um ator remoto, o \english{proxy} local 
embrulha a mensagem, adicionando a ela informações de cabeçalho necessárias para 
o envio. O \english{proxy} usa um  \code{RemoteClient} para enviar a mensagem ao 
\code{RemoteServer} correspondente. Este processo de envio, do ponto de vista do cliente
leva tempo $O(1)$, já que a seriação da mensagem é feita de modo assíncrono.
        
A figura \ref{fig:remote-actor-message-flow} mostra o caminho que a mensagem faz saindo
da aplicação cliente via \english{proxy} e sendo repassada para um \code{RemoteClient}, 
que por sua vez faz a seriação assíncrona da mensagem e a envia para o \code{RemoteServer} 
correspondente. Uma vez que a mensagem tenha sido recebida pelo \english{handler} plugado 
ao JBoss Netty no lado servidor, o \english{handler} examina as informações de cabeçalho, 
localiza o ator destinatário no registro local de atores e encaminha a mensagem a caixa de 
mensagens do ator, como se o envio fosse local. O despachador associado ao ator faz o 
tratamento mostrado na figura \ref{fig:local-actor-message}, já que do ponto de vista do
despachador não há diferença entre um envio local e um remoto.

Em alguns casos, o processamento deve gerar uma mensagem de resposta, como por exemplo
um resultado futuro ou uma mensagem de erro para um ator supervisor. Em tais casos a 
mensagem de resposta faz o caminho contrário, indo do \code{RemoteServer} para
o \code{RemoteClient}, onde analogamente o \english{handler} faz o repasse da resposta
para quem a estiver aguardando.
        