%% ------------------------------------------------------------------------- %%
\chapter{Atores no projeto Akka}
\label{cap:atores_akka}
Os atores do Akka podem ser locais ou remotos. O termo ``ator local'' é usado
para denotar um ator que pode receber mensagens apenas de atores residentes
na mesma máquina virtual. Por outro lado, um ator remoto pode receber mensagens
de quaisquer outros atores, inclusive daqueles residentes em outras máquinas virtuais.
Em outras palavras, o termo ``ator remoto'' é um sinônimo de ``ator remotamente acessível''.

Nas próximas duas seções examinaremos a implementação de atores do projeto Akka. 
Mostraremos a criação e o uso de atores locais ou remotos, bem como o fluxo de uma 
mensagem (envio, tráfego e processamento da mensagem) tanto no caso local como no remoto.
        
\section{Atores locais}
\index{Akka!Atores locais}

A definição de atores locais acontece por meio de extensões da 
\english{trait} \lstinline$akka.actor.Actor$ provendo uma implementação para o 
método \code{receive} como mostrado na listagem \ref{lst:def-actor}. 
A definição de um ator ``descreve'' o comportamento que o
ator terá, sendo que o ator propriamente dito que possui a infraestrutura provida
pelo arcabouço, é uma instância de \lstinline$akka.actor.ActorRef$. \lstinline$ActorRef$s
são imutáveis, seriáveis, possuem um relacionamento único com a definição do ator,
são acessíveis dentro da definição do ator como \lstinline$self$, além
de conter informação do nó onde foram criadas. 

\begin{lstlisting}[frame=tb, caption={Classe SampleActor.}, label={lst:def-actor}]
class SampleActor(val name: String) extends akka.actor.Actor {
  def this() = this("No name")

  def receive = {
    case "hello" => println("%s received hello".format(name))
    case          _ => println("%s received unknown".format(name))
  }
}
\end{lstlisting}

Atores são criados pelo método \lstinline$actorOf$ do objeto \lstinline$akka.actor.Actor$
como mostrado na listagem \ref{lst:actorOf1}. Nessa listagem a instância do ator é criada
com base no tipo da classe, onde o construtor público e sem argumentos da classe é invocado
por reflexão. O método \lstinline$actorOf$ é sobrecarregado para permitir que uma função sem 
argumentos e com tipo de retorno \lstinline$Actor$, possa ser passada como argumento para ser 
invocada na criação do ator substituíndo a invocação do construtor padrão, como mostrado na 
listagem \ref{lst:actorOf2}. 

Nas duas listagens tivemos que chamar explicitamente o método 
\lstinline$start$ para inicializar o ator. Os atores do projeto Akka possuem um conjunto de estados
simples, bem definido e linear. Um ator, logo após sua criação, está no estado chamado de ``novo'' 
e ainda não pode receber mensagens. Após a chamada do método \lstinline$start$, o ator passa ao 
estado ``iniciado'' e está apto a receber mensagens. Uma vez que o método \lstinline$exit$ é invocado
o ator passa ao estado de ``desligado'' e não pode mais executar ação alguma.

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via construtor padrão.}, label={lst:actorOf1}]
  val theActor = Actor.actorOf[SampleActor].start
  theActor ! "hello"
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via função de inicialização.}, label={lst:actorOf2}]
  val function = {
    // some other actions here
    new SampleActor("John")
  }
  val theActor = Actor.actorOf(function).start
  theActor ! "hello"
\end{lstlisting}

Mensagens que são enviadas para um ator são colocada sincronamente 
na fila de mensagens do ator, levando tempo $O(1)$. As mensagens enfileiradas são então 
despachadas assincronamente para a função parcial definida no bloco \lstinline$receive$, 
como mostrado na figura \ref{fig:local-actor-message}. 

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics{local-actor-message} 
  	\caption{Akka -- Envio e despacho de mensagens para atores locais.}
  	\label{fig:local-actor-message}
\end{figure}

O despachador de um ator possui um papel importante. Ele permite a configuração do tipo
da fila do ator e a semântica de despachamento das mensagens. As filas dos atores podem ser 
duráveis ou transiente e terem seu tamanho limitado superiormente ou não. O Akka
permite que despachadores específicos sejam definidos, porém possui em sua distribuição quatro 
tipos de despachadores listados a seguir:

\begin{itemize}
	\item \english{ExecutorBasedEventDrivenDispatcher}: é o despachador padrão impulsionado por 
	eventos. Esse despachador normalmente é compartilhado por diversos atores de diferentes
	tipos, já que ele utiliza um \english{thread pool} para agendar as ações de despachamento.
	É o despachador mais flexível em termos de configurações, já que permite que os
	parâmetros do \english{thread pool}, como quantidade máxima e mínima de \english{threads}
	sejam configurados, e da fila, como limite de mensagens, durabilidade e políticas para
	rejeição sejam configurados;

	\item \english{ExecutorBasedEventDrivenWorkStealingDispatcher}: semelhante ao despachador
	anterior, esse despachador deve ser usado em atores do mesmo tipo já que permite que
	instâncias que não estão processando mensagens, possam ``roubar'' mensagens de filas de atores
	que estão sobrecarregados, permitindo o balanceamento do processamento das mensagens entre
	os atores;
	
	\item \english{HawtDispatcher}: inspirado no \english{Grand Central Dispacher} do Mac OS X
	\cite{apple-gcd}, define um \english{thread pool} cujo tamanho é ajustado ao automaticamente
	para minimizar a quantidade de \english{threads} concorrentes e inativas
	\footnote{Idealmente a quantidade de \english{threads} corresponde ao número de núcleos disponíveis.}.
	A grande diferença desse despachador é a capacidade de agrupar diversos eventos gerados pela
	aplicação, por exemplo diversas mensagens recebidas, gerando uma única tarefa assíncrona;		
	
	\item \english{ThreadBasedDispatcher}:  é o mais simples de todos os dispachadores, já que
	associa uma \english{thread} para cada ator. O uso desse despachador implica no ator
	utilizar filas transientes. É importante ressaltar que internamente é utilizado uma fila
	que faz o bloqueio da \english{thread} que está tentando adicionar um elemento, caso o limite
	superior da fila tenha sido atingido (para o caso onde há um limite informado). 		
\end{itemize}

Por padrão, atores são associados ao despachador global impulsionado por eventos. A 
configuração padrão do despachador define uma fila transiente sem limite máximo de mensagens. 
Caso seja necessário definir um outro despachador para um ator, a definição deve acontecer 
antes de o ator ser inciado via método \lstinline$self.dispatcher$. 


% falar dos outros tipos de envio? falar de hotswap? falar de hierarquia de supervisao?

                
\section{Atores remotos}
\label{sec:atores_remotos_akka}
No contexto de um envio de mensagem para um ator remoto, o termo cliente se refere à 
entidade que está enviando a mensagem. O termo servidor denota o processo (máquina virtual) 
no qual reside o ator remoto. A infra-estrutura de atores remotos utiliza os seguintes elementos:
	
\begin{itemize}

	\item \code{RemoteActor}: Sub-classe de \code{Actor} que torna conveniente 
	a criação de um ator remoto, ao invés de se criar explicitamente um ator local 
	e torná-lo remoto.

	\item \code{RemoteServer}: É um componente usado no lado do servidor. Tem como 
	responsabilidade manter registrados os atores, bem como encaminhar a eles as mensagens 
	recebidas de clientes remotos. Cada \code{RemoteServer} é associado a um \english{host} 
	e a uma porta TCP. Um mesma máquina virtual pode conter múltiplos \code{RemoteServer}s.

	\item \code{RemoteNode}: Objeto \english{singleton} que é instância de 
	\code{RemoteServer}. Não possui nenhum comportamento adicional e é usado quando 
	se deseja ter um único \code{RemoteServer} numa dada máquina virtual.

	\item \code{Cluster}: Abstração para se agrupar instâncias de \code{RemoteServer}. 
	Permite que um cliente interaja com múltiplos \code{RemoteServer}s, por exemplo via 
	\english{broadcasts} de mensagens;

	\item \code{RemoteClient}: É um componente usado pelo cliente. Tem como responsabilidade 
	visível oferecer uma interface para obtenção de referências a atores remotos. 
	Oferece também suporte em tempo de execução para a infra-estrutura de atores do lado do 
	cliente, provendo uma série de serviços não vísiveis para o usuário, tais como: 
	\entry{(i)} seriação de mensagens; \entry{(ii)} envio de mensagens para atores remotos; 
	\entry{(iii)} conversão de ator local em ator remoto; \entry{(iv)} intermediação de 
	mensagens de resposta vindas do \code{RemoteServer}, no caso envios via \code{!!} 
	ou \code{!!!}.

\end{itemize}
	
A figura \ref{fig:remote-actor-diagram} mostra os elementos acima descritos e os 
relacionamentos entre esses elementos. A criação de atores remotos pelo cliente é 
análoga a de atores locais, salvo o fato de se informar o \english{host} e porta 
de um \code{RemoteServer} já em execução. A listagem \ref{lst:subclass-actor-remote} 
mostra a criação por meio de uma sub-classe de \code{RemoteActor}. Vale destacar que, 
nesta listagem, o valor de \code{myRemoteActor} (linha $12$) é um \english{proxy} local 
para o ator remoto. Outra possibilidade é criar um ator local e posteriormente convertê-lo
em remoto, por meio de uma chamada ao método \code{makeRemote(host, port)} 
(listagem \ref{lst:make-remote-of-local-actor}). Tal chamada deve ocorrer anteriormente
à ativação do ator via chamada ao método \code{start}.
       	
A criação de atores remotos pelo servidor, por sua vez, é exatamente igual a de atores 
locais, mostram as listagens \ref{lst:subclass-actor} e \ref{lst:anonym-actor}. 
Depois de criar o ator localmente, basta registrá-lo em um \code{RemoteServer} 
ou \code{RemoteNode}, como mostra a listagem \ref{lst:registering-actor}. 
A maneira com que o cliente remoto busca pelo ator e envia uma mensagem pode ser
vista na listagem \ref{lst:using-remote-actor}.
        
Quando um cliente envia uma mensagem a um ator remoto, o \english{proxy} local 
embrulha a mensagem, adicionando a ela informações de cabeçalho necessárias para 
o envio. O \english{proxy} usa um  \code{RemoteClient} para enviar a mensagem ao 
\code{RemoteServer} correspondente. Este processo de envio, do ponto de vista do cliente
leva tempo $O(1)$, já que a seriação da mensagem é feita de modo assíncrono.
        
A figura \ref{fig:remote-actor-message-flow} mostra o caminho que a mensagem faz saindo
da aplicação cliente via \english{proxy} e sendo repassada para um \code{RemoteClient}, 
que por sua vez faz a seriação assíncrona da mensagem e a envia para o \code{RemoteServer} 
correspondente. Uma vez que a mensagem tenha sido recebida pelo \english{handler} plugado 
ao JBoss Netty no lado servidor, o \english{handler} examina as informações de cabeçalho, 
localiza o ator destinatário no registro local de atores e encaminha a mensagem a caixa de 
mensagens do ator, como se o envio fosse local. O despachador associado ao ator faz o 
tratamento mostrado na figura \ref{fig:local-actor-message}, já que do ponto de vista do
despachador não há diferença entre um envio local e um remoto.

Em alguns casos, o processamento deve gerar uma mensagem de resposta, como por exemplo
um resultado futuro ou uma mensagem de erro para um ator supervisor. Em tais casos a 
mensagem de resposta faz o caminho contrário, indo do \code{RemoteServer} para
o \code{RemoteClient}, onde analogamente o \english{handler} faz o repasse da resposta
para quem a estiver aguardando.
        