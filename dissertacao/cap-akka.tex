%% ------------------------------------------------------------------------- %%
\chapter{Atores no projeto Akka}
\label{cap:atores_akka}
O projeto Akka disponibiliza tanto atores locais quanto remotos. O termo ``ator local'' é usado
para denotar um ator que pode receber mensagens apenas de atores residentes
na mesma máquina virtual. Por outro lado, um ator remoto pode receber mensagens
de quaisquer outros atores, inclusive daqueles residentes em outras máquinas virtuais.
Em outras palavras, o termo ``ator remoto'' é um sinônimo de ``ator remotamente acessível''.

Nas próximas duas seções examinaremos a implementação de atores do projeto Akka. 
Mostraremos a criação e o uso de atores locais ou remotos, bem como o fluxo de uma 
mensagem (envio, tráfego e processamento da mensagem) tanto no caso local como no remoto.
        
\section{Atores locais}
\index{Akka!atores locais}

A definição de atores locais acontece por meio de extensões da 
\english{trait} \lstinline$akka.actor.Actor$, onde deve-se prover uma implementação para o 
método \code{receive} como mostrado na listagem \ref{lst:def-actor}. 
A definição de um ator descreve o comportamento inicial que o
ator terá. A ator propriamente dito (que possui a infraestrutura provida
pelo arcabouço) é uma instância de \lstinline$akka.actor.ActorRef$. \lstinline$ActorRef$s
são imutáveis, seriáveis, identificáveis e possuem um relacionamento único com a 
definição do ator. 

A \english{trait} \lstinline$Actor$ possui em sua declaração uma referência para o seu 
\lstinline$ActorRef$ definida como \lstinline$self$. No caso de
atores locais, \lstinline$self$ referencia uma instância de \lstinline$akka.actor.LocalActorRef$.
Com essa referência, a classe que define o comportamento do ator pode alterar as definições
padrão providas pelo arcabouço e utilizar métodos, por exemplo, para responder ou encaminhar 
mensagens recebidas, acessar a referência de um ator supervisor ou ainda de atores que estejam
sob supervisão.

\begin{lstlisting}[frame=tb, caption={Classe SampleActor.}, label={lst:def-actor}]
class SampleActor(val name: String) extends akka.actor.Actor {
  def this() = this("No name")

  def receive = {
    case "hello" => println("%s received hello".format(name))
    case          _ => println("%s received unknown".format(name))
  }
}
\end{lstlisting}

Atores são criados pelo método \lstinline$actorOf$ do objeto \lstinline$akka.actor.Actor$
como mostrado na listagem \ref{lst:actorOf1}. Nessa listagem, a instância do ator é criada
por reflexão com base no tipo da classe, onde o construtor padrão é invocado.
O método \lstinline$actorOf$ é sobrecarregado para permitir que uma função sem 
argumentos e com tipo de retorno \lstinline$Actor$, possa ser utilizada como alternativa ao
construtor padrão na criação do ator, como mostrado na listagem \ref{lst:actorOf2}. 

Nas duas listagens tivemos que chamar explicitamente o método 
\lstinline$start$ para iniciar o ator. Os atores do projeto Akka possuem um conjunto de estados
simples, bem definido e linear. Um ator logo após sua criação está no estado chamado de ``novo'' 
e ainda não pode receber mensagens. Após a invocação do método \lstinline$start$, o ator passa ao 
estado ``iniciado'' e está apto a receber mensagens. Uma vez que o método \lstinline$exit$ ou 
\lstinline$stop$\footnote{O método \lstinline$exit$ chama internamente o método 
\lstinline$stop$ que é responsável por desligar o ator.} é invocado, o ator passa 
ao estado de ``desligado'' e não pode mais executar ação alguma.

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via construtor padrão.}, label={lst:actorOf1}]
  val theActor = Actor.actorOf[SampleActor].start
  theActor ! "hello"
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via função de inicialização.}, label={lst:actorOf2}]
  val function = {
    // outras ações
    new SampleActor("John")
  }
  val theActor = Actor.actorOf(function).start
  theActor ! "hello"
\end{lstlisting}

As mensagens que são enviadas para um ator são colocada sincronamente 
na fila de mensagens do ator, levando tempo $O(1)$. As mensagens enfileiradas são então 
despachadas assincronamente para a função parcial definida no bloco \lstinline$receive$, 
como mostrado na figura \ref{fig:local-actor-message}. 

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics{local-actor-message} 
  	\caption{Envio e despacho de mensagens para atores locais.}
  	\label{fig:local-actor-message}
\end{figure}

\subsubsection{Despachadores}

O despachador de um ator é uma entidade que possui um papel importante. O despachador permite a 
configuração do tipo da fila do ator e a semântica do despachamento das mensagens. A fila
de um ator pode ser durável ou transiente e ter seu tamanho limitado superiormente ou não. O Akka
permite que despachadores específicos sejam definidos, porém possui em sua distribuição os quatro 
despachadores listados a seguir:

\begin{itemize}
	\item Despachador impulsionado por eventos: 
	O despachador é definido na classe \lstinline$akka.dispatch.ExecutorBasedEventDrivenDispatcher$
	e é normalmente compartilhado por diversos atores de diferentes
	tipos, já que ele utiliza um \english{thread pool} para agendar as ações de despachamento.
	É o despachador mais flexível em termos de configurações, já que permite que
	parâmetros do \english{thread pool} e da fila de mensagens sejam configurados;

	\item Despachador impulsionado por eventos com balanceamento de carga:
	O despachador é definido na classe \lstinline$akka.dispatch.ExecutorBasedEventDrivenWorkStealingDispatcher$
	e é semelhante ao despachador anterior, já que também é impulsionado por eventos. 
	Esse despachador deve ser usado em atores do mesmo tipo já que permite que
	atores que não estejam processando mensagens possam ``roubar'' mensagens das filas dos atores
	que estão sobrecarregados, permitindo o balanceamento do processamento das mensagens entre
	os atores;
	
	\item Despachador quente: 
	O despachador é definido na classe \lstinline$akka.dispatch.HawtDispatcher$ e é inspirado no 
	\english{Grand Central Dispacher} do Mac OS X \cite{apple-gcd}. Esse despachador 
	define um \english{thread pool} cujo tamanho é ajustado automaticamente
	para minimizar a quantidade de \english{threads} concorrentes e inativas
	\footnote{Idealmente a quantidade de \english{threads} corresponde ao número de núcleos disponíveis.}.
	A grande diferença desse despachador é a capacidade de agrupar diversos eventos gerados pela
	aplicação, por exemplo diversas mensagens recebidas, gerando uma única tarefa assíncrona;		
	
	\item Despachador impulsionado por \english{threads}:  
	O despachador é definido na classe \lstinline$akka.dispatch.ThreadBasedDispatcher$ e
	é o mais simples de todos os dispachadores, já que associa uma \english{thread} para 
	cada ator. O uso desse despachador implica no ator
	utilizar filas transientes. É importante ressaltar que internamente é utilizado uma fila
	que faz o bloqueio da \english{thread} que está tentando adicionar um elemento, caso o limite
	superior da fila tenha sido atingido (para o caso onde há um limite informado). 		
\end{itemize}

Por padrão atores são associados ao despachador global impulsionado por eventos. A 
configuração padrão do despachador define uma fila transiente sem limite máximo de mensagens. 
Caso seja necessário definir um outro despachador para um ator, a definição deve acontecer 
antes de o ator ser inciado via método \lstinline$self.dispatcher$. 

\subsubsection{Envios de respostas}

Envios de mensagens podem gerar mensagens de resposta ao remetente. Os métodos para
envios de mensagens capturam implicitamente uma cópia da referência da entidade que está 
fazendo o envio. Essa cópia é enviada junto com a mensagem para que o ator destinatário 
possa eventualmente enviar uma mensagem de resposta.

O ator destinatário pode responder a uma mensagem via método \lstinline$self.reply$. 
A execução do método de resposta nada mais é que um envio de mensagem como já apresentado.
Envios de mensagens feitos via métodos \lstinline$!!$ e \lstinline$!!!$ são 
considerados como feitos por ``remetentes futuros''. Uma vez que o ator enviou
a mensagem de resposta, a mensagem não é coloca em uma fila de mensagens assim como
acontece para atores, mas é utilizada para indicar no resultado futuro que a computação 
foi completada. 

Envios de mensagens não são limitados somente a atores. Qualquer objeto
ou classe pode enviar uma mensagem a um ator. Podemos notar que o código da listagem 
\ref{lst:actorOf1} não está definido em um ator. O ator que está para enviar a mensagem
de resposta pode verificar se há um remetente definido associado a mensagem recebida, 
porém existe um modo alternativo e mais simples: o método \lstinline$self.reply_?$ faz o 
envio ao remetente somente no caso em que há um remetente definido, devolvendo o valor 
boleano \lstinline$true$ para indicar se houve envio, ou \lstinline$false$ caso contrário.

\subsubsection{Hierarquia de supervisão}
%%% TODO revisar e fazer figura

A biblioteca de atores do Akka permite que o tratamento de erros possa ser feito por
atores definidos como supervisores. Sua implementação é totalmente baseada na abordagem feita na
linguagem Erlang descrita na seção \ref{sec:atores-linguagens-erlang}, e é conhecida como
``deixe que falhe'' (\english{let it crash}). 

Uma hierarquia de supervisão é criada com o uso de ligações entre os atores. A ligação
de dois atores pode acontecer via métodos \lstinline$link$, \lstinline$startLink$ e
\lstinline$spawnLink$, definidos em \lstinline$ActorRef$. O método \lstinline$link$ 
faz a ligação de dois atores. O método \lstinline$startLink$ também faz a ligação
de dois atores, porém coloca o ator que está sendo passado como parâmetro em execução,
enquanto que o método \lstinline$spawnLink$ faz a criação do ator, sua ligação e ainda
o coloca em execução. 

É necessário definir nos atores sob supervisão qual ciclo de vida que o ator possui, para
que o ator supervisor saiba como proceder no caso de erros. Existem duas opções de ciclo de vida:

\begin{enumerate}
	\item Permantente: O ciclo de vida é definido na classe 
	\lstinline$akka.config.Supervision.Permanent$. Indica que o ator possui um ciclo de 
	vida permante, ou seja, sempre deve ser reiniciado no caso de erros;
	
	\item Temporário: O ciclo de vida é definido na classe 
	\lstinline$akka.config.Supervision.Temporary$.
	Indica que o ator possui um ciclo de vida temporário, ou seja,
	não deve ser reiniciado no caso de erros. Contudo, esse ciclo de vida
	indica que o ator deve ser desligado pelo processo regular, ou seja, como
	se o método \lstinline$exit$ tivesse sido invocado. O processo regular
	ainda faz uma invocação ao método \lstinline$postStop$;	
\end{enumerate}

A definição de um ator com ciclo de vida permanente é mostrada na listagem
\ref{lst:supervised-actor}. Na linha $2$ definimos o seu ciclo de vida. 

O processo de reinicialização de um ator consiste na criação de uma nova instância da
classe que define o ator. Os métodos \lstinline$preRestart$ e \lstinline$postRestart$ são 
invocados, respectivamente, antes de o ator ser desligado e logo após ele ter sido reiniciado.
O método \lstinline$preRestart$ é invocado no ator onde ocorreu a exceção. Em contrapartida, 
o método \lstinline$postRestart$é invocado na nova instância. A \lstinline$ActorRef$ do
ator onde ocorreu o erro e do novo ator é a mesma. A criação da nova instância da classe que
define o ator utiliza o mesmo modo que o ator foi criado originalmente. Por exemplo, 
na listagem \ref{lst:actorOf1} criamos o ator via construtor padrão e na listagem \ref{lst:actorOf2}, 
utilizamos uma função específica. 

\begin{lstlisting}[frame=tb, caption={Ator com ciclo de vida permanente.}, label={lst:supervised-actor}]
class MySupervised extends akka.actor.Actor{
  self.lifeCycle = akka.config.Supervision.Permanent

  override def postRestart(reason: Throwable): Unit = {
    // restore the state
  }

  override def preRestart(reason: Throwable): Unit = {
    // save the current state
  }

  def receive = {
    case msg => println("message received: %s".format(msg))
  }
}
\end{lstlisting}

É necessário também definir no ator supervisor qual será a estratégia de reinicialização para
os atores que estejam ligados a ele. Existem duas estratégias possíveis:

\begin{enumerate}
	\item Um por um: É definida na classe 
	\lstinline$akka.config.Supervision.OneForOneStrategy$. Quando essa estratégia é utilizada,
	exceções que sejam lançadas em um ator sob supervisão que possua um ciclo de vida permanente,
	fazem com que somente o ator seja reiniciado;
	
	\item Todos por um: É definida na classe 
	\lstinline$akka.config.Supervision.AllForOneStrategy$. 
	Quando essa estratégia é utilizada, exceções que sejam lançadas em um ator sob supervisão, 
	fazem com que todos os atores sob o mesmo supervisor sejam reiniciados. 	
\end{enumerate}

Junto com a estratégida de reinicialização, é necessário definir quais são as exceções que o ator
é responsável por fazer o tratamento, além de configurações relacionadas a quantas tentativas de
reinicialização devem ser feitas dentro de um período de tempo. Mostramos na listagem 
\ref{lst:supervisor-actor} a definição do ator supervisor. Na linha $2$ utilizamos a estratégia 
um por um, capturando as exceções do tipo \lstinline$java.lang.Exception$, com $2$ 
tentativas de reinicialização em um período de $5$ segundos. Caso o limite de tentativas
de reinicialização tenha sido atingido, porém sem sucesso na reinicialização do ator supervisionado,
uma mensagem específica é enviada para o ator supervisor. Essa mensagem pode ser capturada para
que as ações necessárias sejam tomadas.

\begin{lstlisting}[frame=tb, caption={Ator supervisor.}, label={lst:supervisor-actor}]
class MySupervisor extends akka.actor.Actor {
  self.faultHandler = akka.config.Supervision.OneForOneStrategy(List(classOf[Exception]), 2, 5000)

  def receive = {
    case _ => // ignore all messages
  }
}
\end{lstlisting}

Apresentamos na listagem \ref{lst:supervisor-hier} a criação de uma hierarquia de 
supervisão entre os atores apresentados nas listagens \ref{lst:supervised-actor} 
e \ref{supervisor-actor}.

\begin{lstlisting}[frame=tb, caption={Criação da hierarquia de supervisão.}, label={lst:supervisor-hier}]
object SampleSupervisorHierarchy extends Application {
  val actorSupervisor = Actor.actorOf[MySupervisor].start
  val supervised = Actor.actorOf[MySupervised]
  actorSupervisor.startLink(supervised)
}
\end{lstlisting}

Atores supervisores e supervisionados podem trocar mensagens. Quando criamos uma ligação
de supervisão entre dois atores, como na linha $4$ da listagem \ref{lst:supervisor-hier},
a referência para o ator supervisor passa a estar definida no ator \lstinline$supervised$.
Essa referência é acessível via método \lstinline$self.supervisor$. 

Um ator que supervisiona outros atores também pode ser supervisionado por outro ator, como 
mostrado na figura \ref{}. Podemos notar na figura que podemos criar sub-hierarquias de 
supervisão que permitem certa flexibilidade do tratamento de erros.

\section{Atores remotos}
\index{Akka!atores remotos}
\label{sec:atores_remotos_akka}

No contexto de um envio de mensagem para um ator remoto, o termo cliente se refere à 
entidade que está enviando a mensagem. O termo servidor denota o processo (máquina virtual) 
no qual reside o ator remoto. Atores remotamente acessíveis possuem as mesmas características
de atores locais no que diz respeito ao recebimento e despachamento de mensagens. Atores
locais e remotos diferem basicamente na criação e no envio de mensagens. A infra-estrutura 
de atores remotos utiliza os seguintes elementos:
	
\begin{itemize}	
	\item \lstinline$RemoteServerModule$: É uma \english{trait} que define as responsabilidades
	do componente usado no lado do servidor. Suas implementações têm como
	responsabilidade manter registrados os atores, bem como encaminhar a eles as mensagens 
	recebidas de clientes remotos. Cada \lstinline$RemoteServerModule$ é associado a um \english{host} 
	e a uma porta TCP. Um mesma máquina virtual pode conter múltiplos \lstinline$RemoteServerModule$s.
	A documentação do Akka utiliza para esse componente a terminologia ``servidor remoto'' 
	(\english{remote server});

	\item \lstinline$RemoteClientModule$: É uma \english{trait} que define as responsabilidades
	do componente usado no lado do cliente. Suas implementações têm como responsabilidade 
	visível oferecer uma interface para obtenção de referências a atores remotos. 
	Oferece também suporte em tempo de execução para a infra-estrutura de atores do lado do 
	cliente, provendo uma série de serviços não vísiveis para o usuário, tais como
	seriação de mensagens, envio de mensagens para atores remotos,
	conversão de ator local em ator remoto e intermediação de 
	mensagens de resposta vindas do \lstinline$RemoteServerModule$, no caso envios via \lstinline$!!$
	ou \lstinline$!!!$. A documentação do Akka utiliza para esse componente a terminologia
	``cliente remoto'' (\english{remote client});

	\item \lstinline$RemoteSupport$: É acessível via \lstinline$Actor.remote$. Essa
	classe abstrata é responsável por concentrar as responsabilidades definidas para os
	módulos remotos do cliente e do servidor e ser um ponto único de suporte remoto;

	\item \lstinline$RemoteActorRef$: É uma classe equivalente a \lstinline$LocalActorRef$, porém
	utiliza o suporte remoto para fazer envio das mensagens.		
	
\end{itemize}

A implementação de atores remotos do Akka, implementa os componentes de suporte remoto com o
auxílio do JBoss Netty. Apresentamos na figura \ref{fig:remote-actor-colaboracao} como os 
componentes se relacionam. Dividimos a figura em duas partes, sendo a camada de interface remota
que é a camada que se interage diretamente, e a camada de implementação. A camada
de implementação é associada em tempo de execução, permitindo que outras implementações 
possam ser criadas e utilizadas.

Na versão $1.0$ do Akka, a definição de atores remotos não possui diferença em
relação a definição de atores locais. Podemos utilizar a classe apresentada na 
listagem \ref{lst:def-actor} para criamos instâncias de atores remotos. A criação de atores
remotos pode acontecer tanto no nó onde reside a aplicação servidora, quanto
ser criado remotamente por uma aplicação cliente.

A criação de atores remotos gerenciados pelo servidor (\english{server managed actors})
é mostrada na listagem \ref{lst:remote-server1}. Nessa listagem, um servidor
remoto é inicializado na linha $2$ para que os atores possam ser registrados. Na implementação
padrão feita com o Netty, a inicialização de um servidor remoto implica na associação
de um componente do Netty para monitorar a \english{socket} associada ao par \english{host} e 
porta. Na linha $3$ registramos o ator sob o nome \lstinline$hello-service$. O ator passou a 
estar remotamente acessível por aplicações que residam em outras máquinas virtuais. Um detalhe
importante a ser destacado é a inicialização implícita do ator feita pelo método \lstinline$register$.
A implementação desse método fica a critério dos componentes da camada de implementação de
suporte remoto, porém sua interface obriga que implementações compatíveis inicializem atores
que ainda não estão em execução.

\vspace{1ex}
\begin{figure}[hbtp]
 	\centering
	\includegraphics[scale=.75]{remote-actor-colaboracao} 
  	\caption{Relacionamento entre os componentes remotos.}
  	\label{fig:remote-actor-colaboracao}
\end{figure}


Referências para atores remotos podem ser obtidas via método \lstinline$actorFor$. Esse
método possui diversas sobrecargas, porém a mais simples recebe como argumentos o nome do ator, 
o \english{host} e a porta onde foi feito o registro. A linha $2$ da listagem 
\ref{lst:remote-client1} mostra como uma aplicação cliente 
obtém uma referência para o ator. Podemos notar que o uso do ator na linha $3$ não possui 
nenhuma indicação explícita sobre um envio remoto. O método \lstinline$actorFor$ retorna na 
maioria das vezes instâncias de \lstinline$RemoteActorRef$, que representam \english{proxies} 
locais para o ator remoto. A implementação possui algumas otimizações para que referências
locais sempre que possível. Por exemplo, a entidade que está enviando a mensagem reside no 
mesmo nó que o ator. Em casos como esse, uma instância de \lstinline$LocalActorRef$ é retornada. 

\begin{lstlisting}[frame=tb, caption={Aplicação SampleRemoteServer.}, label={lst:remote-server1}]
object SampleRemoteServer extends Application {
	Actor.remote.start("localhost", 2552)
	Actor.remote.register("hello-service", Actor.actorOf[SampleActor])
}
\end{lstlisting}


\begin{lstlisting}[frame=tb, caption={Aplicação SampleRemoteClient.}, label={lst:remote-client1}]
object SampleRemoteClient extends Application{
  val helloActor = Actor.remote.actorFor("hello-service", "localhost", 2552)
  helloActor ! "Hello"
}
\end{lstlisting}
		
Aplicações cliente podem optar por criar e iniciar atores em nós que não sejam o corrente.
Esses atores são chamados de atores gerenciados pelo cliente (\english{client managed actors}). 
Para tal, a biblioteca de atores fornece uma versão alternativa do método \lstinline$actorOf$
que recebe parâmetros adicionais para indicar o nó onde o ator criado será executado. O Akka
não possui carregamento remoto de classes, obrigando que as classes com as definições
dos atores estejam acessíveis para a máquina virtual onde ele será instanciado e executado.
Uma outra observação importante a ser feita em relação ao servidor remoto que irá executar
o ator sendo criado, é a necessidade de ele estar em execução antes de o método \lstinline$actorOf$
ser invocado. Os detalhes observados são alguns dos exemplos que motivam discussões entre
a comunidade de desenvolvedores do Akka para que esse tipo de suporte seja depreciado e 
removido em versões futuras, já que os mesmos resultados podem ser obtidos com o uso de 
atores gerenciados pelo servidor.

\subsection{Fluxo de envio das mensagens}
\index{Akka!atores remotos!fluxo de envio}
\label{sec:atores_remotos_akka_fluxo}

Quando um cliente envia uma mensagem a um ator remoto, alguns passos adicionais
acontecem em relação a um envio local, como mostrado na figura 
\ref{fig:remote-actor-message-flow}. O processo começa com o \english{proxy} local 
embrulhando a mensagem e adicionando a ela informações de cabeçalho necessárias para 
o envio e posterior processamento. O seriador é responsável por converter a informação 
recebida em um vetor de \english{bytes} para que o transporte possa ocorrer. 
Uma vez que a informação esteja no formato a ser transportado, o \english{proxy} usa uma 
implementação de \lstinline$RemoteSupport$ (que na figura \ref{fig:remote-actor-message-flow} é 
uma instância de \lstinline$NettyRemoteSupport$) para enviar a mensagem ao \lstinline$RemoteSupport$ 
que está no lado do servidor. Este processo de envio, do ponto de vista do cliente leva tempo $O(1)$, 
já que o envio da mensagem é feita de modo assíncrono.

\vspace{1ex}
\begin{figure}[hbtp]
 	\centering
	\includegraphics[scale=.9]{remote-actor-message-flow} 
  	\caption{Fluxo de envio de mensagens para atores remotos.}
  	\label{fig:remote-actor-message-flow}
\end{figure}
        
Uma vez que a mensagem tenha sido recebida pelo \english{handler} plugado 
ao JBoss Netty no lado servidor, o \english{handler} repassa a informação recebida para o
seriador. O seriador faz o processo inverso do envio, repassando uma representação desseriada da
informação recebida para o \english{handler}. O \english{handler} examina as informações de 
cabeçalho adicionadas na mensagem, localiza o ator destinatário no registro local de atores 
e encaminha a mensagem à caixa de mensagens do ator fazendo um envio local. Esse envio local
respeita o remetente remoto original da mensagem. O despachador associado ao ator tem o 
mesmo comportamento já mostrado na figura \ref{fig:local-actor-message}.

Em alguns casos o processamento deve gerar uma mensagem de resposta, como por exemplo,
um resultado futuro ou uma mensagem de erro para um ator supervisor. Em tais casos, a 
mensagem de resposta faz o caminho inverso. O \english{handler} ao receber a mensagem,
utiliza o seriador e faz o repasse da resposta para quem a estiver aguardando.

O Akka possui uma configuração opcional de segurança onde cada JVM que esteja executando o
arcabouço pode definir um \english{cookie}. O \english{cookie} nada mais é do que uma chave
que o usuário pode gerar e que é parte das informações de cabeçalho das mensagens.
Quando a verificação de segurança está ativada, o recebedor da mensagem verifica se a informação
do \english{cookie} presente na mensagem confere com a informação esperada. Essa verificação
ocorre entre os passos $6$ e $7$ da figura \ref{fig:remote-actor-message-flow} e caso
os valores sejam iguais, o passo $7$ será executado. Caso contrário, uma excessão de segurança 
é lançada na JVM que recebeu a mensagem e o passo $7$ não será executado.

O Netty oferece algumas opções específicas para o transporte de mensagens baseadas
em \english{socket}s TCP. Exemplos dessas opções são a definição do tamanho máximo da
janela utilizada para o envio das mensagens a atores remotos, o tempo limite de espera 
para leitura na \english{socket}, o intervalo de espera para tentativa de reconexão e
o intervalo máximo em que o cliente deve tentar se conectar. Além dessas opções, o
Netty fornece ainda a possibilidade de compactação das mensagens durante o envio. O Akka
faz uso de todas as opções listadas, permitindo que os usuários da biblioteca definam
os valores desejados. As configurações de todos os módulos do Akka são feitas no 
arquivo \lstinline$akka.conf$. 

\subsection{Protocolo para envios de mensagens a atores remotos}
\index{Akka!atores remotos!protocolo}
\label{sec:atores_remotos_akka_protocolo}

O protocolo utilizado para envios de mensagens a atores remotos é definido no Akka com o
uso da biblioteca Protobuf \cite{protobuf}. 

Protobuf é uma biblioteca que permite que dados estruturados sejam representados 
em um formato eficiente e extensível. A biblioteca possui uma espécie de compilador que 
converte a definição de protocolos em classes Java, Python e C++, permitindo uma interação 
direta com o protocolo nas linguagens, sem a necessidade de bibliotecas adicionais 
para conversões. A bibliteca permite que protocolos sejam definidos com a palavra-chave 
\lstinline$message$. Protocolos podem contér outros protocolos e tipos primitivos 
de dados, como por exemplo números, textos, boleanos e vetores de dados. Ademais, pode-se
definir a obrigatoriedade dos valores para alguns atributos com as palavras-chaves
\lstinline$optional$ e \lstinline$required$.

O protocolo para endereços remotos é apresentado na listagem 
\ref{lst:proto-remote-address}. Endereços remotos são utilizados por referências remotas 
para identificar, por exemplo, onde o ator remoto foi criado. 
O protocolo para referências de atores remotos é apresentado na listagem 
\ref{lst:proto-remote-actor}. As mensagens para atores remotos são definidas com 
base no tipo de seriação que foi definido na JVM que fez o envio. Para que a JVM 
que esteja recebendo a mensagem possa fazer o processamento correto, a informação do tipo de 
seriação deve estar presente. Os protocolos para definição dos tipos de seriações e 
das mensagens são mostrados nas listagens \ref{lst:proto-enum-serial} e \ref{lst:proto-message}, 
respectivamente. Por fim, o protocolo utilizado para as mensagens remotas que é composto, dentre
outros protocolos menores, pelo protocolo para mensagens e pelo protocolo para referências remotas,
é apresentado na listagem \ref{lst:proto-remote-message}.

Optamos por não detalhar os demais protocolos utilizados para compor o protocolo para
mensagens remotas pois, apesar de serem importantes para o suporte a atores remotos, 
eles não possuem grande relevância para o desenvolvimento deste trabalho.

\begin{lstlisting}[frame=tb, caption={Protocolo para endereços remotos.}, label={lst:proto-remote-address}]
message AddressProtocol {
  required string hostname = 1;
  optional uint32 port = 2;
}
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Protocolo para referências de atores remotos.}, label={lst:proto-remote-actor}]
message RemoteActorRefProtocol {
  required string classOrServiceName = 1;
  required string actorClassname = 2;
  required AddressProtocol homeAddress = 3;
  optional uint64 timeout = 4;
}
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Enumeração com tipos de seriação suportados.}, label={lst:proto-enum-serial}]
enum SerializationSchemeType {
  JAVA = 1;
  SBINARY = 2;
  SCALA_JSON = 3;
  JAVA_JSON = 4;
  PROTOBUF = 5;
}
\end{lstlisting}  

\begin{lstlisting}[frame=tb, caption={Protocolo para mensagens.}, label={lst:proto-message}]
message MessageProtocol {
  required SerializationSchemeType serializationScheme = 1;
  required bytes message = 2;
  optional bytes messageManifest = 3;
}
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Protocolo para mensagens remotas.}, label={lst:proto-remote-message}]
message RemoteMessageProtocol {
  required UuidProtocol uuid = 1;
  required ActorInfoProtocol actorInfo = 2;
  required bool oneWay = 3;
  optional MessageProtocol message = 4;
  optional ExceptionProtocol exception = 5;
  optional UuidProtocol supervisorUuid = 6;
  optional RemoteActorRefProtocol sender = 7;
  repeated MetadataEntryProtocol metadata = 8;
  optional string cookie = 9;
}
\end{lstlisting}

