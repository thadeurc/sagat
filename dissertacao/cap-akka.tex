%% ------------------------------------------------------------------------- %%
\chapter{Atores no projeto Akka}
\index{Akka}
\label{cap:atores_akka}
O projeto Akka disponibiliza tanto atores locais quanto remotos. O termo ``ator local'' é usado
para denotar um ator que pode receber mensagens apenas de atores residentes
na mesma máquina virtual. Por outro lado, um ator remoto pode receber mensagens
de quaisquer outros atores, inclusive daqueles residentes em outras máquinas virtuais.
Em outras palavras, o termo ``ator remoto'' é um sinônimo de ``ator remotamente acessível''.

Na seção \ref{sec:atores_locais} examinamos a implementação de atores locais. Nosso objetivo
é focar a criação desses atores, o envio e despachamento de mensagens e a hierarquia 
de supervisão. Na seção \ref{sec:atores_remotos_akka} examinamos a implementação de 
atores remotos. Nosso objetivo é focar a estrutura definida para o suporte a atores remotos,
a seriação de mensagens e o formato definido para o envio de mensagens.
        
\section{Atores locais}
\label{sec:atores_locais}
\index{Akka!atores locais}

Para se definir um ator local, cria-se uma classe que é combinada com a feição \code{akka.actor.Actor} 
e que provê uma implementação para o método \code{receive}, como mostrado na listagem \ref{lst:def-actor}. 
A classe que define um ator descreve o comportamento inicial que o
ator terá. Entretanto, o ator propriamente dito não é uma instância dessa classe, e sim 
da feição \code{akka.actor.ActorRef}, cujas instâncias têm o papel de referências para atores. 
Essas referências são imutáveis, seriáveis, identificáveis e armazenam o endereço do nó onde foram criadas. 

\begin{lstlisting}[frame=tb, caption={Classe SampleActor.}, label={lst:def-actor}]
class SampleActor(val name: String) extends akka.actor.Actor {
  def this() = this("No name")

  def receive = {
    case "hello" => println("%s received hello".format(name))
    case          _ => println("%s received unknown".format(name))
  }
}
\end{lstlisting}

Atores são criados pelo método \code{actorOf} do objeto \code{akka.actor.Actor}, um
objeto \english{singleton} que é o objeto acompanhante da feição de mesmo nome. 
A listagem \ref{lst:actorOf1} mostra o uso do método \code{actorOf}, que devolve 
uma instância de \code{akka.actor.ActorRef}. A instância do ator criado
possui uma referência para uma instância da classe que define o comportamento do ator.
Na listagem \ref{lst:actorOf1}, esta instância é criada por reflexão com base no tipo \code{SampleActor}. 
O construtor utilizado durante a reflexão é o construtor padrão. A listagem 
\ref{lst:actorOf1} ilustra também o uso do método \code{!} para fazer
o envio assícrono da mensagem \code{"hello"} ao ator referenciado por \code{theActor}.
O processamento dessa mensagem resultará na impressão do texto \code{"No name received hello"}.

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via construtor padrão.}, label={lst:actorOf1}]
  val theActor = Actor.actorOf[SampleActor].start
  theActor ! "hello"
\end{lstlisting}

O método \code{actorOf} é sobrecarregado para permitir que uma função de inicialização (uma função sem 
argumentos e com tipo de retorno \code{Actor}) possa ser utilizada como alternativa ao
construtor padrão na criação do ator. A listagem \ref{lst:actorOf2} ilustra a criação do ator
via função de inicialização. 

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via função de inicialização.}, label={lst:actorOf2}]
  val function = {
    // outras ações
    new SampleActor("John")
  }
  val theActor = Actor.actorOf(function).start
  theActor ! "hello"
\end{lstlisting}

Nas listagens \ref{lst:actorOf1} e \ref{lst:actorOf2}, tivemos que chamar explicitamente o método 
\code{start} para iniciar o ator. Os atores do projeto Akka possuem um conjunto de estados
simples e linear. Um ator, logo após sua criação, está no estado ``novo'' 
e ainda não pode receber mensagens. Após a invocação do método \code{start}, o ator passa ao 
estado ``iniciado'' e está apto a receber mensagens. Uma vez que o método 
\code{stop} é invocado, o ator passa ao estado ``desligado'' e não executa mais ação alguma.

A feição \code{Actor} possui em sua declaração uma referência para o seu 
\code{ActorRef}, acessível via atributo \code{self}. Com essa referência, a classe que 
define o comportamento do ator pode alterar as definições padrão providas pelo Akka e utilizar 
o métodos do \code{ActorRef} para, por exemplo, enviar uma resposta ao remetente de uma
mensagem ou encaminhar a outro ator uma mensagem recebida. Vale mencionar que, no caso de 
atores locais, \code{self} referencia uma instância da classe \code{akka.actor.LocalActorRef}.

As mensagens que são enviadas para um ator são colocadas sincronamente 
na fila de mensagens do ator, levando tempo $O(1)$. As mensagens enfileiradas são então 
despachadas assincronamente para a função parcial definida no bloco \code{receive} da classe
que define o comportamento do ator, como mostrado na figura \ref{fig:local-actor-message}. 

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics{local-actor-message} 
  	\caption{Envio e despacho de mensagens para atores locais.}
  	\label{fig:local-actor-message}
\end{figure}

\subsection{Despachadores}
\index{Akka!atores locais!despachadores}
O despachador de um ator é uma entidade que possui um papel importante. O despachador permite a 
configuração do tipo da fila do ator e a semântica do despachamento das mensagens. A fila
de um ator pode ser durável ou transiente e ter seu tamanho limitado superiormente ou não. O Akka
possui em sua distribuição os quatro despachadores listados a seguir:

\begin{itemize}
	\item Despachador baseado em \english{threads}:  	
	É o despachador mais simples de todos os despachadores, que associa uma \english{thread} a 
	cada ator. Essa \english{thread} processa sequencialmente as mensagens na fila do ator.
	O uso deste despachador implica no uso de uma fila transiente.
	Internamente, é utilizada uma fila
	que faz o bloqueio da \english{thread} que está tentando adicionar uma mensagem, caso o limite
	superior da fila tenha sido atingido. Este despachador é definido na classe 
	\code{ThreadBasedDispatcher}.

	\item Despachador impulsionado por eventos: 
	É um despachador normalmente compartilhado por diversos atores de diferentes
	tipos, já que ele utiliza um \english{thread pool} para agendar as ações de despachamento.
	Este é o despachador mais flexível em termos de configurações, pois permite que
	parâmetros do \english{thread pool} e da fila de mensagens sejam configurados.
	É definido na classe \code{ExecutorBasedEventDrivenDispatcher}.
	
	\item Despachador impulsionado por eventos com balanceamento de carga:	
	É um despachador semelhante ao despachador anterior, já que também é impulsionado por eventos.
	Este despachador deve ser compartilhado por atores do mesmo tipo, pois permite que
	atores que não estejam processando mensagens possam ``roubar'' mensagens das filas dos atores
	que estejam sobrecarregados. Dessa forma, o despachador dá suporte a uma forma de balanceamento 
	do processamento das mensagens entre os atores.
	É definido na classe \code{ExecutorBasedEventDrivenWorkStealingDispatcher},
	
	\item Despachador quente: 
	É um despachador inspirado no \english{Grand Central Dispacher} do Mac OS X \cite{apple-gcd}. 
	Este despachador define um \english{thread pool} cujo tamanho é ajustado automaticamente
	para minimizar a quantidade de \english{threads} concorrentes e 
	inativas\footnote{Idealmente a quantidade de \english{threads} corresponde ao número de núcleos disponíveis.}.
	Sua vantagem é a capacidade de agrupar múltiplos eventos gerados pela
	aplicação, por exemplo diversas mensagens recebidas, gerando uma única tarefa assíncrona.
	Este despachador é definido na classe \code{HawtDispatcher}.			
\end{itemize}

Por padrão, atores são associados a um despachador global impulsionado por eventos. A 
configuração padrão desse despachador define uma fila transiente sem limite máximo de mensagens. 
Caso seja necessário outro despachador a um ator, a atribuição deve acontecer 
antes do ator ser iniciado via método \code{self.dispatcher}. O Akka permite ainda
que novos despachadores sejam criados. 

\subsection{Envios de respostas}
\index{Akka!atores locais!envios de respostas}
\label{subsec:akka_envio_resposta}

Além do método \code{!}, que faz o envio assícrono de uma mensagem sem devolver resposta
alguma ao remetente, o Akka oferece dois métodos para envio de mensagem com
resposta ao remetente. O primeiro deles é o método \code{!!}, que faz envio síncrono
da mensagem e deixa o remetente bloqueado aguardando uma resposta durante um tempo limite. 
O segundo é o método \code{!!!}, que devolve um resultado futuro ao remetente.

Os métodos para envio de mensagem com resposta ao remetente capturam implicitamente uma
referência para o ator remetente (\english{sender}). A assinatura do método \code{!!} é mostrada na 
listagem \ref{lst:method!!}. Uma cópia da referência ao \english{sender} é enviada junto 
com a mensagem para que o ator destinatário possa, eventualmente, enviar uma mensagem de resposta. 
O ator destinatário pode enviar uma mensagem de resposta via método \code{self.reply}. 

\begin{lstlisting}[frame=tb, caption={Assinatura do método !!.}, label={lst:method!!}]
def !!(message: Any, timeout: Long = this.timeout)
	(implicit sender: Option[ActorRef] = None): Option[Any] = {
	...
}
\end{lstlisting}

A implementação dos métodos \code{!!} e \code{!!!} é baseada em resultados futuros.
Resultados futuros são representações de resultados de computações assíncronas. Na biblioteca de Java,
a classe \code{java.util.concurrent.FutureTask} provê funcionalidades básicas
para resultados futuros. O projeto Akka tem sua própria implementação
de resultados futuros de computações assíncronas. Essa implementação provê
algumas facilidades que não são oferecidas pela implementação de Java e que são necessárias
ao Akka. A feição \code{CompletableFuture} define métodos
para que resultados futuros possam ser completados por outras entidades, como mostra a listagem
\ref{lst:completable}. A implementação do Akka é inspirada no projeto Actorom \cite{actorom} e
é construída sobre classes do pacote \code{java.util.concurrent}.

\begin{lstlisting}[frame=tb, caption={Feição CompletableFuture.}, label={lst:completable}]
trait CompletableFuture[T] extends Future[T] {
  def completeWithResult(result: T)
  def completeWithException(exception: Throwable)
  def completeWith(other: Future[T])
}
\end{lstlisting}

Envios de mensagens via métodos \code{!!} e \code{!!!} são 
considerados como feitos por ``remetentes futuros''. Uma vez que o ator destinatário enviou
a mensagem de resposta, essa mensagem não é colocada em uma fila de mensagens como no caso
de um envio via \code{!}, mas é utilizada para indicar no resultado futuro que a computação 
foi completada. Na \code{ActorRef}, um envio de uma mensagem feito via método \code{!!!} é processado 
da seguinte maneira:

\begin{enumerate}
	\item Uma instância de \code{CompletableFuture} é criada dentro do método.
	
	\item Assim como para um envio assíncrono via \code{!}, a mensagem é colocada na fila do ator destinatário. 
	Além disso, uma referência para a instância de \code{CompletableFuture} criada no passo anterior é colocada 
	juntamente com a mensagem.
	
	\item Uma outra cópia da referência para o \code{CompletableFuture} criado no passo $1$
	é devolvida para quem invocou o método \code{!!!}.
	
	\item Ao final do processamento da mensagem, o \code{CompletableFuture}
	é completado com o resultado. Como a instância completada
	(seja com um resultado válido ou com uma exceção) é a mesma
	referenciada por quem fez a invocação do método \code{!!!}, o resultado pode então
	ser utilizado.
\end{enumerate}

Um envio feito via método \code{!!} possui quase os mesmos passos de processamento.
A diferença está na devolução da referência. Como o envio é síncrono, a espera do resultado
acontece de modo bloqueante dentro do próprio método \code{!!}.
Quando o \code{CompletableFuture} estiver preenchido, o resultado será devolvido ao chamador
do método \code{!!}.

Envios de mensagens não são limitados somente a atores. Qualquer objeto
ou classe pode enviar uma mensagem a um ator. Podemos notar que o código da listagem 
\ref{lst:actorOf1} não está definido em um ator. Num envio de mensagem com resposta
ao remetente (\code{!!} ou \code{!!!}), o ator destinatário
pode verificar se há um remetente definido a mensagem recebida, 
porém existe um modo alternativo e mais simples: o método \code{self.reply\_?} faz o 
envio ao remetente somente no caso em que há remetente definido, devolvendo o valor 
booleano \code{true} para indicar se houve envio ou \code{false} caso contrário.

\subsection{Hierarquias de supervisão}
\index{Akka!atores locais!supervisão}

A biblioteca de atores do Akka permite que o tratamento de erros possa ser feito por
atores definidos como supervisores. Sua implementação é totalmente baseada na abordagem feita na
linguagem Erlang \cite{PROG_ERLANG07} e é conhecida como ``deixe que falhe'' (\english{let it crash}). 

Uma hierarquia de supervisão é criada com o uso de ligações entre atores. A ligação
de dois atores pode acontecer via métodos \code{link}, \code{startLink} e
\code{spawnLink}, definidos em \code{ActorRef}. O método \code{link}
faz a ligação de dois atores $A1$ e $A2$. O método \code{startLink} também faz a ligação
de dois atores $A1$ e $A2$, porém coloca o ator $A2$ em execução.
O método \code{spawnLink} faz a criação do ator $A2$, sua ligação com $A1$ e ainda
coloca $A2$ execução. 

É necessário definir no ator que estará sob supervisão, qual ciclo de vida que esse ator 
deverá ter. O ciclo de vida de um ator indica ao ator supervisor como proceder no caso de erros. 
Existem dois tipos de ciclo de vida:

\begin{enumerate}
	\item Permanente: Indica que o ator possui um ciclo de 
	vida permanente e sempre deve ser reiniciado no caso de erros.
	Este ciclo é definido na classe \code{Supervision.Permanent}.
	
	\item Temporário: 
	Indica que o ator possui um ciclo de vida temporário e
	não deve ser reiniciado no caso de erros. Contudo, esse ciclo de vida
	indica que o ator deve ser desligado normalmente, ou seja, como
	se o método \code{exit} tivesse sido invocado. O processo normal
	ainda faz uma invocação ao método \code{postStop}.	
	Este ciclo é definido na classe \code{Supervision.Temporary}.
\end{enumerate}

A definição de um ator com ciclo de vida permanente é mostrada na listagem
\ref{lst:supervised-actor}. A definição do ciclo de vida do ator acontece na linha $2$.
O processo de reinicialização de um ator consiste na criação de uma nova instância da
classe que define o ator. Os métodos \code{preRestart} e \code{postRestart} são 
invocados, respectivamente, antes de o ator ser desligado e logo após ele ter sido reiniciado.
Alguns detalhes importantes a observarmos sobre a reinicialização de atores:

\begin{itemize}
	\item O método \code{preRestart} é invocado na instância em que ocorreu o erro.

	\item O método \code{postRestart} é invocado na nova instância.

	\item A nova instância criada utiliza a mesma \code{ActorRef} do ator em que ocorreu o erro,
	logo, as duas instâncias possuem o mesmo valor para \code{self}.

	\item  A criação da nova instância é feita da mesma maneira que o ator foi criado 
	originalmente. Por exemplo, na listagem \ref{lst:actorOf1} o ator foi originalmente
	criado via construtor padrão. Já na listagem \ref{lst:actorOf2}, o ator foi originalmente
	criado com o uso de uma função específica.
\end{itemize}

No ator supervisor, por sua vez, deverá ser definida a estratégia de reinicialização para
os atores que ficarão ligados a ele. Existem duas estratégias possíveis:

\begin{enumerate}
	\item Um por um:  
	Quando essa estratégia é utilizada, exceções lançadas por um ator 
	sob supervisão que possua um ciclo de vida permanente, fazem
	com que somente o ator seja reiniciado. Esta estratégia é definida 
	na classe \code{Supervision.OneForOneStrategy}.
	
	\item Todos por um:  
	Quando essa estratégia é utilizada, exceções lançadas por um ator 
	sob supervisão que possua um ciclo de vida permanente, fazem com 
	que todos os atores sob o mesmo supervisor sejam reiniciados. Esta 
	estratégia é definida na classe \code{Supervision.AllForOneStrategy}.
\end{enumerate}

\begin{lstlisting}[frame=tb, caption={Ator com ciclo de vida permanente.}, label={lst:supervised-actor}]
class MySupervised extends akka.actor.Actor{
  self.lifeCycle = akka.config.Supervision.Permanent

  override def postRestart(reason: Throwable): Unit = {
    // restaura o estado
  }

  override def preRestart(reason: Throwable): Unit = {
    // salva o estado corrente
  }

  def receive = {
    case msg => println("message received: %s".format(msg))
  }
}
\end{lstlisting}


Junto com a estratégia de reinicialização, é necessário definir quais são as exceções que o ator
é responsável por fazer o tratamento, além de configurações relacionadas a quantas tentativas de
reinicialização devem ser feitas dentro de um período de tempo. Mostramos na listagem 
\ref{lst:supervisor-actor} a definição de um ator supervisor. Na linha $2$ dessa listagem
definimos a estratégia um por um, supervisionando exceções do tipo \code{java.lang.Exception}, 
com duas tentativas de reinicialização em um período de cinco segundos. Caso o limite de tentativas
de reinicialização tenha sido atingido, porém sem sucesso na reinicialização do ator supervisionado,
uma mensagem específica é enviada para o ator supervisor. Essa mensagem pode estar definida
no método \code{receive} para que as ações necessárias sejam tomadas.

\begin{lstlisting}[frame=tb, caption={Ator supervisor.}, label={lst:supervisor-actor}]
class MySupervisor extends akka.actor.Actor {
  self.faultHandler = akka.config.Supervision.OneForOneStrategy(List(classOf[Exception]), 2, 5000)

  def receive = {
    case _ => // ignora todas as mensagens
  }
}
\end{lstlisting}

Apresentamos na listagem \ref{lst:supervisor-hier} a criação de uma hierarquia de 
supervisão entre os atores apresentados nas listagens \ref{lst:supervised-actor} 
e \ref{lst:supervisor-actor}.

\begin{lstlisting}[frame=tb, caption={Criação da hierarquia de supervisão.}, label={lst:supervisor-hier}]
object SampleSupervisorHierarchy extends Application {
  val actorSupervisor = Actor.actorOf[MySupervisor].start
  val supervised = Actor.actorOf[MySupervised]
  actorSupervisor.startLink(supervised)
}
\end{lstlisting}

Atores supervisores e supervisionados podem trocar mensagens. Quando criamos uma ligação
de supervisão entre dois atores, como na linha $4$ da listagem \ref{lst:supervisor-hier},
a referência para o ator supervisor passa a estar definida no ator \code{supervised}.
Essa referência é acessível via método \code{self.supervisor}. Um ator supervisor
também pode ser supervisionado por outro ator, como mostrado na figura 
\ref{fig:actor-hier}. O encadeamento de atores supervisores abre a possibilidade da
criação de sub-hieraquias, cada uma com seu supervisor. 

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics[scale=.5]{actor-hier} 
  	\caption{Hierarquia de supervisão de atores.}
  	\label{fig:actor-hier}
\end{figure}

\section{Atores remotos}
\index{Akka!atores remotos}
\label{sec:atores_remotos_akka}

No contexto de envios de mensagens para atores remotos, o termo cliente se refere ao processo
(máquina virtual) onde residem as referências para os atores remotos e as demais entidades que, 
normalmente, iniciam o envio de mensagens. O termo servidor denota o processo (máquina virtual) 
no qual reside o ator remoto. Atores remotamente acessíveis possuem as mesmas características
de atores locais no que diz respeito ao recebimento e despachamento de mensagens. Atores
locais e remotos diferem basicamente na sua criação e no envio de mensagens. A infraestrutura 
de atores remotos utiliza os seguintes elementos:
	
\begin{itemize}	
	\item \code{RemoteServerModule}: É uma feição que define as responsabilidades
	do componente utilizado no lado do servidor. Suas implementações têm como
	responsabilidade manter registrados os atores, bem como encaminhar a eles as mensagens 
	recebidas de clientes remotos. Cada \code{RemoteServerModule} é associado a um endereço
	de hospedeiro (\english{host}) e a uma porta TCP. Um mesma máquina virtual pode conter 
	múltiplos \code{RemoteServerModule}s.
	A documentação do Akka utiliza para esse componente a terminologia ``servidor remoto'' 
	(\english{remote server}).

	\item \code{RemoteClientModule}: É uma feição que define as responsabilidades
	do componente usado no lado do cliente. Suas implementações têm como responsabilidade 
	visível oferecer uma interface para obtenção de referências a atores remotos. 
	Ademais, oferece também suporte em tempo de execução para a infraestrutura de atores do lado do 
	cliente, provendo uma série de serviços não visíveis para o usuário, tais como
	seriação de mensagens, envio de mensagens para atores remotos,
	conversão de ator local em ator remoto e intermediação de 
	mensagens de resposta vindas do \code{RemoteServerModule}, no caso envios via \code{!!}
	ou \code{!!!}. A documentação do Akka utiliza para esse componente a terminologia
	``cliente remoto'' (\english{remote client}).

	\item \code{RemoteSupport}: Essa classe abstrata é responsável por concentrar as 
	responsabilidades definidas para os módulos remotos do cliente e do servidor e ser um 
	ponto único de suporte remoto. É acessível via \code{Actor.remote}.

	\item \code{RemoteActorRef}: É uma classe equivalente a \code{LocalActorRef}, porém
	utiliza o suporte remoto para fazer envio das mensagens.
\end{itemize}

A biblioteca de atores remotos do Akka implementa os componentes de suporte remoto com o
auxílio do JBoss Netty \cite{jboss-netty}. Apresentamos na figura \ref{fig:remote-actor-colaboracao} como os 
componentes descritos acima estão relacionados. Dividimos a figura em duas camadas, sendo a primeira a 
camada de interface remota, e a segunda a camada de implementação. A camada
de implementação é associada em tempo de execução, permitindo que demais implementações 
possam ser utilizadas.

Na versão $1.0$ do Akka, a definição de atores remotos não possui diferença em
relação a definição de atores locais. Podemos utilizar a classe apresentada na 
listagem \ref{lst:def-actor} para criamos instâncias de atores remotos. A criação de atores
remotos pode acontecer tanto no nó onde reside a aplicação servidora, quanto
ser criado remotamente por uma aplicação cliente.

A criação de atores remotos gerenciados pelo servidor (\english{server managed actors})
é mostrada na listagem \ref{lst:remote-server1}. Nessa listagem, um servidor
remoto é inicializado na linha $2$ para que os atores possam ser registrados. Na implementação
padrão feita com o Netty, a inicialização de um servidor remoto implica na associação
de um componente do Netty para monitorar a \english{socket} associada ao par hospedeiro e 
porta. Na linha $3$ registramos o ator sob o nome \code{hello-service}. O ator passou a 
estar remotamente acessível a aplicações que residam em outras máquinas virtuais. Um detalhe
importante a ser destacado é a inicialização implícita do ator feita pelo método \code{register}.
A implementação desse método fica a critério dos componentes da camada de implementação de
suporte remoto, porém sua interface obriga que implementações compatíveis inicializem atores
que ainda não estão em execução.

\vspace{1ex}
\begin{figure}[!h]
 	\centering
	\includegraphics[scale=.75]{remote-actor-colaboracao} 
  	\caption{Relacionamento entre os componentes remotos.}
  	\label{fig:remote-actor-colaboracao}
\end{figure}

As referências para os atores remotos são obtidas via método \code{actorFor}. Esse
método possui diversas sobrecargas, sendo que a mais simples recebe como argumentos o nome do ator, 
o endereço do hospedeiro e a porta do \english{remote server} onde o ator foi registrado. 
A linha $2$ da listagem \ref{lst:remote-client1} mostra como uma aplicação cliente 
obtém uma referência para o ator. Podemos notar que, no uso do ator na linha $3$, não há nenhuma 
indicação que caracterize um envio remoto. O método \code{actorFor} devolve, na 
maioria das vezes, instâncias de \code{RemoteActorRef} que representam \english{proxies} 
locais para o ator remoto. A implementação possui algumas otimizações para que referências
locais sejam utilizadas sempre que possível. Por exemplo, caso a entidade que está enviando a mensagem resida no 
mesmo nó que o ator, uma instância de \code{LocalActorRef} é devolvida. 

\begin{lstlisting}[frame=tb, caption={Aplicação SampleRemoteServer.}, label={lst:remote-server1}]
object SampleRemoteServer extends Application {
	Actor.remote.start("localhost", 2552)
	Actor.remote.register("hello-service", Actor.actorOf[SampleActor])
}
\end{lstlisting}
		
Aplicações cliente podem optar por criar e iniciar atores em nós que não sejam o corrente.
Esses atores são chamados de atores gerenciados pelo cliente (\english{client managed actors}). 
Para tal, a biblioteca de atores fornece uma versão alternativa do método \code{actorOf}
que recebe parâmetros adicionais para indicar o nó onde o ator criado será executado. O Akka
não possui carregamento remoto de classes, obrigando que as classes com as definições
dos atores estejam acessíveis para a máquina virtual onde ele será instanciado e executado.
Uma outra observação importante a ser feita em relação ao servidor remoto que irá executar
o ator sendo criado, é a necessidade de ele estar em execução antes de o método \code{actorOf}
ser invocado. Esses detalhes são alguns dos exemplos que motivam discussões entre
a comunidade de desenvolvedores do Akka para que esse tipo de suporte seja depreciado e 
removido em versões futuras, já que os mesmos resultados podem ser obtidos com o uso de 
atores gerenciados pelo servidor.

\begin{lstlisting}[frame=tb, caption={Aplicação SampleRemoteClient.}, label={lst:remote-client1}]
object SampleRemoteClient extends Application{
  val helloActor = Actor.remote.actorFor("hello-service", "localhost", 2552)
  helloActor ! "Hello"
}
\end{lstlisting}


\subsection{Fluxo de envio das mensagens}
\index{Akka!atores remotos!fluxo de envio}
\label{sec:atores_remotos_akka_fluxo}

O envio assíncrono de uma mensagem a um ator remoto tem alguns passos adicionais em relação
a um envio local de mensagens. O processo de um envio assíncrono de uma mensagem
para um ator remoto é ilustrado na figura \ref{fig:remote-actor-message-flow} e acontece
em sete passos:

\begin{enumerate}
	\item O processo de envio começa com o \english{proxy} local 
	embrulhando a mensagem e adicionando a ela informações de cabeçalho necessárias para 
	o envio e processamento posterior. A mensagem embrulhada e com as informações de cabeçalho
	é então repassada ao seriador.
	
	\item O seriador é responsável por converter a informação 
	recebida em um vetor de \english{bytes} para que o transporte possa ocorrer. 
	Uma vez que a informação esteja no formato a ser transportado, o \english{proxy} utiliza uma 
	implementação de \code{RemoteSupport} (que na figura \ref{fig:remote-actor-message-flow} é 
	uma instância de \code{NettyRemoteSupport}) para enviar a mensagem 
	ao \code{RemoteSupport} que está no lado do servidor.
	
	\item A classe \code{ClientBootstrap} repassa a mensagem para o 
	\code{ServerBootstrap} ao qual se está conectada. O processo de envio, do ponto de vista 
	do cliente, leva tempo $O(1)$, já que o transporte da mensagem pelo JBoss Netty 
	entre o \code{ClientBootstrap} e o \code{ServerBootstrap}	
	é feito de modo assíncrono.
	
	\item A classe \code{ServerBootstrap} repassa a mensagem ao \english{handler} que
	lhe foi associado.
	
	\item A implementação do \english{handler} feita no Akka repassa a mensagem para o seriador
	para que a desseriação seja feita.
	
	\item O seriador desseria a mensagem, deixando-a no formato original, e em seguida,
	repassa novamente a mensagem ao \english{handler}.
	
	\item Por fim, a implementação do \english{handler} utiliza as informações definidas
	de cabeçalho da mensagem para identificar qual o ator destinatário no registro
	local de atores e como deve ser feito o envio. No caso do envio assíncrono, o ator 
	destinatário tem seu método \code{!} invocado com a mensagem e eventualmente a 
	referência do ator que fez o envio (ou \code{None} caso contrário).
	O despachador associado ao ator tem o mesmo comportamento já mostrado na 
	figura \ref{fig:local-actor-message}.
\end{enumerate}

\vspace{1ex}
\begin{figure}[!h]
 	\centering
	\includegraphics[scale=.9]{remote-actor-message-flow} 
  	\caption{Fluxo de envio de mensagens para atores remotos.}
  	\label{fig:remote-actor-message-flow}
\end{figure}
        
Os envios feitos via métodos \code{!!} e \code{!!!} para atores remotos são iguais,
e possuem um passo a mais do que os mostrados na figura \ref{fig:remote-actor-message-flow}.
O passo adicional acontece entre os passos $2$ e $3$. Antes da mensagem ser enviada,
uma cópia da referência da instância do resultado futuro que é devolvida é colocada 
no mapa de resultados futuros. A chave para a instância é o identificador da mensagem.

Envios feitos via métodos \code{!!} e \code{!!!}, assim como mensagens para atores
supervisores que estão remotos, geram envios de mensagens no caminho contrário ao mostrado
na figura \ref{fig:remote-actor-message-flow}. Caso a mensagem que foi enviada pelo servidor
seja o resultado de um envio feito via métodos \code{!!} ou \code{!!!}, o conteúdo da mensagem
(seja um resultado de sucesso ou uma exceção) é utilizado para completar o resultado futuro.
Já no caso de mensagens originadas no servidor e que possuam um ator supervisor, o ator supervisor
é localizado e é feito um envio local assíncrono da mensagem para ele.

O Akka possui uma configuração opcional de segurança em que cada JVM que esteja executando o
arcabouço pode definir um \english{cookie}. O \english{cookie} nada mais é do que uma chave
que o usuário pode definir e que faz parte das informações do cabeçalho das mensagens.
Quando a verificação de segurança está ativada, o recebedor da mensagem verifica se a informação
do \english{cookie} presente na mensagem confere com a informação esperada. Essa verificação
ocorre entre os passos $6$ e $7$ da figura \ref{fig:remote-actor-message-flow}. Caso
os valores sejam iguais, o passo $7$ será executado. Caso contrário, uma exceção de segurança 
será lançada na JVM onde a mensagem foi recebida e o passo $7$ não será executado.

O Netty oferece algumas opções específicas para o transporte de mensagens baseadas
em \english{socket}s TCP. Exemplos dessas opções são a definição do tamanho máximo da
janela utilizada para o envio das mensagens a atores remotos, o tempo limite de espera 
para leitura na \english{socket}, o intervalo de espera para tentativa de reconexão e
o intervalo máximo em que o cliente deve tentar se conectar. Além dessas opções, o
Netty fornece ainda a possibilidade de compactação das mensagens durante o envio. O Akka
faz uso de todas as opções listadas, permitindo que os usuários da biblioteca definam
os valores desejados. As configurações de todos os módulos do Akka são feitas no 
arquivo \code{akka.conf}. 

O arquivo \code{akka.conf} é o ponto de entrada para todas as configurações
que são parametrizáveis de todos os módulos do projeto Akka. O formato do arquivo difere
dos arquivos para configurações de propriedades baseados em chaves e valores. O projeto
Akka utiliza uma biblioteca chamada Configgy \cite{configgy} que define um formato
mais idiomático para arquivos de configurações. Existe uma seção
específica para as configurações correspondentes aos atores remotos. Na distribuição
padrão, boa parte das propriedades para configuração de atores remotos são relacionadas ao
Netty. Por exemplo, o tipo nível de compressão, tamanho da janela da mensagem e
tempo limite de espera pelo cliente para se conectar. Contudo, existem algumas propriedades
que são mais gerais, como se a comunicação deve ser autenticada via \english{cookies}
pré-definidos, qual o \english{cookie} de segurança que deve ser utilizado e ainda qual a classe que deve
ser utilizada como implementação da camada de suporte para atores remotos.

Os dados informados no arquivo \code{akka.conf}, uma vez que foram lidos ficam acessíveis
em objetos de acordo com o contexto que fazem parte. As propriedades relacionadas
aos atores remotos estão organizadas em objetos dentro do módulo \code{RemoteShared}.
Existe ainda uma classe auxiliar que é utilizada para acessar os módulos dos subprojetos
do Akka via reflexão chamada de \code{ReflectiveAccess}. 
A camada de implementação para o transporte de mensagens entre atores remotos é instanciada nessa
classe. A listagem \ref{lst:akka-conf-vanilla} mostra a seção referente às configurações do módulo de atores remotos.


\begin{lstlisting}[frame=tb, caption={Seção remote do arquivo akka.conf.}, label={lst:akka-conf-vanilla}]
...
remote {
    secure-cookie = "050E0A0D0D0601AA00B0090B..." 
    compression-scheme = "zlib"
    zlib-compression-level = 6
    layer = "akka.remote.netty.NettyRemoteSupport"

    server {
      hostname = "localhost"
      port = 2552           
      message-frame-size = 1048576 
      connection-timeout = 1
      require-cookie = on
      untrusted-mode = off
    }

    client {
      reconnect-delay = 5
      read-timeout = 10
      message-frame-size = 1048576
      reconnection-time-window = 600
    }
}
\end{lstlisting}

\subsection{Protocolo para envios de mensagens a atores remotos}
\index{Akka!atores remotos!protocolo}
\label{sec:atores_remotos_akka_protocolo}

O protocolo utilizado para envios de mensagens entre atores remotos é definido no Akka com o
uso da biblioteca Protobuf. Protobuf \cite{protobuf} é uma biblioteca que permite que dados 
estruturados sejam representados em um formato eficiente e extensível. A biblioteca possui um compilador que 
converte a definição de protocolos em classes Java, Python e C++, permitindo uma interação 
direta com o protocolo nas linguagens, eliminando a necessidade de bibliotecas adicionais 
para conversões. A biblioteca permite que protocolos sejam definidos com a palavra-chave 
\code{message}. Protocolos podem conter outros protocolos e tipos primitivos 
de dados, como por exemplo números, textos, valores booleanos e vetores de dados. Ademais, pode-se
definir a obrigatoriedade dos valores para alguns atributos com as palavras-chaves
\code{optional} e \code{required}.

O protocolo das mensagens é mostrado na listagem \ref{lst:proto-message}. Uma mensagem
é definida pelo tipo de seriação (linha $1$) que foi utilizado na codificação dos dados da mensagem 
(listagem \ref{lst:proto-enum-serial}), pelos bytes da mensagem (linha $2$) 
e por um atributo que é utilizado para informar o nome da classe da mensagem. 
As mensagens para atores remotos são definidas com 
base no tipo de seriação que foi definido na JVM onde se originou o envio. Para que a JVM 
que esteja recebendo a mensagem possa fazer o processamento correto, a informação do tipo de 
seriação deve estar presente. O atributo de manifesto da mensagem (linha $3$) é opcional, 
porém é utilizado para forçar o carregamento da classe no \english{class loader}
onde a mensagem será desseriada. 

\begin{lstlisting}[frame=tb, caption={Protocolo para mensagens.}, label={lst:proto-message}]
message MessageProtocol {
  required SerializationSchemeType serializationScheme = 1;
  required bytes message = 2;
  optional bytes messageManifest = 3;
}
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Enumeração com tipos de seriação suportados.}, label={lst:proto-enum-serial}]
enum SerializationSchemeType {
  JAVA = 1;
  SBINARY = 2;
  SCALA_JSON = 3;
  JAVA_JSON = 4;
  PROTOBUF = 5;
}
\end{lstlisting}  

Pelo fato da referência remota de um ator que faz um envio de mensagem ser enviada
junto à mensagem, foi definido um protocolo para as \code{RemoteActorRef}s.
Esse protocolo, mostrado na listagem \ref{lst:proto-remote-actor},  define
o nome que é utilizado para identificar o ator (linha $1$), a classe que foi utilizada para
a criação do ator (linha $2$), o endereço de onde o ator remoto foi criado (linha $3$) e, por
fim, um valor opcional que indica o tempo máximo que o ator deve ficar bloqueado 
durante um envio síncrono (linha $4$). O protocolo \code{AddressProtocol} utilizado na linha $3$,
possui atributos para o endereço do hospedeiro e a porta.

\begin{lstlisting}[frame=tb, caption={Protocolo para referências de atores remotos.}, label={lst:proto-remote-actor}]
message RemoteActorRefProtocol {
  required string classOrServiceName = 1;
  required string actorClassname = 2;
  required AddressProtocol homeAddress = 3;
  optional uint64 timeout = 4;
}
\end{lstlisting}

Por fim, é apresentado na listagem \ref{lst:proto-remote-message}, o protocolo utilizado para as 
mensagens remotas. Esse protocolo é composto pelo protocolo para mensagens 
(linha $4$) e pelo protocolo para referências remotas (linha $7$), além de outros protocolos menores.
Na linha $1$, o atributo \code{uuid} é um identificador único para as mensagens.
A implementação do protocolo \code{UuidProtocol} utiliza a biblioteca UUID \cite{uuid}
que é uma implementação de identificadores globais únicos. Podemos notar na linha $4$ um 
atributo booleano que é utilizado para indicar se é esperado uma mensagem de resposta para a
mensagem que está sendo processada. Envios feitos via método \code{!} possuem valor
\code{oneWay = true}, enquanto que os demais envios não.

\begin{lstlisting}[frame=tb, caption={Protocolo para envios de mensagens remotas.}, label={lst:proto-remote-message}]
message RemoteMessageProtocol {
  required UuidProtocol uuid = 1;
  required ActorInfoProtocol actorInfo = 2;
  required bool oneWay = 3;
  optional MessageProtocol message = 4;
  optional ExceptionProtocol exception = 5;
  optional UuidProtocol supervisorUuid = 6;
  optional RemoteActorRefProtocol sender = 7;
  repeated MetadataEntryProtocol metadata = 8;
  optional string cookie = 9;
}
\end{lstlisting}

Optamos por não detalhar os demais protocolos utilizados para compor o protocolo para
mensagens remotas pois, apesar de serem importantes para o suporte a atores remotos, 
eles não possuem grande relevância para o desenvolvimento deste trabalho.

\subsection{Seriação de mensagens e de referências remotas}
\index{Akka!atores remotos!seriação}
\label{sec:atores_remotos_akka_seriacao}

Os diferentes tipos de seriação suportados pelo projeto Akka são utilizados na seriação
da mensagem (listagem \ref{lst:proto-message}) e opcionalmente na seriação da referência
remota (listagem \ref{lst:proto-remote-actor}). O módulo \code{Serializable} define 
um conjunto de feições que podem ser utilizadas para trocar a seriação Java 
padrão por algum dos outros formatos suportados.

O módulo \code{Serializer} define um objeto chamado de \code{MessageSerializer}
que é o responsável para seriação e desseriação das mensagens. A seriação das mensagens
acontece com base no tipo da mensagem. Por exemplo, se a instância utilizada como
argumento para os métodos de envio de mensagens combinar a feição
\code{ScalaJSON}, o conteúdo binário da mensagem estará no formato JSON.

A seriação de \code{RemoteActorRef}s é suportada por padrão e é utilizada
no envio implícito do ator remetente (quando existe um ator remetente) junto
à mensagem. Contudo, a seriação do estado ou mesmo da definição do ator 
(chamada de \english{deep serialization}) deve, quando necessária, ser implementada pelo
usuário da biblioteca. A seriação completa do ator é útil
quando desejamos realocar o ator em um nó diferente do atual. 
 
