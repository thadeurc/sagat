%% ------------------------------------------------------------------------- %%
\chapter{Atores no projeto Akka}
\label{cap:atores_akka}
Os atores do Akka podem ser locais ou remotos. O termo ``ator local'' é usado
para denotar um ator que pode receber mensagens apenas de atores residentes
na mesma máquina virtual. Por outro lado, um ator remoto pode receber mensagens
de quaisquer outros atores, inclusive daqueles residentes em outras máquinas virtuais.
Em outras palavras, o termo ``ator remoto'' é um sinônimo de ``ator remotamente acessível''.

Nas próximas duas seções examinaremos a implementação de atores do projeto Akka. 
Mostraremos a criação e o uso de atores locais ou remotos, bem como o fluxo de uma 
mensagem (envio, tráfego e processamento da mensagem) tanto no caso local como no remoto.
        
\section{Atores locais}
\index{Akka!Atores locais}

A definição de atores locais acontece por meio de extensões da 
\english{trait} \lstinline$akka.actor.Actor$ provendo uma implementação para o 
método \code{receive} como mostrado na listagem \ref{lst:def-actor}. 
A definição de um ator descreve o comportamento inicial que o
ator terá. A ator propriamente dito (que possui a infraestrutura provida
pelo arcabouço) é uma instância de \lstinline$akka.actor.ActorRef$. \lstinline$ActorRef$s
são imutáveis, seriáveis, identificáveis e possuem um relacionamento único com a 
definição do ator. 

A \english{trait} \lstinline$Actor$ tem em sua declaração uma referência para o
\lstinline$ActorRef$ que é acessível pela referência \lstinline$self$. No caso de
atores locais, \lstinline$self$ referencia uma instância de \lstinline$akka.actor.LocalActorRef$.
Com essa referência, a classe que define o comportamento do ator pode alterar as definições
padrão providas pelo arcabouço e utilizar métodos, por exemplo, para responder ou encaminhar 
mensagens recebidas, acessar as referências para um ator supervisor ou atores que estejam
sobre supervisão.

\begin{lstlisting}[frame=tb, caption={Classe SampleActor.}, label={lst:def-actor}]
class SampleActor(val name: String) extends akka.actor.Actor {
  def this() = this("No name")

  def receive = {
    case "hello" => println("%s received hello".format(name))
    case          _ => println("%s received unknown".format(name))
  }
}
\end{lstlisting}

Atores são criados pelo método \lstinline$actorOf$ do objeto \lstinline$akka.actor.Actor$
como mostrado na listagem \ref{lst:actorOf1}. Nessa listagem a instância do ator é criada
com base no tipo da classe via invocação por reflexão do construtor padrão da classe.
O método \lstinline$actorOf$ é sobrecarregado para permitir que uma função sem 
argumentos e com tipo de retorno \lstinline$Actor$, possa ser utilizada como alternativa ao
construtor padrão na criação do ator, como mostrado na listagem \ref{lst:actorOf2}. 

Nas duas listagens tivemos que chamar explicitamente o método 
\lstinline$start$ para inicializar o ator. Os atores do projeto Akka possuem um conjunto de estados
simples, bem definido e linear. Um ator logo após sua criação está no estado chamado de ``novo'' 
e ainda não pode receber mensagens. Após a chamada do método \lstinline$start$, o ator passa ao 
estado ``iniciado'' e está apto a receber mensagens. Uma vez que o método \lstinline$exit$ é 
invocado, o ator passa ao estado de ``desligado'' e não pode mais executar ação alguma.

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via construtor padrão.}, label={lst:actorOf1}]
  val theActor = Actor.actorOf[SampleActor].start
  theActor ! "hello"
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via função de inicialização.}, label={lst:actorOf2}]
  val function = {
    // outras ações
    new SampleActor("John")
  }
  val theActor = Actor.actorOf(function).start
  theActor ! "hello"
\end{lstlisting}

As mensagens que são enviadas para um ator são colocada sincronamente 
na fila de mensagens do ator, levando tempo $O(1)$. As mensagens enfileiradas são então 
despachadas assincronamente para a função parcial definida no bloco \lstinline$receive$, 
como mostrado na figura \ref{fig:local-actor-message}. 

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics{local-actor-message} 
  	\caption{Envio e despacho de mensagens para atores locais.}
  	\label{fig:local-actor-message}
\end{figure}

\subsubsection{Despachadores}

O despachador de um ator é uma entidade que possui um papel importante. O despachador permite a 
configuração do tipo da fila do ator e a semântica de despachamento das mensagens. As filas 
dos atores podem ser duráveis ou transientes e ter seu tamanho limitado superiormente ou não. O Akka
permite que despachadores específicos sejam definidos, porém possui em sua distribuição os quatro 
despachadores listados a seguir:

\begin{itemize}
	\item Despachador impulsionado por eventos: 
	O despachador é definido na classe \lstinline$akka.dispatch.ExecutorBasedEventDrivenDispatcher$
	e é normalmente compartilhado por diversos atores de diferentes
	tipos, já que ele utiliza um \english{thread pool} para agendar as ações de despachamento.
	É o despachador mais flexível em termos de configurações, já que permite que
	parâmetros do \english{thread pool} e da fila de mensagens sejam configurados;

	%, como quantidade máxima e mínima de \english{threads},
	%sejam configurados, e da fila, como limite de mensagens, durabilidade e políticas para
	%rejeição sejam configurados;

	\item Despachador impulsionado por eventos com balanceamento de processamento:
	O despachador é definido na classe \lstinline$akka.dispatch.ExecutorBasedEventDrivenWorkStealingDispatcher$
	e é semelhante ao despachador anterior, já que também é impulsionado por eventos. 
	Esse despachador deve ser usado em atores do mesmo tipo já que permite que
	atores que não estão processando mensagens possam ``roubar'' mensagens das filas dos atores
	que estão sobrecarregados, permitindo o balanceamento do processamento das mensagens entre
	os atores;
	
	\item Despachador quente: 
	O despachador é definido na classe \lstinline$akka.dispatch.HawtDispatcher$ e é inspirado no 
	\english{Grand Central Dispacher} do Mac OS X \cite{apple-gcd}. Esse despachador 
	define um \english{thread pool} cujo tamanho é ajustado ao automaticamente
	para minimizar a quantidade de \english{threads} concorrentes e inativas
	\footnote{Idealmente a quantidade de \english{threads} corresponde ao número de núcleos disponíveis.}.
	A grande diferença desse despachador é a capacidade de agrupar diversos eventos gerados pela
	aplicação, por exemplo diversas mensagens recebidas, gerando uma única tarefa assíncrona;		
	
	\item Despachador impulsionado por \english{threads}:  
	O despachador é definido na classe \lstinline$akka.dispatch.ThreadBasedDispatcher$ e
	é o mais simples de todos os dispachadores, já que associa uma \english{thread} para 
	cada ator. O uso desse despachador implica no ator
	utilizar filas transientes. É importante ressaltar que internamente é utilizado uma fila
	que faz o bloqueio da \english{thread} que está tentando adicionar um elemento, caso o limite
	superior da fila tenha sido atingido (para o caso onde há um limite informado). 		
\end{itemize}

Por padrão, atores são associados ao despachador global impulsionado por eventos. A 
configuração padrão do despachador define uma fila transiente sem limite máximo de mensagens. 
Caso seja necessário definir um outro despachador para um ator, a definição deve acontecer 
antes de o ator ser inciado via método \lstinline$self.dispatcher$. 

\subsubsection{Envios de respostas}

Envios de mensagens podem gerar mensagens de resposta ao remetente. Os métodos para
envios de mensagens capturam implicitamente uma cópia da referência da entidade que está 
fazendo o envio. A referência é enviada junto com a mensagem para que o ator destinatário 
possa eventualmente enviar uma mensagem de resposta.

O ator destinatário pode responder a uma mensagem via método \lstinline$self.reply$. 
A execução do método de resposta nada mais é que um envio de mensagem como já apresentado.
Envios de mensagens feitos via métodos \lstinline$!!$ e \lstinline$!!!$ são 
considerados como feitos por ``remetentes futuros''. Uma vez que o ator enviou
a mensagem de resposta, a mensagem não é coloca em uma fila de mensagens assim como
acontece para atores, mas é utilizada para indicar no resultado futuro que a computação 
foi completada. 

Envios de mensagens não são limitados somente a atores. Qualquer objeto
ou classe pode enviar uma mensagem a um ator. Podemos notar que o código da listagem 
\ref{lst:actorOf1} não está definido em um ator. O ator que está para enviar a mensagem
de resposta pode verificar se há um remetente definido associado a mensagem recebida, 
porém existe um modo alternativo e mais simples. O método \lstinline$seld.reply_?$ faz o 
envio ao remetente somente no caso em que há um remetente definido, devolvendo o valor 
boleano \english{true} para indicar se houve envio, ou \english{false} caso contrário.
                
\section{Atores remotos}
\index{Akka!Atores remotos}
\label{sec:atores_remotos_akka}

No contexto de um envio de mensagem para um ator remoto, o termo cliente se refere à 
entidade que está enviando a mensagem. O termo servidor denota o processo (máquina virtual) 
no qual reside o ator remoto. Atores remotamente acessíveis possuem as mesmas características
de atores locais no que diz respeito ao recebimento e despachamento de mensagens. Atores
locais e remotos diferem basicamente na criação e no envio de mensagens. A infra-estrutura 
de atores remotos utiliza os seguintes elementos:
	
\begin{itemize}	
	\item \lstinline$RemoteServerModule$: É uma \english{trait} que define as responsabilidades
	do componente usado no lado do servidor. Suas implementações têm como
	responsabilidade manter registrados os atores, bem como encaminhar a eles as mensagens 
	recebidas de clientes remotos. Cada \code{RemoteServerMobule} é associado a um \english{host} 
	e a uma porta TCP. Um mesma máquina virtual pode conter múltiplos \code{RemoteServerModule}s.
	A documentação do Akka utiliza para esse componente a terminologia ``servidor remoto'' 
	(\english{remote server});

	\item \lstinline$RemoteClientModule$: É uma \english{trait} que define as responsabilidades
	do componente usado no lado do cliente. Suas implementações têm como responsabilidade 
	visível oferecer uma interface para obtenção de referências a atores remotos. 
	Oferece também suporte em tempo de execução para a infra-estrutura de atores do lado do 
	cliente, provendo uma série de serviços não vísiveis para o usuário, tais como
	seriação de mensagens, envio de mensagens para atores remotos,
	conversão de ator local em ator remoto e intermediação de 
	mensagens de resposta vindas do \code{RemoteServerModule}, no caso envios via \lstinline$!!$
	ou \lstinline$!!!$. A documentação do Akka utiliza para esse componente a terminologia
	``cliente remoto'' (\english{remote client});

	\item \lstinline$RemoteSupport$: É acessível via \lstinline$Actor.remote$. Essa
	classe abstrata é responsável por concentrar as responsabilidades definidas para os
	módulos remotos do cliente e do servidor e ser um ponto único de suporte remoto;

	\item \lstinline$RemoteActorRef$: É uma classe equivalente a \lstinline$LocalActorRef$, porém
	utiliza o suporte remoto para fazer envio das mensagens.		
	
\end{itemize}

A implementação de atores remotos do Akka, implementa os componentes de suporte remoto com o
auxílio do JBoss Netty. Apresentamos na figura \ref{fig:remote-actor-colaboracao} como os 
componentes se relacionam. Dividimos a figura em duas partes, sendo a camada de interface remota
que é a camada que implementação interage diretamente, e a camada de implementação. A camada
de implementação é associada em tempo de execução, permitindo outras implementações possam ser
criadas e utilizadas.

\vspace{1ex}
\begin{figure}[hbtp]
 	\centering
	\includegraphics[scale=.75]{remote-actor-colaboracao} 
  	\caption{Relacionamento entre os componentes remotos.}
  	\label{fig:remote-actor-colaboracao}
\end{figure}

Na versão $1.0$ do Akka, a definição de atores remotos não possui diferença em
relação a definição de atores locais. Podemos utilizar a classe apresentada na 
listagem \ref{lst:def-actor} para criamos um ator remoto. A criação de atores
remotos pode acontecer tanto no nó onde reside a aplicação servidora, quanto
ser criado remotamente por uma aplicação cliente.

A criação de atores remotos gerenciados pelo servidor (\english{server managed actors})
é mostrada na listagem \ref{lst:remote-server1}. Nessa listagem, um servidor
remoto é inicializado na linha $2$ para que os atores possam ser registrados. Na implementação
padrão feita com o Netty, a inicialização de um servidor remoto implica em associar 
um componente do Netty para monitorar a \english{socket} associada ao par \english{host} e 
porta. Na linha $3$ registramos o ator sob o nome \lstinline$hello-service$. O ator passou a 
estar remotamente acessível por aplicações que residam em outras máquinas virtuais. Um detalhe
importante a destacar é a inicialização implícita do ator feita pelo método \lstinline$register$.
A implementação desse método fica a critério dos componentes da camada de implementação de
suporte remoto, porém sua interface obriga que implementações compatíveis inicializem atores
que ainda não estão em execução.

\begin{lstlisting}[frame=tb, caption={Aplicação SampleRemoteServer.}, label={lst:remote-server1}]
object SampleRemoteServer extends Application {
	Actor.remote.start("localhost", 2552)
	Actor.remote.register("hello-service", actorOf[SampleActor])
}
\end{lstlisting}

Referências para atores remotos podem ser obtidas via método \lstinline$actorFor$. Esse
método possui diversas sobrecargas, porém a mais simples recebe como argumentos o nome do ator, 
o \english{host} e a porta onde foi feito o registro. A linha $2$ da listagem 
\ref{lst:remote-client1} mostra como uma aplicação cliente 
obtém uma referência para o ator. Podemos notar que o uso do ator na linha $3$ não possui 
nenhuma indicação explícita sobre um envio remoto. O método \lstinline$actorFor$ retorna na 
maioria das vezes instâncias de \lstinline$RemoteActorRef$, que representam \english{proxies} 
locais para o ator remoto. A implementação possui algumas otimizações para o caso em que, 
quem busca a referência remota estar no mesmo nó onde o ator reside. Em casos como esse, 
uma instância de \lstinline$LocalActorRef$ é retornada. 

\begin{lstlisting}[frame=tb, caption={Aplicação SampleRemoteClient.}, label={lst:remote-client1}]
object SampleRemoteClient extends Application{
  val helloActor = Actor.remote.actorFor("hello-service", "localhost", 2552)
  helloActor ! "Hello"
}
\end{lstlisting}
		
Aplicações cliente podem optar por criar e iniciar atores em nós que não sejam o corrente.
Esses atores são chamados de atores gerenciados pelo cliente (\english{client managed actors}). 
Para tal, a biblioteca de atores fornece uma versão alternativa do método \lstinline$actorOf$
que recebe parâmetros adicionais para indicar o nó onde o ator criado será executado. Akka
não possui carregamento remoto de classes, obrigando que as classes com as definições
dos atores estejam acessíveis para a máquina virtual onde ele será instanciado e executado.
Uma outra observação importante a ser feita em relação ao servidor remoto que irá executar
o ator sendo criado, é a necessidade de ele estar em execução antes de o método \lstinline$actorOf$
ser invocado. Os detalhes observados são alguns dos exemplos que motivam discussões no projeto
para que esse tipo de suporte seja depreciado e removido em versões futuras, já que os
mesmos resultados podem ser obtidos com o uso de atores gerenciados pelo servidor.

\subsection{Fluxo de envio das mensagens}

%% explicar como funciona o envio. deveria ter uma mensagem mostrando a interação dos componentes?
        
Quando um cliente envia uma mensagem a um ator remoto, o \english{proxy} local 
embrulha a mensagem, adicionando a ela informações de cabeçalho necessárias para 
o envio. O \english{proxy} usa um \code{RemoteClient} para enviar a mensagem ao 
\code{RemoteServer} correspondente. Este processo de envio, do ponto de vista do cliente
leva tempo $O(1)$, já que a seriação da mensagem é feita de modo assíncrono.
        
A figura \ref{fig:remote-actor-message-flow} mostra o caminho que a mensagem faz saindo
da aplicação cliente via \english{proxy} e sendo repassada para um \code{RemoteClient}, 
que por sua vez faz a seriação assíncrona da mensagem e a envia para o \code{RemoteServer} 
correspondente. Uma vez que a mensagem tenha sido recebida pelo \english{handler} plugado 
ao JBoss Netty no lado servidor, o \english{handler} examina as informações de cabeçalho, 
localiza o ator destinatário no registro local de atores e encaminha a mensagem a caixa de 
mensagens do ator, como se o envio fosse local. O despachador associado ao ator faz o 
tratamento mostrado na figura \ref{fig:local-actor-message}, já que do ponto de vista do
despachador não há diferença entre um envio local e um remoto.

\vspace{1ex}
\begin{figure}[hbtp]
 	\centering
	\includegraphics[scale=.9]{remote-actor-message-flow} 
  	\caption{Fluxo de envio de mensagens para atores remotos.}
  	\label{fig:remote-actor-message-flow}
\end{figure}


Em alguns casos, o processamento deve gerar uma mensagem de resposta, como por exemplo
um resultado futuro ou uma mensagem de erro para um ator supervisor. Em tais casos a 
mensagem de resposta faz o caminho contrário, indo do \code{RemoteServer} para
o \code{RemoteClient}, onde analogamente o \english{handler} faz o repasse da resposta
para quem a estiver aguardando.
        