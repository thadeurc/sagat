%% ------------------------------------------------------------------------- %%
\chapter{Atores no projeto Akka}
\index{Akka}
\label{cap:atores_akka}
O projeto Akka disponibiliza tanto atores locais quanto remotos. O termo ``ator local'' é usado
para denotar um ator que pode receber mensagens apenas de atores residentes
na mesma máquina virtual. Por outro lado, um ator remoto pode receber mensagens
de quaisquer outros atores, inclusive daqueles residentes em outras máquinas virtuais.
Em outras palavras, o termo ``ator remoto'' é um sinônimo de ``ator remotamente acessível''.

Na seção \ref{sec:atores_locais} examinaremos a implementação de atores locais. Nosso objetivo
é focar na criação desses atores, no envio e despachamento de mensagens e na hierarquia 
de supervisão. Na seção \ref{sec:atores_remotos_akka} examinaremos a implementação de 
atores remotos. Nosso objetivo é focar na estrutura definida para o suporte a atores remotos,
seriação de mensagens e no protocolo que foi definido para o envio de mensagens para atores
remotos.
        
\section{Atores locais}
\label{sec:atores_locais}
\index{Akka!atores locais}

A definição de atores locais acontece por meio de extensões da 
\english{trait} \lstinline$akka.actor.Actor$, onde deve-se prover uma implementação para o 
método \lstinline$receive$ como mostrado na listagem \ref{lst:def-actor}. 
A definição de um ator descreve o comportamento inicial que o
ator terá. O ator propriamente dito (aquele que possui as funcionalidades providas
pelo arcabouço) é uma instância de \lstinline$akka.actor.ActorRef$. \lstinline$ActorRef$s
são imutáveis, seriáveis, identificáveis, possuem um relacionamento único com a 
definição do ator e armazenam o endereço do nó onde foram criadas. 

A \english{trait} \lstinline$Actor$ possui em sua declaração uma referência para o seu 
\lstinline$ActorRef$ definida como \lstinline$self$. No caso de
atores locais, \lstinline$self$ referencia uma instância de \lstinline$akka.actor.LocalActorRef$.
Com essa referência, a classe que define o comportamento do ator pode alterar as definições
padrão providas pelo arcabouço e utilizar seus métodos para, por exemplo, responder ou encaminhar 
mensagens recebidas e acessar a referência de um ator supervisor.

\begin{lstlisting}[frame=tb, caption={Classe SampleActor.}, label={lst:def-actor}]
class SampleActor(val name: String) extends akka.actor.Actor {
  def this() = this("No name")

  def receive = {
    case "hello" => println("%s received hello".format(name))
    case          _ => println("%s received unknown".format(name))
  }
}
\end{lstlisting}

Atores são criados pelo método \lstinline$actorOf$ do objeto \lstinline$akka.actor.Actor$
como mostrado na listagem \ref{lst:actorOf1}. Nessa listagem, a instância do ator é criada
por reflexão com base no tipo da classe onde o construtor padrão é executado.
O método \lstinline$actorOf$ é sobrecarregado para permitir que uma função sem 
argumentos e com tipo de retorno \lstinline$Actor$, possa ser utilizada como alternativa ao
construtor padrão na criação do ator, como mostrado na listagem \ref{lst:actorOf2}. 

Nas duas listagens tivemos que chamar explicitamente o método 
\lstinline$start$ para iniciar o ator. Os atores do projeto Akka possuem um conjunto de estados
simples, bem definido e linear. Um ator logo após sua criação está no estado chamado de ``novo'' 
e ainda não pode receber mensagens. Após a invocação do método \lstinline$start$, o ator passa ao 
estado ``iniciado'' e está apto a receber mensagens. Uma vez que o método \lstinline$exit$ ou 
\lstinline$stop$\footnote{O método \lstinline$exit$ invoca internamente o método 
\lstinline$stop$ que é responsável por desligar o ator.} é invocado, o ator passa 
ao estado de ``desligado'' e não pode mais executar ação alguma.

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via construtor padrão.}, label={lst:actorOf1}]
  val theActor = Actor.actorOf[SampleActor].start
  theActor ! "hello"
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Criação e inicialização de SampleActor via função de inicialização.}, label={lst:actorOf2}]
  val function = {
    // outras ações
    new SampleActor("John")
  }
  val theActor = Actor.actorOf(function).start
  theActor ! "hello"
\end{lstlisting}

As mensagens que são enviadas para um ator são colocada sincronamente 
na fila de mensagens do ator, levando tempo $O(1)$. As mensagens enfileiradas são então 
despachadas assincronamente para a função parcial definida no bloco \lstinline$receive$, 
como mostrado na figura \ref{fig:local-actor-message}. 

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics{local-actor-message} 
  	\caption{Envio e despacho de mensagens para atores locais.}
  	\label{fig:local-actor-message}
\end{figure}

\subsection{Despachadores}
\index{Akka!atores locais!despachadores}
O despachador de um ator é uma entidade que possui um papel importante. O despachador permite a 
configuração do tipo da fila do ator e a semântica do despachamento das mensagens. A fila
de um ator pode ser durável ou transiente e ter seu tamanho limitado superiormente ou não. O Akka
possui em sua distribuição os quatro despachadores listados a seguir:

\begin{itemize}
	\item Despachador impulsionado por eventos: 
	O despachador é definido na classe \lstinline$akka.dispatch.ExecutorBasedEventDrivenDispatcher$
	e é normalmente compartilhado por diversos atores de diferentes
	tipos, já que ele utiliza um \english{thread pool} para agendar as ações de despachamento.
	É o despachador mais flexível em termos de configurações, já que permite que
	parâmetros do \english{thread pool} e da fila de mensagens sejam configurados;

	\item Despachador impulsionado por eventos com balanceamento de carga:
	O despachador é definido na classe \lstinline$akka.dispatch.ExecutorBasedEventDrivenWorkStealingDispatcher$
	e é semelhante ao despachador anterior, já que também é impulsionado por eventos. 
	Esse despachador deve ser usado em atores do mesmo tipo já que permite que
	atores que não estejam processando mensagens possam ``roubar'' mensagens das filas dos atores
	que estão sobrecarregados, permitindo o balanceamento do processamento das mensagens entre
	os atores;
	
	\item Despachador quente: 
	O despachador é definido na classe \lstinline$akka.dispatch.HawtDispatcher$ e é inspirado no 
	\english{Grand Central Dispacher} do Mac OS X \cite{apple-gcd}. Esse despachador 
	define um \english{thread pool} cujo tamanho é ajustado automaticamente
	para minimizar a quantidade de \english{threads} concorrentes e 
	inativas\footnote{Idealmente a quantidade de \english{threads} corresponde ao número de núcleos disponíveis.}.
	A grande diferença desse despachador é a capacidade de agrupar diversos eventos gerados pela
	aplicação, por exemplo diversas mensagens recebidas, gerando uma única tarefa assíncrona;		
	
	\item Despachador impulsionado por \english{threads}:  
	O despachador é definido na classe \lstinline$akka.dispatch.ThreadBasedDispatcher$ e
	é o mais simples de todos os dispachadores, já que associa uma \english{thread} para 
	cada ator. O uso desse despachador implica no ator
	utilizar filas transientes. É importante ressaltar que internamente é utilizado uma fila
	que faz o bloqueio da \english{thread} que está tentando adicionar um elemento, caso o limite
	superior da fila tenha sido atingido (para o caso onde há um limite informado). 		
\end{itemize}

Por padrão atores são associados ao despachador global impulsionado por eventos. A 
configuração padrão do despachador define uma fila transiente sem limite máximo de mensagens. 
Caso seja necessário definir um outro despachador para um ator, a definição deve acontecer 
antes de o ator ser inciado via método \lstinline$self.dispatcher$. O Akka permite ainda
que novos dispachadores sejam criados.

\subsection{Envios de respostas}
\index{Akka!atores locais!envios de respostas}

Envios de mensagens podem gerar mensagens de resposta ao remetente. Os métodos para
envios de mensagens capturam implicitamente uma cópia da referência da entidade que está 
fazendo o envio (\english{sender}). A assinatura do método \lstinline$!!$ é mostrada na 
listagem \ref{lst:method!!}. Uma cópia da referência do \english{sender} é enviada junto 
com a mensagem para que o ator destinatário possa eventualmente enviar uma mensagem de resposta. 

\begin{lstlisting}[frame=tb, caption={Assinatura do método !!.}, label={lst:method!!}]
def !!(message: Any, timeout: Long = this.timeout)
	(implicit sender: Option[ActorRef] = None): Option[Any] = {
	...
}
\end{lstlisting}

O ator destinatário pode responder a uma mensagem via método \lstinline$self.reply$. 
A execução do método para envio de uma resposta nada mais é que um envio de mensagem como 
já apresentado. 

A implementação dos métodos \lstinline$!!$ e \lstinline$!!!$ é baseada em resultados futuros.
Resultados futuros são representações de resultados de computações assíncronas. Em Java,
a classe \lstinline$java.util.concurrent.FutureTask$ provê uma implementação básica 
de resultados futuros. A implementação feita no projeto Akka tem sua própria implementação
para representar resultados futuros de computações assíncronas. Essa implementação provê
algumas facilidades em relação a implementação de Java que são necessárias em seu uso
pelo arcabouço. A \english{trait} \lstinline$CompletableFuture$ define métodos
para que resultados futuros possam ser completados por outras entidades como mostrado na listagem
\ref{lst:completable}. Essa implementação foi inspirada no projeto Actorom \cite{actorom}.
A implementação do Akka é construída sobre classes do pacote \lstinline$java.util.concurrent$.

\begin{lstlisting}[frame=tb, caption={Trait CompletableFuture.}, label={lst:completable}]
trait CompletableFuture[T] extends Future[T] {
  def completeWithResult(result: T)
  def completeWithException(exception: Throwable)
  def completeWith(other: Future[T])
}
\end{lstlisting}

Envios de mensagens feitos via métodos \lstinline$!!$ e \lstinline$!!!$ são 
considerados como feitos por ``remetentes futuros''. Uma vez que o ator enviou
a mensagem de resposta, a mensagem não é coloca em uma fila de mensagens assim como
acontece para atores, mas é utilizada para indicar no resultado futuro que a computação 
foi completada. 

Na \lstinline$ActorRef$, um envio de uma mensagem feito via método \lstinline$!!!$ é processado 
da seguinte maneira:

\begin{enumerate}
	\item Uma instância de \lstinline$CompletableFuture$ é criada dentro do método;
	
	\item A mensagem é colocada da fila do ator como se tivesse sido um envio feito via método
	\lstinline$!$, porém é colocado junto a mensagem uma cópia da referência para o
	\lstinline$CompletableFuture$ criado no passo anterior;
	
	\item É retornado para quem invocou o método uma outra cópia da referência para o 
	\lstinline$CompletableFuture$ criado no passo $1$;
	
	\item Quando a mensagem terminou de ser processada, seu resultado é atualizado
	na referência que foi enviado junto à mensagem. Como a instância que foi teve
	o resultado ``completado'' (seja com um valor ou com uma exceção) é a mesma
	que é referenciada por quem fez a invocação do método, o resultado pode então
	ser utilizado.
\end{enumerate}

Um envio feito via método \lstinline$!!$ possui quase os mesmos passos de processamento.
A diferença está no retorno da referência. Como o envio é síncrono, a espera do resultado
da computação assíncrona acontece de modo bloqueante dentro do próprio método \lstinline$!!$.
Quando a computação for completada, o resultado é retornado a quem fez a invocação do método.

Envios de mensagens não são limitados somente a atores. Qualquer objeto
ou classe pode enviar uma mensagem a um ator. Podemos notar que o código da listagem 
\ref{lst:actorOf1} não está definido em um ator. O ator que está para enviar a mensagem
de resposta pode verificar se há um remetente definido associado a mensagem recebida, 
porém existe um modo alternativo e mais simples: o método \lstinline$self.reply_?$ faz o 
envio ao remetente somente no caso em que há um remetente definido, devolvendo o valor 
boleano \lstinline$true$ para indicar se houve envio ou \lstinline$false$ caso contrário.

\subsection{Hierarquias de supervisão}
\index{Akka!atores locais!supervisão}

A biblioteca de atores do Akka permite que o tratamento de erros possa ser feito por
atores definidos como supervisores. Sua implementação é totalmente baseada na abordagem feita na
linguagem Erlang \cite{PROG_ERLANG07} e é conhecida como ``deixe que falhe'' (\english{let it crash}). 

Uma hierarquia de supervisão é criada com o uso de ligações entre atores. A ligação
de dois atores pode acontecer via métodos \lstinline$link$, \lstinline$startLink$ e
\lstinline$spawnLink$, definidos em \lstinline$ActorRef$. O método \lstinline$link$ 
faz a ligação de dois atores $A1$ e $A2$. O método \lstinline$startLink$ também faz a ligação
de dois atores $A1$ e $A2$, porém coloca o ator $A2$ em execução.
O método \lstinline$spawnLink$ faz a criação do ator $A2$, sua ligação com $A1$ e ainda
coloca $A2$ execução. 

É necessário definir no ator que estará sob supervisão, qual ciclo de vida que esse ator 
deverá ter. O ciclo de vida de um ator indica ao ator supervisor como proceder no caso de erros. 
Existem dois tipos de ciclo de vida:

\begin{enumerate}
	\item Permantente: O ciclo de vida é definido na classe 
	\lstinline$akka.config.Supervision.Permanent$. Indica que o ator possui um ciclo de 
	vida permante e sempre deve ser reiniciado no caso de erros;
	
	\item Temporário: O ciclo de vida é definido na classe 
	\lstinline$akka.config.Supervision.Temporary$.
	Indica que o ator possui um ciclo de vida temporário e
	não deve ser reiniciado no caso de erros. Contudo, esse ciclo de vida
	indica que o ator deve ser desligado pelo processo regular, ou seja, como
	se o método \lstinline$exit$ tivesse sido invocado. O processo regular
	ainda faz uma invocação ao método \lstinline$postStop$.	
\end{enumerate}

A definição de um ator com ciclo de vida permanente é mostrada na listagem
\ref{lst:supervised-actor}. A definição do ciclo de vida do ator acontece na linha $2$.

O processo de reinicialização de um ator consiste na criação de uma nova instância da
classe que define o ator. Os métodos \lstinline$preRestart$ e \lstinline$postRestart$ são 
invocados, respectivamente, antes de o ator ser desligado e logo após ele ter sido reiniciado.
Alguns detalhes importantes a observarmos sobre a reinicialização de atores:

\begin{itemize}
	\item O método \lstinline$preRestart$ é invocado na instância onde ocorreu o erro;

	\item O método \lstinline$postRestart$ é invocado na nova instância;

	\item A nova instância criada utiliza a mesma \lstinline$ActorRef$ do ator onde ocorreu o erro,
	logo, ambos os atores possuem o mesmo valor para \lstinline$self$;

	\item  A criação da nova instância é feita da mesma maneira que o ator foi criado 
	originalmente. Por exemplo, na listagem \ref{lst:actorOf1} o ator foi originalmente
	criado via construtor padrão. Já na listagem \ref{lst:actorOf2}, o ator foi originalmente
	criado com o uso de uma função específica.
\end{itemize}

No ator supervisor, por sua vez, deverá ser definida a estratégia de reinicialização para
os atores que ficarão ligados a ele. Existem duas estratégias possíveis:

\begin{enumerate}
	\item Um por um: É definida na classe 
	\lstinline$akka.config.Supervision.OneForOneStrategy$. Quando essa estratégia é utilizada,
	exceções que sejam lançadas em um ator sob supervisão que possua um ciclo de vida permanente.
	Faz com que somente o ator seja reiniciado;
	
	\item Todos por um: É definida na classe 
	\lstinline$akka.config.Supervision.AllForOneStrategy$. 
	Quando essa estratégia é utilizada, exceções que sejam lançadas em um ator sob supervisão, 
	fazem com que todos os atores sob o mesmo supervisor sejam reiniciados. 	
\end{enumerate}

\begin{lstlisting}[frame=tb, caption={Ator com ciclo de vida permanente.}, label={lst:supervised-actor}]
class MySupervised extends akka.actor.Actor{
  self.lifeCycle = akka.config.Supervision.Permanent

  override def postRestart(reason: Throwable): Unit = {
    // restaura o estado
  }

  override def preRestart(reason: Throwable): Unit = {
    // salva o estado corrente
  }

  def receive = {
    case msg => println("message received: %s".format(msg))
  }
}
\end{lstlisting}


Junto com a estratégida de reinicialização, é necessário definir quais são as exceções que o ator
é responsável por fazer o tratamento, além de configurações relacionadas a quantas tentativas de
reinicialização devem ser feitas dentro de um período de tempo. Mostramos na listagem 
\ref{lst:supervisor-actor} a definição de um ator supervisor. Na linha $2$ dessa listagem
definimos a estratégia um por um, supervisionando exceções do tipo \lstinline$java.lang.Exception$, 
com duas tentativas de reinicialização em um período de cinco segundos. Caso o limite de tentativas
de reinicialização tenha sido atingido, porém sem sucesso na reinicialização do ator supervisionado,
uma mensagem específica é enviada para o ator supervisor. Essa mensagem pode estar definida
no método \lstinline$receive$ para que as ações necessárias sejam tomadas.

\begin{lstlisting}[frame=tb, caption={Ator supervisor.}, label={lst:supervisor-actor}]
class MySupervisor extends akka.actor.Actor {
  self.faultHandler = akka.config.Supervision.OneForOneStrategy(List(classOf[Exception]), 2, 5000)

  def receive = {
    case _ => // ignora todas as mensagens
  }
}
\end{lstlisting}

Apresentamos na listagem \ref{lst:supervisor-hier} a criação de uma hierarquia de 
supervisão entre os atores apresentados nas listagens \ref{lst:supervised-actor} 
e \ref{lst:supervisor-actor}.

\begin{lstlisting}[frame=tb, caption={Criação da hierarquia de supervisão.}, label={lst:supervisor-hier}]
object SampleSupervisorHierarchy extends Application {
  val actorSupervisor = Actor.actorOf[MySupervisor].start
  val supervised = Actor.actorOf[MySupervised]
  actorSupervisor.startLink(supervised)
}
\end{lstlisting}

Atores supervisores e supervisionados podem trocar mensagens. Quando criamos uma ligação
de supervisão entre dois atores, como na linha $4$ da listagem \ref{lst:supervisor-hier},
a referência para o ator supervisor passa a estar definida no ator \lstinline$supervised$.
Essa referência é acessível via método \lstinline$self.supervisor$. Um ator supervisor
também pode ser supervisionado por outro ator, como mostrado na figura 
\ref{fig:actor-hier}. O encadeamento de atores supervisores abre a possibilidade da
criação de sub-hieraquias, cada uma com seu supervisor. 

\vspace{1ex}
\begin{figure}[hbtp]
 		\centering
	\includegraphics[scale=.5]{actor-hier} 
  	\caption{Hierarquia de supervisão de atores.}
  	\label{fig:actor-hier}
\end{figure}

\section{Atores remotos}
\index{Akka!atores remotos}
\label{sec:atores_remotos_akka}

No contexto de envios de mensagens para atores remotos, o termo cliente se refere à 
entidade que está enviando a mensagem. O termo servidor denota o processo (máquina virtual) 
no qual reside o ator remoto. Atores remotamente acessíveis possuem as mesmas características
de atores locais no que diz respeito ao recebimento e despachamento de mensagens. Atores
locais e remotos diferem basicamente na sua criação e no envio de mensagens. A infra-estrutura 
de atores remotos utiliza os seguintes elementos:
	
\begin{itemize}	
	\item \lstinline$RemoteServerModule$: É uma \english{trait} que define as responsabilidades
	do componente usado no lado do servidor. Suas implementações têm como
	responsabilidade manter registrados os atores, bem como encaminhar a eles as mensagens 
	recebidas de clientes remotos. Cada \lstinline$RemoteServerModule$ é associado a um endereço
	de hospedeiro (\english{host}) e a uma porta TCP. Um mesma máquina virtual pode conter 
	múltiplos \lstinline$RemoteServerModule$s.
	A documentação do Akka utiliza para esse componente a terminologia ``servidor remoto'' 
	(\english{remote server});

	\item \lstinline$RemoteClientModule$: É uma \english{trait} que define as responsabilidades
	do componente usado no lado do cliente. Suas implementações têm como responsabilidade 
	visível oferecer uma interface para obtenção de referências a atores remotos. 
	Oferece também suporte em tempo de execução para a infra-estrutura de atores do lado do 
	cliente, provendo uma série de serviços não vísiveis para o usuário, tais como
	seriação de mensagens, envio de mensagens para atores remotos,
	conversão de ator local em ator remoto e intermediação de 
	mensagens de resposta vindas do \lstinline$RemoteServerModule$, no caso envios via \lstinline$!!$
	ou \lstinline$!!!$. A documentação do Akka utiliza para esse componente a terminologia
	``cliente remoto'' (\english{remote client});

	\item \lstinline$RemoteSupport$: É acessível via \lstinline$Actor.remote$. Essa
	classe abstrata é responsável por concentrar as responsabilidades definidas para os
	módulos remotos do cliente e do servidor e ser um ponto único de suporte remoto;

	\item \lstinline$RemoteActorRef$: É uma classe equivalente a \lstinline$LocalActorRef$, porém
	utiliza o suporte remoto para fazer envio das mensagens.
\end{itemize}

A implementação de atores remotos do Akka, implementa os componentes de suporte remoto com o
auxílio do JBoss Netty. Apresentamos na figura \ref{fig:remote-actor-colaboracao} como os 
componentes se relacionam. Dividimos a figura em duas partes, sendo a camada de interface remota
que é a camada que se interage diretamente, e a camada de implementação. A camada
de implementação é associada em tempo de execução, permitindo que outras implementações 
criadas possam ser utilizadas.

Na versão $1.0$ do Akka, a definição de atores remotos não possui diferença em
relação a definição de atores locais. Podemos utilizar a classe apresentada na 
listagem \ref{lst:def-actor} para criamos instâncias de atores remotos. A criação de atores
remotos pode acontecer tanto no nó onde reside a aplicação servidora, quanto
ser criado remotamente por uma aplicação cliente.

A criação de atores remotos gerenciados pelo servidor (\english{server managed actors})
é mostrada na listagem \ref{lst:remote-server1}. Nessa listagem, um servidor
remoto é inicializado na linha $2$ para que os atores possam ser registrados. Na implementação
padrão feita com o Netty, a inicialização de um servidor remoto implica na associação
de um componente do Netty para monitorar a \english{socket} associada ao par \english{host} e 
porta. Na linha $3$ registramos o ator sob o nome \lstinline$hello-service$. O ator passou a 
estar remotamente acessível a aplicações que residam em outras máquinas virtuais. Um detalhe
importante a ser destacado é a inicialização implícita do ator feita pelo método \lstinline$register$.
A implementação desse método fica a critério dos componentes da camada de implementação de
suporte remoto, porém sua interface obriga que implementações compatíveis inicializem atores
que ainda não estão em execução.

\vspace{1ex}
\begin{figure}[!h]
 	\centering
	\includegraphics[scale=.75]{remote-actor-colaboracao} 
  	\caption{Relacionamento entre os componentes remotos.}
  	\label{fig:remote-actor-colaboracao}
\end{figure}

Referências para atores remotos podem ser obtidas via método \lstinline$actorFor$. Esse
método possui diversas sobrecargas, sendo que a mais simples recebe como argumentos o nome do ator, 
o \english{host} e a porta onde foi feito o registro. A linha $2$ da listagem 
\ref{lst:remote-client1} mostra como uma aplicação cliente 
obtém uma referência para o ator. Podemos notar que o uso do ator na linha $3$ não possui 
nenhuma indicação explícita sobre um envio remoto. O método \lstinline$actorFor$ retorna na 
maioria das vezes instâncias de \lstinline$RemoteActorRef$, que representam \english{proxies} 
locais para o ator remoto. A implementação possui algumas otimizações para que referências
locais sejam utilizadas sempre que possível. Por exemplo, a entidade que está enviando a mensagem reside no 
mesmo nó que o ator. Em casos como esse, uma instância de \lstinline$LocalActorRef$ é retornada. 

\begin{lstlisting}[frame=tb, caption={Aplicação SampleRemoteServer.}, label={lst:remote-server1}]
object SampleRemoteServer extends Application {
	Actor.remote.start("localhost", 2552)
	Actor.remote.register("hello-service", Actor.actorOf[SampleActor])
}
\end{lstlisting}


\begin{lstlisting}[frame=tb, caption={Aplicação SampleRemoteClient.}, label={lst:remote-client1}]
object SampleRemoteClient extends Application{
  val helloActor = Actor.remote.actorFor("hello-service", "localhost", 2552)
  helloActor ! "Hello"
}
\end{lstlisting}
		
Aplicações cliente podem optar por criar e iniciar atores em nós que não sejam o corrente.
Esses atores são chamados de atores gerenciados pelo cliente (\english{client managed actors}). 
Para tal, a biblioteca de atores fornece uma versão alternativa do método \lstinline$actorOf$
que recebe parâmetros adicionais para indicar o nó onde o ator criado será executado. O Akka
não possui carregamento remoto de classes, obrigando que as classes com as definições
dos atores estejam acessíveis para a máquina virtual onde ele será instanciado e executado.
Uma outra observação importante a ser feita em relação ao servidor remoto que irá executar
o ator sendo criado, é a necessidade de ele estar em execução antes de o método \lstinline$actorOf$
ser invocado. Os detalhes observados são alguns dos exemplos que motivam discussões entre
a comunidade de desenvolvedores do Akka para que esse tipo de suporte seja depreciado e 
removido em versões futuras, já que os mesmos resultados podem ser obtidos com o uso de 
atores gerenciados pelo servidor.

\subsection{Fluxo de envio das mensagens}
\index{Akka!atores remotos!fluxo de envio}
\label{sec:atores_remotos_akka_fluxo}

O envio assícrono de uma mensagem a um ator remoto tem alguns passos adicionais em relação
a um envio local de mensagens. O processo de um envio assíncrono de uma mensagem
para um ator remoto é ilustrado na figura \ref{fig:remote-actor-message-flow} e acontece
em sete passos:

\begin{enumerate}
	\item O processo começa com o \english{proxy} local 
	embrulhando a mensagem e adicionando a ela informações de cabeçalho necessárias para 
	o envio e processamento posterior. A mensagem embrulhada e com as informações de cabeçalho
	é entao repassada ao seriador;
	
	\item O seriador é responsável por converter a informação 
	recebida em um vetor de \english{bytes} para que o transporte possa ocorrer. 
	Uma vez que a informação esteja no formato a ser transportado, o \english{proxy} usa uma 
	implementação de \lstinline$RemoteSupport$ (que na figura \ref{fig:remote-actor-message-flow} é 
	uma instância de \lstinline$NettyRemoteSupport$) para enviar a mensagem 
	ao \lstinline$RemoteSupport$ que está no lado do servidor;
	
	\item A classe \lstinline$ClientBootstrap$ transporta a mensagem para o 
	\lstinline$ServerBootstrap$ que está conectado. O processo de envio, do ponto de vista 
	do cliente leva tempo $O(1)$, já que o transporte da mensagem pelo JBoss Netty 
	entre o \lstinline$ClientBootstrap$ e o \lstinline$ServerBootstrap$	
	é feito de modo assíncrono;
	
	\item A classe \lstinline$ServerBootstrap$ repassa a mensagem ao \english{handler} que
	está associado a ele;
	
	\item A implementação do \english{handler} feita no Akka repassa a mensagem para o seriador
	para que a deseriação seja feita;
	
	\item O seriador desseria a mensagem para o formato que ela estava antes de ser seriada para
	ser enviada. Em seguida, o seriador repassa novamente a mensagem para o \english{handler};
	
	\item Por fim, a implementação do \english{handler} utiliza as informações definidas
	de cabeçalho da mensagem para identificar qual o ator destinatário no registro
	local de atores e como deve ser feito o envio. No caso do envio assíncrono, o ator 
	destinatário tem seu método \lstinline$!$ invocado com a mensagem e eventualmente a 
	referência do ator que fez o envio (ou \lstinline$None$ caso contrário).
	O despachador associado ao ator tem o mesmo comportamento já mostrado na 
	figura \ref{fig:local-actor-message}.
\end{enumerate}

\vspace{1ex}
\begin{figure}[!h]
 	\centering
	\includegraphics[scale=.9]{remote-actor-message-flow} 
  	\caption{Fluxo de envio de mensagens para atores remotos.}
  	\label{fig:remote-actor-message-flow}
\end{figure}
        
Os envios feitos via métodos \lstinline$!!$ e \lstinline$!!!$ para atores remotos são iguais,
e possuem um passo a mais do que os mostrados na figura \ref{fig:remote-actor-message-flow}.
O passo adicional acontece entre os passos $2$ e $3$. Antes de a mensagem ser enviada
uma cópia da referência para instância de resultado futuro que é retornada é colocada 
no mapa de resultados futuros. A chave para a instância é o identificador da mensagem.

Envios feitos via métodos \lstinline$!!$ e \lstinline$!!!$, assim como mensagens para atores
supervisores que estão remotos, geram envios de mensagens no caminho contrário ao mostrado
na figura \ref{fig:remote-actor-message-flow}. Caso a mensagem que foi enviada pelo servidor
seja o resultado de um envio com \lstinline$!!$ ou \lstinline$!!!$, o conteúdo da mensagem
(seja um resultado de sucesso ou uma exceção) é utilizado para completar a instância cujo a
referência havia sido colocada no mapa de resultados futuros.

No caso de mensagens originadas no servidor que possuam um ator supervisor definido, o ator supervisor
é localizado e é feito um envio local assíncrono da mensagem para ele.

O Akka possui uma configuração opcional de segurança onde cada JVM que esteja executando o
arcabouço pode definir um \english{cookie}. O \english{cookie} nada mais é do que uma chave
que o usuário pode gerar e que é parte das informações de cabeçalho das mensagens.
Quando a verificação de segurança está ativada, o recebedor da mensagem verifica se a informação
do \english{cookie} presente na mensagem confere com a informação esperada. Essa verificação
ocorre entre os passos $6$ e $7$ da figura \ref{fig:remote-actor-message-flow} e caso
os valores sejam iguais, o passo $7$ será executado. Caso contrário, uma exceção de segurança 
é lançada na JVM que recebeu a mensagem e o passo $7$ não é executado.

O Netty oferece algumas opções específicas para o transporte de mensagens baseadas
em \english{socket}s TCP. Exemplos dessas opções são a definição do tamanho máximo da
janela utilizada para o envio das mensagens a atores remotos, o tempo limite de espera 
para leitura na \english{socket}, o intervalo de espera para tentativa de reconexão e
o intervalo máximo em que o cliente deve tentar se conectar. Além dessas opções, o
Netty fornece ainda a possibilidade de compactação das mensagens durante o envio. O Akka
faz uso de todas as opções listadas, permitindo que os usuários da biblioteca definam
os valores desejados. As configurações de todos os módulos do Akka são feitas no 
arquivo \lstinline$akka.conf$. A seção para se informar as configurações do módulo de atores 
remotos é mostrada na listagem \ref{lst:akka-conf-vanilla}.

\begin{lstlisting}[frame=tb, caption={Seção remote do arquivo akka.conf.}, label={lst:akka-conf-vanilla}]
...
remote {
    secure-cookie = "050E0A0D0D0601AA00B0090B..." 
    compression-scheme = "zlib"
    zlib-compression-level = 6
    layer = "akka.remote.netty.NettyRemoteSupport"

    server {
      hostname = "localhost"
      port = 2552           
      message-frame-size = 1048576 
      connection-timeout = 1
      require-cookie = on
      untrusted-mode = off
    }

    client {
      reconnect-delay = 5
      read-timeout = 10
      message-frame-size = 1048576
      reconnection-time-window = 600
    }
}
\end{lstlisting}

\subsection{Protocolo para envios de mensagens a atores remotos}
\index{Akka!atores remotos!protocolo}
\label{sec:atores_remotos_akka_protocolo}

O protocolo utilizado para envios de mensagens entre atores remotos é definido no Akka com o
uso da biblioteca Protobuf. 

Protobuf \cite{protobuf} é uma biblioteca que permite que dados estruturados sejam representados 
em um formato eficiente e extensível. A biblioteca possui um compilador que 
converte a definição de protocolos em classes Java, Python e C++, permitindo uma interação 
direta com o protocolo nas linguagens, eliminando a necessidade de bibliotecas adicionais 
para conversões. A bibliteca permite que protocolos sejam definidos com a palavra-chave 
\lstinline$message$. Protocolos podem contér outros protocolos e tipos primitivos 
de dados, como por exemplo números, textos, boleanos e vetores de dados. Ademais, pode-se
definir a obrigatoriedade dos valores para alguns atributos com as palavras-chaves
\lstinline$optional$ e \lstinline$required$.

O protocolo das mensagens é mostrado na listagem \ref{lst:proto-message}. Uma mensagem
é definida pelo tipo de seriação (linha $1$) que foi utilizado na codificação dos dados da mensagem 
(listagem \ref{lst:proto-enum-serial}), pelos bytes da mensagem (linha $2$) 
e por um atributo que é utilizado para informar o nome da classe da mensagem. 
As mensagens para atores remotos são definidas com 
base no tipo de seriação que foi definido na JVM de onde partiu o envio. Para que a JVM 
que esteja recebendo a mensagem possa fazer o processamento correto, a informação do tipo de 
seriação deve estar presente. O atributo de manifesto da mensagem (linha $3$) é opcional, 
porém é utilizado para forçar o carregamento da classe no \english{class loader}
onde a mensagem será desseriada. 

\begin{lstlisting}[frame=tb, caption={Protocolo para mensagens.}, label={lst:proto-message}]
message MessageProtocol {
  required SerializationSchemeType serializationScheme = 1;
  required bytes message = 2;
  optional bytes messageManifest = 3;
}
\end{lstlisting}

\begin{lstlisting}[frame=tb, caption={Enumeração com tipos de seriação suportados.}, label={lst:proto-enum-serial}]
enum SerializationSchemeType {
  JAVA = 1;
  SBINARY = 2;
  SCALA_JSON = 3;
  JAVA_JSON = 4;
  PROTOBUF = 5;
}
\end{lstlisting}  

Pelo fato de as referências remotas dos atores que estão enviando uma mensagem serem enviadas
junto à mensagem foi necessário a definição de um protocolo para as \lstinline$RemoteActorRef$s.
O protocolo é mostrado na listagem \ref{lst:proto-remote-actor}. O protocolo define
o nome que é utilizado para identificar o ator (linha $1$), a classe que foi utilizada para
a criação do ator (linha $2$), o endereço de onde o ator remoto foi criado (linha $3$) e por
fim um valor opcional (linha $4$), que indica o tempo máximo que o ator deve ficar bloqueado 
durante um envio síncrono. O protocolo \lstinline$AddressProtocol$ utilizado na linha $3$ é
definido pelos atributos endereço do hospedeiro e porta.

\begin{lstlisting}[frame=tb, caption={Protocolo para referências de atores remotos.}, label={lst:proto-remote-actor}]
message RemoteActorRefProtocol {
  required string classOrServiceName = 1;
  required string actorClassname = 2;
  required AddressProtocol homeAddress = 3;
  optional uint64 timeout = 4;
}
\end{lstlisting}

Por fim, o protocolo utilizado para as mensagens remotas que é composto, dentre
outros protocolos menores, pelo protocolo para mensagens (linha $4$) e pelo protocolo para 
referências remotas (linha $7$), é apresentado na listagem \ref{lst:proto-remote-message}.
Na linha $1$, o atributo \lstinline$uuid$ é um identificador único para as mensagens.
A implementação do protocolo \lstinline$UuidProtocol$ utiliza a biblioteca UUID \cite{uuid}
que é uma implementação de identificadores globais únicos. Podemos notar na linha $4$ um 
atributo boleano que é utilizado para indicar se é esperado uma mensagem de resposta para a
mensagem que está sendo processada. Envios feitos via método \lstinline$!$ possuem valor
\lstinline$oneWay = true$, enquanto que os demais envios não.

\begin{lstlisting}[frame=tb, caption={Protocolo para envios de mensagens remotas.}, label={lst:proto-remote-message}]
message RemoteMessageProtocol {
  required UuidProtocol uuid = 1;
  required ActorInfoProtocol actorInfo = 2;
  required bool oneWay = 3;
  optional MessageProtocol message = 4;
  optional ExceptionProtocol exception = 5;
  optional UuidProtocol supervisorUuid = 6;
  optional RemoteActorRefProtocol sender = 7;
  repeated MetadataEntryProtocol metadata = 8;
  optional string cookie = 9;
}
\end{lstlisting}

Optamos por não detalhar os demais sub-protocolos utilizados para compor o protocolo para
mensagens remotas pois, apesar de serem importantes para o suporte a atores remotos, 
eles não possuem grande relevância para o desenvolvimento deste trabalho.

\subsection{Seriação de mensagens e de referências remotas}
\index{Akka!atores remotos!seriação}
\label{sec:atores_remotos_akka_seriacao}

Os diferentes tipos de seriação suportados pelo projeto Akka são utilizados na seriação
da mensagem (listagem \ref{lst:proto-message}) e opcionalmente na seriação da referência
remota (listagem \ref{lst:proto-remote-actor}). O módulo \lstinline$Serializable$ define 
um conjunto de \english{traits} que podem ser utilizadas para trocar a seriação Java 
padrão por algum dos outros formatos suportados.

O módulo \lstinline$Serializer$ define um objeto chamado de \lstinline$MessageSerializer$
que é o responsável para seriação e desseriação das mensagens. A seriação das mensagens
acontece com base no tipo da mensagem. Por exemplo, se a instância utilizada como
argumento para os métodos de envio de mensagens implementar a \english{trait}
\lstinline$ScalaJSON$, o conteúdo binário da mensagem estará no formato JSON.

A seriação de \lstinline$RemoteActorRef$s é suportada por padrão e é utilizada
no envio implícito do ator remetente (quando existe um ator remetente) junto
à mensagem. Contudo, a seriação do estado ou mesmo da definição do ator 
(chamada de \english{deep serialization}) deve, quando necessária, ser implementada pelo
usuário da biblioteca. A seriação completa do ator é útil
quando desejamos realocar o ator em um nó diferente do atual. 
