%% ------------------------------------------------------------------------- %%
\chapter{O Padrão AMQP}
\label{cap:amqp}
\index{AMQP!Padrão}
	AMQP \cite{amqp} (\english{Advanced Message Queuing Protocol}) é um 
	protocolo aberto para sistemas corporativos de troca de mensagens. 
	Especificado pelo AMQP \english{Working Group}, 
	o protocolo permite completa interoperabilidade para \english{middleware} 
	orientado a mensagens. A especificação define não somente o protocolo de rede, 
	mas também a semântica dos serviços da aplicação servidora. Também é parte 
	do foco que capacidades providas por sistemas de \english{middleware} orientados 
	a mensagem possam estar pervasivamente disponíveis nas redes das empresas, 
	incentivando o desenvolvimento de aplicações interoperáveis baseadas em troca 
	de mensagens. 
	
	O protocolo AMQP é um protocolo binário, assíncrono, seguro, portável, 
	neutro e eficiente, sendo também multi canal. 
	Na especificação \cite{amqp-spec}, o protocolo é dividido em três camadas, 
	mostradas na figura \ref{fig:protocol_overview}).	

	\begin{figure}[!h]
  		\centering
		\includegraphics{protocol_overview} 
	  	\caption{Camadas do protocolo AMQP.}
	  	\label{fig:protocol_overview}
	\end{figure}
	
	Nas seções seguintes descrevemos as camadas do protocolo AMQP.
	A camada de modelo, que é a camada que define o conjunto de objetos que 
	utilizamos em nosso trabalho, a camada de sessão que age como intermediária
	entre as camadas de modelo e transporte, e comentamos brevemente sobre a 
	camada de transporte, pois seus detalhes não se enquadram no escopo 
	deste trabalho. Apresentamos também algumas implementações do padrão e
	nossa escolha para este trabalho.

\section{A camada de modelo}		
	\label{sec:amqp-modelo}
	\index{AMQP!Padrão!Modelo}
	A camada de modelo é responsável pela definição do conjunto de comandos
	e dos objetos que as aplicações podem utilizar, como por exemplo, filas. 
	A especificação dos requisítos para essa camada possui, entre outros itens: 
	garantir a interoperabilidade das implementações, prover controle explícito
	sobre a qualidade do serviço, proporcionar um mapeamento fácil entre os 
	comandos e as bibliotecas de nível de aplicação e ter clareza, de modo 
	que cada comando seja responsável por uma única ação. Os componentes são: 

	\begin{itemize}
		\item Servidor: É o processo,  conhecido também como \english{broker}, que 
		aceita conexões de clientes e implementa as funções de filas de mensagens e 
		roteamento.
		  
		\item Filas: São entidades internas do servidor que armazenam as mensagens, 
		tanto em memória quanto em disco, até que elas sejam enviadas em sequência para 
		as aplicações consumidoras. As filas são totalmente independentes umas das outras. 
		Na criação de uma fila, várias propriedades podem ser especificadas: a fila de ser 
		pública ou privada, armazenar mensagens de modo durável ou transiente, e ter 
		existência permanente ou temporária (e.g.: a existência da fila é vinculada ao ciclo 
		de vida de uma aplicação consumidora). A combinação de propriedades como essas viabiliza 
		a criação de diversos tipos de fila, como por exemplo: fila armazena-e-encaminha 
		(\english{store-and-forward}), que armazena as mensagens e as distribui para vários 
		consumidores na forma \english{round-robin}, fila temporária para resposta, que 
		armazena as mensagens e as encaminha para um  único consumidor; e fila \english{pub-sub}, 
		que armazena mensagens provenientes de vários produtores e as envia para um único 
		consumidor.
		  
		\item \english{Exchanges}: São entidades internas do servidor que recebem e roteiam 
		as mensagens das aplicações produtoras para as filas, levando em conta critérios 
		pré-definidos. Essas entidades inspecionam as mensagens, verificando, 
		na maioria dos casos, a chave de roteamento presente no cabeçalho de cada mensagem. 		
		Com o auxílio da tabela de \english{bindings}, uma \english{exchange} decide como 
		encaminhar as mensagens às respectivas filas, jamais armazenado mensagens.
		  
		\item \english{Bindings}: São relacionamentos entre \english{exchanges} e filas. 
		Esses relacionamentos definem como deverá ser feito o roteamento das mensagens.
		
		  
		\item \english{Virtual hosts}: São coleções de \english{exchanges}, filas e 
		objetos associados. \english{Virtual hosts} são domínios independentes no servidor 
		e compartilham um ambiente comum para autenticação e segurança. As aplicações
		clientes escolhem um \english{virtual host} após se autenticarem no servidor.		  			
	\end{itemize}	
	
	A figura \ref{fig:amqp_overview} mostra os componentes acima descritos e os 
	relacionamentos entre esses componentes. 
	
	\vspace{1ex}
	\begin{figure}[hbtp]
	  \centering
	  \includegraphics{amqp-overview}
	  \caption{Visão geral dos componentes do modelo AMQP.}
	  \label{fig:amqp_overview}
	\end{figure}
        
	Em modelos pré-AMQP, as tarefas das \english{exchanges} e das filas eram 
	feitas por blocos monolíticos que implementavam tipos específicos de
	roteamento e armazenamento. O modelo AMQP separa essas tarefas e as atribui a 
	entidades distintas (\english{exchanges} e filas), que têm os seguintes
	papéis: \entry{(i)} receber as mensagens e fazer o roteamento para as filas; 
	\entry{(ii)} armazenar as mensagens e fazer o encaminhamento para as aplicações
	consumidoras. Vale frisar que filas, \english{exchanges} e \english{bindings} 
	podem ser criados tanto de modo programático como por meio de ferramentas 
	administrativas.
	
	Há uma analogia entre o modelo AMQP e sistemas de email:
	\begin{enumerate}	
		\item Uma mensagem AMQP é análoga a uma mensagem de \english{email}.
		
		\item Uma fila é análoga a uma caixa de mensagens.
		
		\item Um consumidor corresponde a um cliente de \english{email} que carrega e 
		apaga as mensagens.
		
		\item Uma \english{exchange} corresponde a um \english{mail transfer agent} (MTA) 
		que inspeciona as mensagens e, com base nas chaves de roteamento, 
		verifica as tabelas de registro e decide como enviar as mensagens para uma 
		ou mais caixas de mensagens. No caso do correio eletrônico as chaves de 
		roteamento são os campos de destinatário e cópias (To, Cc e Bcc).
		
		\item Um \english{binding} corresponde a uma entrada nas tabelas de roteamento 
		do MTA.		
	\end{enumerate}
        
	Para enviar uma mensagem, uma aplicação produtora especifica uma determinada 
	\english{exchange} de um determinado \english{virtual host}, uma rotulação com 
	informação de roteamento e eventualmente algumas propriedades adicionais, bem
	como os dados do corpo da mensagem. Uma vez que a mensagem tenha sido recebida 
	no servidor AMQP, ocorre o roteamento para uma ou mais filas do conjunto de 
	filas do \english{virtual host} especificado. No caso de não ser possível rotear a 
	mensagem, seja qual for o motivo, as opções  são: rejeitar a mensagem, descartá-la 
	silenciosamente, ou ainda fazer o roteamento para uma \english{exchange} alternativa. 
	A escolha depende do comportamento definido pelo produtor. Quando a mensagem
	é depositada em alguma fila (ou possivelmente em algumas filas), a fila tenta repassá-la 
	imediatamente para a aplicação consumidora. Caso isso não seja possível, a fila mantém a 
	mensagem armazenada para uma futura tentativa de entrega. Uma vez que a mensagem foi 
	entregue com sucesso a um consumidor, ela é removida da fila. 
	A figura~\ref{fig:amqp-message-flow} mostra o envio e recebimento de uma mensagem.
        
	\vspace{1ex}
	\begin{figure}[hbtp]
	  \centering
	  \includegraphics{amqp-message-flow}
	  \caption{Visão geral do fluxo de uma mensagem desde o produtor até o seu consumidor.}
	  \label{fig:amqp-message-flow}
	\end{figure}
        
	A aceitação ou confirmação de recebimento de uma mensagem fica a critério da aplicação 
	consumidora, podendo acontecer imediatamente depois da retirada da mensagem da fila ou
	após a aplicação consumidora ter processado a mensagem.

\section{A camada de sessão}		
	\index{AMQP!Padrão!Sessão}
	\label{sec:amqp-sessao}

	A camada de sessão, por sua vez age como uma intermediária entre a camada de modelo
	e a camada de transporte, proporcionando confiabilidade para a transmissão de comandos
	à aplicação servidora. É parte das suas responsabilidades dar confiabilidade
	às interações entre aplicações ciente e a aplicação servidora.
	
	Sessões são interações nomeadas entre um cliente e um servidor AMQP
	(também chamados de pares (\english{peers})). Todos os comandos,
	como por exemplo envios de mensagens e criações de filas ou \english{exchanges}, devem
	acontecer no contexto de uma sessão. O ciclo de vida de alguns dos objetos da camada
	modelo como filas, \english{exchanges} e \english{bindings} podem ser limitados ao
	escopo de uma sessão. 
	
	Os principais serviços providos pela camada de sessão para a camada de modelo são:
	\begin{itemize}
		\item Identificação sequencial dos comandos: Cada comando emitido pelos pares
		é identificado única e individualmente dentro da sessão, para que o sistema 
		seja capaz de garantir sua execução exatamente uma vez. Utiliza-se um esquema
		de numeração sequencial. A noção de idenficação permite a correlação de comandos
		e o retorno de resultados assíncronos. O identificador do comando é disponibilizado
		para a camada de modelo e, quando um resultado é retornado para um comando, o
		identificador desse comando é utilizado para estabelecer a correlação entre o
		comando e o resultado.
		
		\item Confirmação que comandos serão executados: É utilizado para que o par 
		solicitante possa seguramente descartar o estado associado a um comando, 
		com a certeza de que ele será executado. A camada de sessão controla o envio
		e recebimento das confirmações permitindo o gerenciamento do estado a ser mantido
		na sessão corrente. O estado da sessão é importante para que o sistema possa se
		recuperar no caso de falhas temporárias em um dos pares. As confirmações podem
		ser entregues em lotes ou mesmo serem deferidas indefinidamente no caso do par
		solicitante não requerer a confirmação de que o comando será executado.
		
		\item Notificação de comandos completados: Diferente do conceito de confirmação,
		este serviço informa o par que solicitou a execução de um comando que esse foi
		executado por completo. As notificações de comandos completados tem como motivação
		a sincronização e a garantia de ordem de execução entre diferentes sessões. Quando
		o par que solicitou a execução do comando não exige confirmação imediata, as 
		confirmações podem ser acumuladas e enviadas em lotes, reduzindo o tráfego de rede.
		
		\item Reenvio e recuperação em caso de falhas de rede: Para que o sistema possa
		se recuperar no caso de falhas de rede, a sessão deve ser capaz de reenviar comandos
		cujos recebimentos pelo outro par são duvidosos. A camada de sessão provê as
		ferramentas necessárias para identificar o conjunto com os comandos rotulados
		como duvidosos, e reenviá-los sem o risco de causar duplicidade.
	\end{itemize}
		
	

\section{A camada de transporte}
	\label{sec:amqp-transporte}
	\index{AMQP!Padrão!Transporte}

	A camada de transporte é responsável por tarefas como 
	multiplexação de canais, detecção de falhas, representação de dados e 
	janelamento (\english{framing}).  A lista dos requisítos dessa camada 
	inclui, entre outros itens: possuir uma representação de dados binária 
	e compacta que seja rápida de se embrulhar e desembrulhar, trabalhar 
	com mensagens sem um limite significante de tamanho, permitir que 
	sessões não sejam perdidas no caso de falhas de rede ou de aplicação, 
	possuir assincronidade e neutralidade em relação a linguagens de 
	programação. 


\section{Implementações}	
	\label{sec:amqp-implementacoes}
	\index{AMQP!Padrão!Implementações}
	
	Dentre as implementações de \english{message brokers} baseados no protocolo AMQP
	disponíveis, destacamos Apache Qpid \cite{qpid}, ZeroMQ \cite{zeromq} e 
	RabbitMQ \cite{rabbitmq}. 	
	
	A implementação feita no projeto Apache Qpid é uma implementação com código
	aberto feita em Java e em C++, com bibliotecas para aplicações cliente em 
	diversas linguagens, como Java, C++, Ruby, Python e C\#.Net. A implementação da 
	biblioteca cliente para Java é compatível com o a versão $1.1$ do padrão Java 
	\english{Message Service} \cite{jms}. A implementação está disponível sob a licença 
	Apache $2.0$ \cite{apache-lic}.
	
	O projeto ZeroMQ também é uma implementação com código aberto feita em C++, com
	bibliotecas disponibilizadas para aplicações cliente em mais de $20$ linguagens,
	incluindo Java, Python, C++ e C. A implementação para clientes Java depende de
	bibliotecas nativas compiladas para cada sistema operacional suportado. 
	A implementação está disponível sob a licença LGPL \cite{lgpl}.
	
	O projeto RabbitMQ é implementado na linguagem Erlang, e também possui bibliotecas
	para aplicações cliente em diversas linguagens como Java, Erlang e Python. 
	A implementação da biblioteca para clientes Java é totalmente feita na linguagem
	e não possui dependências de sistema operacional. A implementação está disponível
	sob a licença MPL \cite{mpl}.

	Como a especificação AMQP não define uma API padrão para as aplicações clientes,	
	o código desenvolvido acabou por ser específico para a biblioteca cliente do 
	projeto RabbitMQ. Optamos por esta implementação por diversos fatores, a destacar:
	
	\begin{itemize}
		\item Atividade na comunidade de usuários e desenvolvedores.
		
		\item Facilidade para se obter informações, seja via tutoriais ou em listas 
		de discussões.
		
		\item Possuir código aberto.
		
		\item Biblioteca para clientes Java independente de plataforma.
		
		\item Se tratar não só de um projeto, mas sim de um produto\footnote{
			A empresa responsável pelo suporte é a Spring Source, uma divisão da VMware}.			
		
		\item Ser escrito em uma linguagem desenvolvida apropriada para 
		sistemas concorrentes.
		
		\item Possuir ferramentas para administração e monitoramento.
	\end{itemize}
	
	Apresentamos na próxima sub-seção os objetos biblioteca para clientes Java disponibilizada 
	no projeto RabbitMQ que utilizamos e como eles se relacionam.
	
	\subsection{RabbitMQ - Biblioteca para clientes Java}
		\label{subsec:amqp-rabbit-api}
		\index{AMQP!Padrão!Implementações!RabbitMQ cliente Java}
	
	A biblioteca para clientes Java disponibilizada pelo projeto RabbitMQ define 
	diversos classes para que seja possível a interação com o \english{broker}. 
	A conexão acontece através de um objeto \lstinline$com.rabbitmq.client.Connection$, 
	que pode ser obtido pelo objeto \lstinline$com.rabbitmq.client.ConnectionFactory$.
	
	
	