%% ------------------------------------------------------------------------- %%
\chapter{Resultados Experimentais}
\label{cap:resultados}

Apresentamos nesse capítulo uma aplicação de \english{benchmark} desenvolvida para
medir o desempenho de nosso protótipo. Apresentamos também uma comparação de desempenho entre a 
implementação original de atores remotos do projeto Akka e o protótipo desenvolvido neste trabalho.
Para finalizar, fazemos uma breve discussão dos resultados observados.

\section{Trading System}
\index{Resultados!Trading System}
\label{sec:resultados:trading_system}

Para medir como novas alterações na biblioteca de atores afetavam o desempenho da biblioteca, 
os desenvolvedores do projeto Akka criaram uma aplicação de \english{benchmark}
que simula compra e venda de ações. Os desenvolvedores criaram também alguns módulos que 
auxiliam em tarefas como armazenamento dos dados coletados nos experimentos e geração de relatórios. 
A aplicação de \english{benchmark} tem um lado servidor, denominado \english{Trading System},
e um lado cliente. A disposição dos componentes do \english{Trading System} é mostrada na 
figura \ref{fig:trading-system}. Os componentes são descritos a seguir:

\begin{itemize}
	\item \english{Order Book}: É uma entidade que possui informações sobre as
	ordens de compra e de venda de uma determinada ação. Neste sistema, uma ação
	é rotulada por uma letra e por um número. Um \english{order book} tem como 
	responsabilidade fazer o casamento de uma ordem de venda com uma ordem de compra.
	São utilizados como nomes de ações as letras A, B e C, combinadas com
	números de $1$ a $5$, num total de quinze \english{order books}.

	\item \english{Matching Engine}: É um ator que age como intermediário 
	no encaminhamento de mensagens aos \english{order books}. Existe um \english{matching engine}
	para cada letra de \english{order book}.

	\item \english{Order Receiver}: É um ator externo (visível para o lado cliente da aplicação) que tem o papel de receber
	mensagens de compra e venda de qualquer ação. Quando uma ordem é recebida por um
	\english{order receiver}, ele identifica o  \english{matching engine}
	responsável pela ordem e encaminha a mensagem a esse \english{matching engine}. 
	A quantidade de \english{order receivers} não possui relação com a quantidade de 
	\english{matching engines}, já que um \english{order receiver} recebe
	ordens de qualquer tipo de ação. O sistema possui dez \english{order receivers}.

	\item \english{Trading System}: É um ator externo que tem o papel de recepcionista do sistema. Tem a responsabilidade
	de fazer a criação e a inicialização dos demais atores que fazem parte do lado servidor da aplicação. 
	O lado cliente utiliza o ator recepcionista apenas uma vez, para obter uma lista com os \english{order receivers} criados
	na inicialização do lado servidor.

	\item \english{Order}: É um componente que não é mostrado na figura, mas que desempenha o papel de mensagem
	e representa uma ordem. É definida em uma classe abstrata e possui como atributos o código da ação, o volume e 
	o valor da ordem. Suas implementações são \code{Ask}, para indicar uma ordem de venda, e \code{Bid}, 
	para indicar uma ordem de compra.
\end{itemize}

\begin{figure}[!h]
		\centering
		\includegraphics[scale=.70]{trading-system} 
 		\caption{Trading System -- Sistema de compra e vendas de ações.}
  		\label{fig:trading-system}
\end{figure}

O lado cliente da aplicação possui ainda atores rotulados como ``clientes''. Um ator cliente 
possui uma lista com ordens a serem enviadas a um \english{order receiver}. 
Um ator cliente possui também dois atributos adicionais. O primeiro é o número de repetições, um valor inteiro que indica
quantas vezes as ordens que estão na lista do ator serão enviadas. O segundo atributo
é o \english{order receiver} para o qual as mensagens serão enviadas.
A quantidade de atores clientes varia de acordo com a instância do experimento que
se deseja fazer. Essa quantidade não precisa ser necessariamente igual à quantidade de \english{order receivers}.
A associação entre atores clientes e \english{order receivers} é feita emparelhando-se os elementos
da lista de atores clientes com os da lista de \english{order receivers}, sendo essa última considerada
como uma lista circular (ou seja, uma vez que se tenha alcançado o último \english{order receiver}, o emparelhamento
prossegue a partir do primeiro \english{order receiver}). Dependendo da quantidade de atores clientes, 
alguns \english{order receivers} podem recebem mais mensagens que outros.

Cada ator cliente possui uma lista com trinta ordens, das quais quinze são ordens de compra e quinze são ordens de venda.
O número de ordens enviado por um ator cliente é o comprimento dessa lista (trinta) multiplicado 
pelo número de repetições. As mensagens são enviadas assincronamente.
A medição do tempo de processamento de uma mensagem tem início imediatamente antes do envio da mensagem e
término imediatamente após o processamento da mensagem por um \english{order book}.

\section{Trading System com atores remotos}
\index{Resultados!Trading System com atores remotos}
\label{sec:resultados:trading_system_remoto}

Ainda que o \english{Trading System} não tenha sido criado para experimentos com atores remotos, 
consideramos que ele é de grande utilidade para comparar o desempenho
entre o suporte padrão a atores remotos do Akka e o desenvolvido neste trabalho. Para tal,
foram necessárias as alterações listadas a seguir:

\begin{enumerate}
	\item Registramos como atores remotos todos os atores que estão posicionados na área rotulada como ``Atores Externos''
	na figura \ref{fig:trading-system}. Como consequência dessa alteração, passamos a obter as referências 
	para os atores externos via método \code{actorFor} (seção \ref{sec:atores_remotos_akka}).

	% TRC: este trecho esta muito confuso, e particularmente acho desnecessário tanto detalhe
	%Essa modificação resultou em alterações na inicialização do \english{Trading System} e na obtenção
	%dos \english{order receivers}. 	
	%Na versão remota, apenas os nomes sob o qual os \english{order receivers}
	%foram registrados no registro de atores remotos é devolvido. Na versão local, são devolvidas \lstinline{ActorRef}s.
	%Evitamos devolver \lstinline{ActorRef}s como parte das mensagens pois, neste caso, os atores deveriam
	%passar por uma seriação funda. Enviando os nomes sob os quais os atores foram registrados, permite que
	%façamos buscas no registro de atores remotos, trabalhando apenas com as referências remotas.	

	\item Fizemos com que as classes \code{Ask} e \code{Bid} passassem a ser seriáveis. 
	Optamos por utilizar como formato de seriação o formato definido na feição \lstinline{ScalaJSON}
	(seção \ref{sec:atores_remotos_akka_seriacao}).

	\item Alteramos os envios das mensagens feitos pelos atores clientes. Os atores clientes passaram
	a fazer envios síncronos, com o uso do método \lstinline{!!}. 

	\item Modificamos a maneira de medir o tempo de processamento de uma mensagem. Na aplicação de \english{benchmark}
	original, a medição começa no lado cliente e termina no lado servidor da aplicação. O fato de desses
	dois lados residirem na mesma JVM facilita essa medição. Em nossa aplicação de \english{benchmark} modificada,
	entretanto, os lados cliente e servidor residem em JVMs que rodam em nós diferentes. Por esse motivo,
	fazemos toda a medição no lado cliente. Para cada mensagem enviada por um ator cliente,
	a medição tem início imediatamente antes da execução do método \lstinline{!!} (que é invocado sobre um \english{order receiver} remoto) e término logo após a execução desse método.
\end{enumerate}

As configurações utilizadas no arquivo \lstinline{akka.conf} para os experimentos com o suporte padrão
a atores remotos do Akka são as recomendadas para uso geral (compressão média de mensagens e tamanho
do janelamento das mensagens de $1$KB). Nos experimentos executados com o suporte remoto via AMQP,
utilizamos uma conexão por canal além da configuração \lstinline{DURABLE} para as pontes AMQP 
(seção \ref{sec:entidades-via-broker-amqp-bridges}).

\section{Comparação de desempenho}
\index{Resultados!comparação de desempenho}
\label{sec:resultados:analise_de_desempenho}

Para que pudéssemos ter medidas mais reais, implantamos os atores clientes e os atores do
\english{Trading System} em JVMs residentes em nós fisicamente separados. A máquina
virtual Erlang com o RabbitMQ ficou separada em um terceiro nó.
Essa máquina virtual foi executada em um \english{laptop} Dell Inspiron N4030 com processador Intel 
Core i3 de $2.4$ GHz, $4$ GB de RAM e Linux Ubuntu $10.10$. A JVM na qual implantamos os atores clientes foi executada
em um \english{laptop} Lenovo T410 com processador Intel Core i5 de $2.4$ GHz, $4$ GB de RAM
e Linux Ubuntu $10.10$. Por fim, a JVM com o \english{Trading System} foi 
executada em um \english{laptop} MacBook Pro com processador Core $2$ Duo de $2.4$ GHz, $4$ GB de RAM
e Mac OS X $10.7$. Os três \english{laptops} foram conectados por um roteador D-Link DI-$524$.
Apesar deste ser um roteador para redes \english{wireless}, optamos por usar cabos de rede para conectá-lo
a cada um dos \english{laptops}.

A estrutura criada para medição e comparação de desempenho de atores locais do Akka
utiliza algumas bibliotecas para o armazenamento e geração de relatórios. Os valores
das medidas registradas em uma instância de experimento são organizados em percentis. 
A biblioteca utilizada para o cálculo de percentis é a Commons Math da fundação Apache \cite{commons-math}.
Os relatórios gerados apresentam também a quantidade de envios e respostas por segundo (ER/S),
o tempo médio de cada envio e resposta e ainda o tempo total gasto para a execução de
todos os envios e respostas. 

Definimos o número de mensagens que cada cliente enviou da seguinte maneira: seja $n_c$ a 
quantidade de atores clientes utilizada em um experimento e seja $r$ o número de repetições; cada ator cliente 
enviou $(30r)/n_c$ mensagens. O valor $r$ de repetições utilizado foi $1000$. 
Variamos os valores de $n_c$ de modo que o resultado da divisão fosse sempre inteiro. A quantidade total
de mensagens enviadas por todos os atores clientes em uma instância de experimento foi sempre $30000$. 

A tabela \ref{tab:medidas} mostra os resultados de nossos experimento com atores via Netty e via AMQP.
Cada linha dessa tabela representa um instância de experimento com o número de clientes indicado na coluna ``Clientes''.
Os experimentos foram executados múltiplas vezes. Os valores apresentados na tabela \ref{tab:medidas} são
melhores medidas que obtivemos. O critério que utilizamos para comparar as medidas de um mesmo experimento
foi o valor apresentado na coluna ``Média''. Em outras palavras, cada linha da tabela \ref{tab:medidas}
contém as informações do experimento que apresentou o menor valor do tempo médio para um envio
síncrono.

\renewcommand{\arraystretch}{0.85}
\captionsetup{margin=1.0cm}
\begin{table}[h]
\begin{center}
\begin{scriptsize}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|} 
\hline

{Impl.} & {Clientes} & {ER/S} & {Média ($\mu s$)} & {25\% ($\mu s$)} & {50\% ($\mu s$)} & {75\% ($\mu s$)} & 
{95\% ($\mu s$)} & {Dur. ($s$)} \\ \hline \hline
Netty & 1 & 501 &  1995 & 1364 & 1433 & 1968 & 3266 & 59.85 \\
AMQP  & 1 & 263 &  3797 & 3283 & 3361 & 3537 & 4550 & 113.91 \\ \hline
 & Variação & -47.50\% & 90.33\%  &  140.69\% &  134.54\% &  79.73\% &  39.31\% &  54.06 (90.33\%) \\ \hline
									
Netty & 2 & 894 & 2238 & 1770 & 1796 & 1836 & 3290 & 33.57 \\
AMQP  & 2 & 528 & 3789 & 3234 & 3359 & 3552 & 4208 & 56.83 \\ \hline
 & Variação & -40.99\% &  69.30\% &   82.71\% &  87.03\% &  93.46\% &  27.90\% &  23.26 (69.33\%) \\ \hline

Netty & 4 & 1245 & 3212 & 2070 & 2517 & 2726 & 4214 & 24.09 \\
AMQP  & 4 &  906 & 4416 & 3248 & 3614 & 4134 & 5088 & 33.12 \\ \hline
 & Variação  & -27.31\% &  37.48\% &  56.91\% &  43.58\% &  51.65\% &  20.74\% &  9.03 (37.48\%) \\ \hline

Netty & 8 & 1494 & 5353 & 3274 & 3771 & 4745 & 6168 & 20.07 \\
AMQP & 8 & 1389 & 5760 & 3567 & 4149 & 5168 & 6425 & 21.60 \\ \hline
 & Variação & -7.10\% &  7.60\% &  8.95\% &  10.02\% &  8.91\% &  4.17\% &   1.52 (7.60\%) \\ \hline

Netty & 10 & 1542 & 6484 & 4005 & 4330 & 5704 & 7041 & 19.45 \\
AMQP & 10 & 1424 & 7023 & 4396 & 5107 & 6136 & 7610 & 21.06 \\ \hline
 & Variação & -7.72\% &  8.31\% &   9.76\% &  17.94\% &  7.57\% &  8.08\% &  1.61 (8.31\%) \\ \hline

Netty & 20 & 1568 & 12757 & 8206 & 9646 & 10146 & 12015 & 19.13 \\
AMQP & 20 & 1503 & 13309 & 8728 & 9964 & 10888 & 13430 & 19.96 \\ \hline
 & Variação & -4.15\% &  4.33\% &   6.36\% &  3.30\% &  7.31\% &  11.78\% &  0.82 (4.33\%) \\ \hline

Netty & 40 & 1589 & 25176 & 17616 & 18183 & 19436 & 21350 & 18.82 \\
AMQP & 40 & 1518 & 26345 & 18496 & 19525 & 20842 & 23360 & 19.75 \\ \hline
& Variação & -4.41\% &  4.64\% &   5.00\% &  7.38\% &  7.23\% &  9.41\% &  0.87 (4.64\%) \\ \hline 

Netty & 80 & 1615 & 49525 & 35403 & 36541 & 37863 & 40041 & 18.57 \\
AMQP & 80 & 1535 & 52122 & 37915 & 39399 & 40943 & 43496 & 19.54 \\ \hline
 & Variação & -5.02\% & 5.24\% &  7.10\% & 7.82\% & 8.13\% & 8.63\% & 0.97 (5.24\%) \\

\hline 
\end{tabular}
\caption{Medidas de tempo do Trading System com atores remotos.}
\label{tab:medidas}
\end{scriptsize}
\end{center}
\end{table}

O fato de introduzirmos um terceiro nó com o \english{message broker} usado na comunicação
entre os atores remotos naturalmente adiciona mais passagens pela rede que conecta os nós.
Um envio que utilize o Netty faz com que duas mensagens trafeguem pela rede: a ordem é
enviada pelo \lstinline{RemoteClient} diretamente ao \lstinline{RemoteServer}. A mensagem de resposta, por sua vez,
faz o caminho inverso, indo do \lstinline{RemoteClient} para o \lstinline{RemoteServer}. 
Já quando utilizamos nossa implementação com AMQP, quatro mensagens
trafegam. A ordem é enviada pelo \lstinline{RemoteClient} ao \english{message broker} e
o \english{message broker} a envia para o \lstinline{RemoteServer}. A mensagem de resposta, por sua vez, 
faz o caminho inverso, do \lstinline{RemoteServer} para o \english{message broker}, e depois
do \english{message broker} para o \lstinline{RemoteClient}. Por esse motivo, esperávamos que 
o tempo gasto pela implementação com AMQP fosse por volta de duas vezes maior do que o tempo gasto pela 
implementação com Netty. 

Observando a variação dos dados da tabela \ref{tab:medidas} para a instância com apenas um ator cliente, 
podemos notar uma diferença bem próxima da esperada. O número de envios e respostas por segundo com nossa implementação 
é quase metade do valor obtido com o Netty (variação de $-47.50\%$) e o valor médio para cada envio/resposta leva 
quase o dobro do tempo (variação de $90.33\%$). Como consequência, a duração total também leva quase o dobro 
do tempo. 

A análise por percentis nos ajuda a ter uma ideia muito interessante sobre o tempo 
de resposta de um sistema. Por exemplo, no \english{Trading System}, quando observamos o $95\%$ percentil,
para apenas um ator cliente, sabemos que $95\%$ dos envios e respostas são completados em 
no máximo $3266 \mu s$ com o Netty e $4550 \mu s$ com AMQP,
resultando em uma variação de $39.31$\%. Contudo, se observarmos os demais percentis, podemos notar 
que, nos dois percentis mais baixos ($25\%$ e $50\%$), as execuções feitas com AMQP foram mais de duas vezes 
mais lentas que as execuções feitas com Netty (variações de $140.69$\% e $134.54$\%). 

Com o aumento do número de atores clientes, a diferença de tempo apresenta uma boa diminuição.
O gráfico da figura \ref{fig:grafico-er} mostra a evolução da quantidade de envios e respostas com o aumento
da quantidade de atores clientes. Podemos observar que, conforme a quantidade de atores clientes foi aumentando, 
os resultados obtidos com nossa implementação apresentaram uma boa melhora e se mantiveram muito
próximos dos resultados obtidos com a implementação original do Akka. A diferença na quantidade de envios e respostas
por segundo, que era de quase 
$-47.50\%$, cai (em valor absoluto) até atingir o valor de apenas $-5.02\%$, que no nosso experimento representa pouco 
menos de $1$ segundo para completar todos os envios e respostas na instância com $80$ atores clientes. 
De um modo geral, se observarmos os tempos de execução para os experimentos a partir de 
$8$ atores clientes, quando o sistema começa a atingir seu
ponto de saturação, temos uma diferença de tempo abaixo de $1.6$ segundos. 

\begin{figure}[!h]
		\centering
		\includegraphics[scale=.70]{grafico-er} 
 		\caption{Comparação da quantidade de envios e respostas.}
  		\label{fig:grafico-er}
\end{figure}

Vale relembrar que não adicionamos compressão nas mensagens em nossa implementação com AMQP e que
os experimentos feitos com Netty utilizaram compressão média. Como as mensagens são 
menores que $1$KB, entendemos que a implementação com AMQP possa ter sido ligeiramente
beneficiada em relação a implementação com Netty. Ademais, o terceiro nó também colabora com a distribuição 
do processamento. Na implementação feita com Netty, tanto as classes responsáveis pelo envio e 
recebimento de mensagens quanto as classes do Netty compartilham a  mesma JVM que executa os atores da aplicação
de \english{benchmark}. Já na implementação com AMQP, apenas as classes responsáveis pelo envio e recebimento de mensagens 
compartilham a mesma JVM. Durante a execução dos experimentos, mesmo diante de um cenário com alta concorrência em que múltiplos
atores clientes executaram envios em paralelo para um \lstinline{RemoteClient} compartilhado, 
não tivemos problemas comuns de concorrência (como \english{deadlocks} e condições de corrida)
em nossa implementação. 

Pelo fato do tráfego de mensagens na rede ser duas vezes maior no caso AMQP, naturalmente a latência da 
rede é um dos principais fatores que podem afetar o desempenho de atores via AMQP. Refizemos os experimentos
já descritos, agora empregando uma rede com maior latência que a utilizada anteriormente.
Utilizamos a mesma configuração de \english{hardware} já descrita, porém retiramos os cabos que ligavam
os \english{laptops} ao roteador. A conexão de cada \english{laptop} ao roteador passou a ser feita
via rede \english{wireless}.

A tabela \ref{tab:medidas-lentas} apresenta os resultados dos novos experimentos. Os dados dessa tabela
mostram que, no pior caso, o tempo gasto com a implementação com AMQP é pouco mais de duas vezes e meia
maior que o gasto pela implementação com Netty. Esse pior caso ocorre quando o número de atores clientes
é igual a $4$. 
Quando observamos os percentis, podemos notar que, nos dois percentis mais baixos, as execuções feitas com
AMQP foram aproximadamente três vezes mais lentas que as execuções feitas com Netty (variações de $209.28$\% e $197.17$\%). Nos dois percentis mais altos, há uma redução razoável nessa diferença (variações de $179.11$\% e  $145.07$\%). 
Assim como na tabela \ref{tab:medidas}, conforme aumentamos a quantidade de atores clientes, a diferença de tempo cai  
(em valores absolutos) até atingir $26.74\%$, que corresponde a pouco menos que $9$ segundos para todos os 
envios e respostas. 

\renewcommand{\arraystretch}{0.85}
\captionsetup{margin=1.0cm}
\begin{table}
\begin{center}
\begin{scriptsize}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|} 
\hline

{Impl.} & {Clientes} & {ER/S} & {Média ($\mu s$)} & {25\% ($\mu s$)} & {50\% ($\mu s$)} & {75\% ($\mu s$)} & 
{95\% ($\mu s$)} & {Dur. ($s$)} \\ \hline \hline

Netty & 1 & 163 &  6129 & 3387 & 4279 & 6265 & 13403 & 183.87 \\
AMQP  & 1 & 106 &  9464 & 5998 & 7223 & 9624 & 17360 & 283.92 \\ \hline
 & Variação & -34.97\% & 54.41\% &  77.09\% & 68.80\% & 53.62\% & 29.52\% & 100.05 (54.41\%) \\ \hline

Netty & 2  &  341  &  5857  &  3418  &  4113  &  5635  &  11481  & 87.855 \\
AMQP  & 2  &  152  &  13121  &  8963  &  10784  &  14077  &  22309 & 196.815 \\ \hline
 & Variação & -55.43\% & 124.02\%  &  162.23\%  &  162.19\%  &  149.81\%  &  94.31\%  &  108.96 (124.02\%) \\ \hline

Netty & 4  &  479  &  8337  &  5248  &  6334  &  8219  &  13892 & 62.5275 \\
AMQP  & 4  &  183  &  21872  &  16231  &  18823  &  22940  &  34045 & 164.04 \\ \hline
 & Variação & -61.80\% & 162.35\%  &  209.28\%  &  197.17\%  &  179.11\%  &  145.07\%  &  101.51 (162.35\%) \\ \hline

Netty & 8  &  491  &  16292  &  10528  &  12692  &  15780  &  23123 & 61.095 \\
AMQP  & 8  &  198  &  40463  &  26918  &  33224  &  41392  &  58513 & 151.73625 \\ \hline
 & Variação & -59.67\% & 148.36\%  &  155.68\%  &  161.77\%  &  162.31\%  &  153.05\%  &  90.64 (148.36\%) \\ \hline

Netty & 10  &  559  &  17883  &  12737  &  14918  &  18099  &  25705 & 53.649 \\
AMQP & 10  &  243  &  40891  &  29653  &  34970  &  41936  &  56755 & 122.673 \\ \hline
 & Variação & -56.27\%  &  128.66\%  &  132.81\%  &  134.41\%  &  131.70\%  &  120.79\%  &  69.02 (128.66\%) \\ \hline

Netty & 20  &  563  &  35486  &  22392  &  26879  &  32957  &  47837 & 53.23 \\
AMQP & 20  &  323  &  61951  &  47710  &  55291  &  64509  &  84108 & 92.92 \\ \hline
 & Variação & -42.63\% & 74.58\%  &  113.07\%  &  105.70\%  &  95.74\%  &  75.82\%  &  39.69 (74.58\%) \\ \hline

Netty & 40  &  607  &  65782  &  41155  &  49748  &  60805  &  83042 & 49.33 \\
AMQP & 40  &  390  &  98951  &  62679  &  77785  &  98463  &  150803 & 74.21 \\ \hline
 & Variação & -35.75\% & 50.42\%  &  52.30\%  &  56.36\%  &  61.93\%  &  81.60\%  &  24.87 (50.42\%) \\ \hline

Netty & 80  &  889  &  89089  &  36654  &  39031  &  50225  &  103695 & 33.41 \\
AMQP & 80  &  628  &  112913  &  66128  &  77563  &  94990  &  139215 & 42.34 \\ \hline
 & Variação & -29.36\% & 26.74\%  &  80.41\%  &  98.72\%  &  89.13\%  &  34.25\%  &  8.93 (26.74\%) \\ 

\hline 
\end{tabular}
\caption{Medidas de tempo do Trading System com atores remotos (wireless).}
\label{tab:medidas-lentas}
\end{scriptsize}
\end{center}
\end{table}

O gráfico da figura \ref{fig:grafico-er-lento} mostra que, com o aumento de atores clientes, a
quantidade de envios e respostas obtida com nossa implementação não teve a mesma melhora que a obtida
com o Netty. Uma melhora mais significativa acontece somente quando a 
quantidade de clientes passa de $10$. Se observamos novamente o gráfico da figura \ref{fig:grafico-er}, 
notamos que o aumento no número de envios e respostas foi mais acentuado no início (de $1$ a $8$ atores clientes) 
quando o sistema ainda não tinha atingido a saturação.

\begin{figure}[!h]
		\centering
		\includegraphics[scale=.70]{grafico-er-lento} 
 		\caption{Comparação da quantidade de envios e respostas na rede wireless.}
  		\label{fig:grafico-er-lento}
\end{figure}

Argumentamos que, na rede com maior latência, o sistema não conseguiu chegar próximo a seu ponto de saturação.
Nosso argumento é baseado na comparação dos valores de envios e respostas por segundo entre os experimentos com $1$ e $2$ 
atores clientes da tabela \ref{tab:medidas} e os experimentos com $10$ e $80$ clientes mostrados 
na tabela \ref{tab:medidas-lentas}. 

Se verificarmos o valor da tabela \ref{tab:medidas} para experimentos com Netty e $1$ ator cliente, 
temos $501$ envios e respostas por segundo. Na rede com maior latência, só obtemos esse fluxo de mensagens com o Netty
quando passamos de $8$ para $10$ atores clientes e o fluxo aumenta de $491$ para $559$
envios e respostas por segundo, como mostra a tabela \ref{tab:medidas-lentas}. Quando passamos para $2$ atores
clientes, temos $894$ envios e respostas na tabela \ref{tab:medidas}. Esse fluxo com o Netty
só é aproximado na rede com maior latência quando utilizamos $80$ clientes. Nesse caso temos $889$ envios e respostas
por segundo.

Analogamente, se verificarmos o valor da tabela \ref{tab:medidas} para experimentos com AMQP e $1$ ator cliente, 
temos $263$ envios e respostas por segundo. Na rede com maior latência, esse fluxo de mensagens via AMQP só é aproximado 
quando utilizamos $10$ atores clientes, caso em que temos $243$ envios e respostas por segundo na tabela
\ref{tab:medidas-lentas}. Quando passamos para $2$ atores
clientes, o fluxo com AMQP aumenta para $528$ (tabela \ref{tab:medidas}). Na rede com maior latência,
esse fluxo com AMQP só é obtido quando utilizamos $80$ clientes. Nesse caso temos $628$
envios e respostas por segundo.

Com base na variação da quantidade de envios e respostas por segundo, nossa conclusão é de que o número de atores clientes
utilizados na rede com maior latência não foi suficiente para fazer com que o sistema chegasse próximo
a seu ponto de saturação. Ao contrário, na rede com maior latência, o sistema teve um fluxo
próximo ao obtido nos experimentos com $1$ e $2$ clientes na rede com
menor latência. Em outras palavras, nosso entendimento é que, sob o ponto de vista do fluxo de envios e respostas, 
o trecho de $10$ a $80$
clientes do gráfico da figura \ref{fig:grafico-er-lento} corresponde ao trecho de
$1$ a $2$ clientes do gráfico da figura \ref{fig:grafico-er}. A figura
\ref{fig:grafico-er-lento-e-normal} ilustra esse fato.

\begin{figure}[!h]
		\centering
		\includegraphics[scale=.70]{grafico-er-lento-e-normal} 
 		\caption{Fluxos nas redes de alta e de baixa latência.}
  		\label{fig:grafico-er-lento-e-normal}
\end{figure}

Concluímos que existe uma vantagem relativa da nossa implementação
para transporte de mensagens entre atores remotos com padrão AMQP em relação a implementação original do
Akka feita com o Netty. Ainda que exista um processamento extra a cargo do \english{message broker} para receber, 
rotear e entregar as mensagens, tal vantagem deve-se ao fato do Netty também possuir tarefas semelhantes, e desse
processamento acontecer nos mesmos nós onde estão em execução as classes que fazem
o processamento das mensagens, como os atores. Vimos na figura \ref{fig:grafico-er} que, conforme o fluxo das 
mensagens foi aumentando e o sistema foi chegando ao seu ponto de saturação, houve uma redução considerável na diferença de tempo entre as execuções com Netty e AMQP. Assim, entendemos que a carga extra de processamento adicionada pelo \english{message broker} não invalida o seu uso como suporte para a troca de mensagens entre atores remotos. 
Enfatizamos que em muitos cenários realistas espera-se que um sistema de atores tenha um alto número de atores clientes.
