\chapter{Exemplo de uma aplicação com RabbitMQ}
\label{ape:sample-amqp}

Apresentamos neste apêndice um exemplo de uma aplicação produtora e de uma aplicação
consumidora escrito em Scala com a biblioteca para clientes Java do RabbitMQ.
A listagem \ref{lst:common-amqp} mostra a configuração da fábrica de conexões e alguns
valores, como nome dos objetos e suas configurações, que são compartilhados entre as 
implementações de produtor e consumidor de mensagens.
		
\begin{lstlisting}[frame=tb, caption={Feição CommonAMQP.}, label={lst:common-amqp}]
trait CommonAMQP {

  val EXCHANGE_NAME  = "sample.exchange"
  val QUEUE_NAME     = "sample.queue"
  val BINDING_KEY    = "key.to.sample.queue"
  val EXCHANGE_TYPE  = "direct"
  val AUTO_ACK       = true
  val NOT_EXCLUSIVE  = false
  val NOT_DURABLE    = false
  val NOT_AUTODELETE = false
  val QUEUE_ARGS     = null
  val BASIC_PROPS    = null

  private lazy val factory = {
    val _factory = new ConnectionFactory()
    _factory.setHost("localhost")
    _factory.setPort(5672)
    _factory.setUsername("anUser")
    _factory.setPassword("t0psecr3t")
    _factory.setVirtualHost("/amqp-sample")
    _factory
  }

  def connect: Connection = {
    factory.newConnection
  }
}		
\end{lstlisting}
	
	Para o nosso exemplo optamos por criar a classe \lstinline{SampleProducer} para 
	encapsular a criação dos objetos no \english{broker} e o envio das mensagens. 
	A classe é apresentada na listagem \ref{lst:producer}. O método \lstinline{startProducer}
	se conecta ao servidor AMQP na linha $6$, e abre um canal na linha $7$ para interagir 
	com a camada de sessão. Nas linhas seguintes, o método declara uma \english{exhange}\footnote{
	Caso o objeto já exista, um novo não será criado. Caso o objeto existente possua 
	uma configuração diferente, uma exceção é lançada.} direta e transiente, uma fila pública, 
	transiente e temporária e faz o \english{binding} de ambos. O método \lstinline{publish}, por 
	sua vez, verifica logo na sua primeira linha se o estado da instância é válido e, em 
	seguida, itera na sequência de mensagens fazendo o envio. Para esse exemplo em particular, 
	omitimos as propriedades adicionais (\lstinline{BASIC\_PROPS}) que podem ser utilizadas no 
	envio. Exemplos dessas propriedades são definir a prioridade da mensagem, especificar um 
	remetente diferente para resposta (\english{replyTo}) e definir uma data para expiração 
	da mensagem.
		
	\begin{lstlisting}[frame=tb, caption={Classe SampleProducer.}, label={lst:producer}]
class SampleProducer extends CommonAMQP {
  private var connection: Connection = _
  private var channel: Channel = _

  def startProducer: SampleProducer = {
    connection = this.connect
    channel = connection.createChannel
    channel.exchangeDeclare(EXCHANGE_NAME, EXCHANGE_TYPE)
    channel.queueDeclare(QUEUE_NAME, NOT_DURABLE, NOT_EXCLUSIVE, NOT_AUTODELETE, QUEUE_ARGS)
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, BINDING_KEY)
    this
  }

  def publish(messages: Seq[String]) = {
    require(channel != null)
    messages.foreach{
      message => channel.basicPublish(EXCHANGE_NAME, BINDING_KEY, BASIC_PROPS, message.getBytes)
    }
  }

  def stopProducer = {    
    connection.close
  }
}	 
	\end{lstlisting}
	
	A listagem \ref{lst:producer-app} mostra a aplicação que faz uso da classe 
	\lstinline{SampleProducer}. Nessa listagem fazemos a instanciação e a inicialização
	de um \lstinline{producer}, geramos uma sequência com $100$ mensagens e as
	repassamos para o envio. Por fim, encerramos a conexão e implicitamente canais que 
	tenham sido abertos junto a ela.
	
	\begin{lstlisting}[frame=tb, caption={Aplicação SampleProducerApplication.}, label={lst:producer-app}]
object SampleProducerApplication  extends Application {
  val producer = new SampleProducer
  println("Inicializando SampleProducer")
  producer.startProducer
  val messages = for(i <- 1 to 100) yield "A string message #%d".format(i)
  println("Enviando mensagens")
  producer.publish {
    messages
  }
  println("Mensagens enviadas com sucesso")
  producer.stopProducer
}
   	\end{lstlisting}

	A abordagem tomada para exemplificar o recebimento das mensagens foi a mesma tomada para o
	envio. Criamos a classe \lstinline{SampleConsumer} para encapsular o recebimento, a 
	confirmação e tratamento das mensagens, como mostrado na listagem \ref{lst:consumer}.
	O método \lstinline{startConsumer}, assim como o método \lstinline{startProducer} mostrado
	na listagem \ref{lst:producer}, se conecta ao servidor AMQP e abre um canal para interagir
	com a camada de sessão. Em seguida, ele registra a instância corrente como um consumidor
	na fila previamente criada com confirmação implícita de recebimento. O método 
	\lstinline{handleDelivery} é o método invocado a cada mensagem recebida. Podemos
	notar que o método, além de receber o corpo da mensagem, ainda recebe algumas informações sobre
	o envio. Os demais métodos são herdados da interface \lstinline{com.rabbitmq.client.Consumer}
	e servem como notificadores para outros eventos, como registro 
	(\lstinline{handleConsumerOk}) ou cancelamento (\lstinline{handleCancelOk}) de um 
	consumidor na fila. Mais detalhes sobre a interface \lstinline{com.rabbitmq.client.Consumer}
	e de suas implementações podem ser encontradas na documentação da biblioteca para clientes Java \cite{rabbit-api}.
	
	\begin{lstlisting}[frame=tb, caption={Classe SampleConsumer.}, label={lst:consumer}]
class SampleConsumer extends Consumer with CommonAMQP {

  def startConsumer = {
    val connection = this.connect
    val channel = connection.createChannel
    channel.basicConsume(QUEUE_NAME, AUTO_ACK, this)
  }

  def handleDelivery(consumerTag: String, envelope: Envelope, properties: BasicProperties,
                     message: Array[Byte]): Unit = {
    println("Mensagem recebida: %s".format(new String(message)))
  }

  def handleShutdownSignal(consumerTag: String, ex: ShutdownSignalException): Unit = {}
  def handleRecoverOk: Unit = {}
  def handleConsumeOk(consumerTag: String): Unit = {}
  def handleCancelOk(consumerTag: String): Unit = {}
}
	\end{lstlisting}
	
	A listagem \ref{lst:consumer-app} mostra a aplicação que faz uso da classe 
	\lstinline{SampleConsumer}. 
	
	\begin{lstlisting}[frame=tb, caption={Aplicação SampleConsumerApplication.}, label={lst:consumer-app}]
object SampleConsumerApplication extends Application {
  val consumer = new SampleConsumer
  println("Inicializando SampleConsumer e recebendo mensagens")
  consumer.startConsumer
}
\end{lstlisting}
