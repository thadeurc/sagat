%% ------------------------------------------------------------------------- %%
\chapter{Conclusões}
\label{cap:conclusoes}

\section{Comparação de desempenho}
\index{Atores Remotos com AMQP!comparação de desempenho}
\label{sec:atores_remotos_amqp:analise_de_desempenho}

Com o intuito de medir como novas alterações no código da biblioteca de atores melhoravam o desempenho, 
os desenvolvedores do projeto Akka criaram um sistema que simula a compra e venda de ações
chamado de \english{Trading System}. Os desenvolvedores criaram também algumas classes que cuidam do armazenamento, 
comparação e geração de relatórios dos dados coletados nos testes de desempenho.

\subsection{Trading System}
\index{Atores Remotos com AMQP!comparação de desempenho!Trading System}
\label{sec:atores_remotos_amqp:trading_system}

A disposição dos componentes do sistema de cotações é mostrados na figura \ref{fig:trading-system}.
Os componentes são descritos a seguir:

\begin{itemize}
	\item \english{Order Book}: É uma entidade que possui informações sobre as
	ordens de compra e venda de uma determinada ação. Neste sistema, uma ação
	é composta por uma letra e por um número. É responsável
	por fazer o casamento de uma ordem de venda com uma ordem de compra.
	É utilizado como nomes de ações as letras A, B e C, combinadas com
	números de $1$ a $5$, num total de quinze \english{order books};

	\item \english{Matching Engine}: É um ator que age como intermediário 
	no encaminhamento de mensagens aos \english{order books}. Existe um \english{matching engine}
	para cada letra de \english{order book};

	\item \english{Order Receiver}: É um ator externo que tem o papel de receber
	mensagens de compra e venda de qualquer ação, encontrar o \english{matching engine}
	responsavél e repassar a mensagem. A quantidade de \english{order receivers} não possui
	relação com \english{matching engines}, já que um \english{order receiver} recebe
	mensagens para qualquer tipo de ação. O sistema possui dez \english{order receivers};

	\item \english{Trading System}: É o ator recepcionista do sistema e é responsável
	por fazer a criação e inicialização dos atores internos do sistema. Este ator ainda
	responde a atores clientes os endereços (referências) dos \english{order receivers}
	que foram criados;

	\item \english{Order}: É um componente que não é mostrado na figura e que representa
	uma ordem. É definida em uma classe abstrata e possui como informações o código da ação, o volume e o valor. 
	Suas implementações são \english{Ask} para indicar uma ordem de venda, e \english{Bid} para indicar uma 
	ordem de compra;
\end{itemize}

\begin{figure}[!h]
		\centering
		\includegraphics[scale=.70]{trading-system} 
 		\caption{Trading System -- Sistema de compra e vendas de ações.}
  		\label{fig:trading-system}
\end{figure}

Existe ainda atores rotulados como ``clientes''. Um ator cliente é um ator externo ao 
sistema de cotações que possui uma lista de ordens a serem enviadas, um valor inteiro
indicando a quantidade de repetições a serem executadas na lista
e um \english{order receiver} para onde as mensagens devem ser enviadas.
A quantidade de atores cliente varia de acordo com a instância do teste que
se deseja fazer. A quantidade não será necessariamente igual à quantidade de \english{order receivers}.
Por este motivo, a associação de um ator cliente a um \english{order receiver} é feita em sequência. 
Itera-se na lista de \english{order receivers} junto com a lista de atores clientes.
Uma vez que se tenha alcançado o décimo \english{order receiver}, reinicia-se a iteração a partir do
primeiro ator. Depedendo a quantidade de atores clientes, alguns \english{order receivers}
podem recebem mensagens de mais, de menos ou até mesmo de nenhum ator cliente quando comparados com
outros \english{order receivers}.

Cada ator cliente envia um total de trinta ordens (quinze ordens de compra e quinze ordenrs de venda)
para o \english{order receiver} que lhe foi associado. Este valor é multiplicado pela quantidade
de repetições que o ator cliente deve executar. A medição é feita com base no tempo que uma mensagem 
enviada por um ator cliente levou para ser processada em um \english{order book}.

\subsubsection{Trading System com atores remotos}
\index{Atores Remotos com AMQP!comparação de desempenho!Trading System!remoto}
\label{sec:atores_remotos_amqp:trading_system_remoto}

Ainda que o \english{Trading System} não tenha sido criado para testes com atores remotos, 
consideramos ser de grande utilidade utilizá-lo para fazer uma comparação de desempenho
entre o suporte padrão a atores remotos do Akka com o que desenvolvemos. Para tal,
foram necessárias as alterações listadas a seguir:

\begin{enumerate}
	\item Registramos todos os atores que estão posicionados na área rotulada como ``Atores Externos''
	na figura \ref{fig:trading-system}, como atores remotos (seção \ref{sec:atores_remotos_akka}).
	Essa modificação resultou em alterações na inicialização do \english{Trading System} e na obtenção
	dos \english{order receivers}. Na versão remota, apenas os nomes sob o qual foram registrados
	no registro de atores remotos é devolvido. Na versão local, são devolvidas \lstinline$ActorRefs$.
	Evitamos devolver \lstinline$ActorRefs$ como parte das mensagens pois, neste caso, os atores deveriam
	passar por uma seriação funda. Enviando os nomes sob os quais os atores foram registrados, permite que
	façamos buscas no registro de atores remotos, trabalhando apenas com as referências remotas;	

	\item Fizemos com que as classes \english{Ask} e \english{Bid} fossem seriáveis 
	(seção \ref{sec:atores_remotos_akka_seriacao}). Optamos por utilizar como formato de seriação, 
	o formato definido na \english{trait} \lstinline$ScalaJSON$;

	\item Trocamos os envios assíncronos de mensagens por envios síncronos (\lstinline{!!})
	nos atores cliente. Assim, uma nova mensagem só é enviada uma vez que a mensagem anterior
	tenha sido processada e sua confirmação recebida no ator cliente. O comportamento de um ator
	cliente teve uma pequena alteração: para cada mensagem enviada, o ator cliente marca o momento de início
	do envio da mensagen, aguarda o valor devolvido pelo método \lstinline{!!} 
	(que é invocado no \english{order receiver}), marca o tempo de término do envio e salva a 
	diferença de tempo em um repositório.
\end{enumerate}

As configurações utilizadas no arquivo \lstinline$akka.conf$ para os testes com o suporte padrão
a atores remotos do Akka são as recomendadas uso geral (compressão média de mensagens e tamanho
do janelamento das mensagens de $1$KB). Nos testes executados com o suporte desenvolvido neste trabalho,
utilizamos uma conexão por canal além da configuração \lstinline$DURABLE$ para as pontes AMQP 
(seção \ref{sec:entidades-via-broker-amqp-bridges}).

Para que pudessemos tem medidas mais reais, separamos os atores clientes e os atores do
\english{Trading System} em JVMs residentes em nós fisicamente separados. A máquina
virtual Erlang, onde o RabbitMQ esteve em execução, ficou separada em um terceiro nó.
A máquina virtual Erlang, responsável por executar o RabbitMQ, ficou em execução em
um \english{laptop} Dell Inspirion N4030 com processador Intel Core i3 de $2.4$ GHz e $4$ GB de RAM
com Linux Ubuntu $10.10$. A JVM onde implantamos os atores cliente, ficou em execução
em um \english{laptop} Lenovo T410 com processador Intel Core i5 de $2.4$ GHz e $4$ GB de RAM
com Linux Ubuntu $10.10$. Por fim, a JVM onde o \english{Trading System} foi implantado, ficou
em execução em um \english{laptop} MacBook Pro com processador Core $2$ Duo de $2.4$ GHz e $4$ GB de RAM
com Mac OS X $10.7$. Os três \english{laptops} foram conectados por um roteador D-Link DI-$524$.
Apesar de este ser um roteador para redes sem fio, optamos por conectá-los com cabos de rede.

\subsection{Resultados}

Definimos o número de mensagens que cada cliente enviou da seguinte maneira: seja $n_c$ a 
quantidade de atores cliente utilizada no teste e seja $r$ o número de repetições; cada ator cliente 
enviou $30 (\lfloor r/n_c \rfloor)$ mensagens. O valor $r$ de repetições definido foi $1000$. 
Variamos os valores de $n_c$ de modo que o resultado da divisão fosse sempre inteiro. O total 
de mensagens enviadas por todos os atores cliente em uma instância de teste foi sempre $30000$. 

A estrutura criada para medição e comparação de desempenho de atores locais do Akka
utiliza algumas bibliotecas para o armazenamento e geração de relatórios. Os valores
das medidas registradas em uma instância de teste são organizados em percentis. 
A biblioteca utilizada para o cálculo de percentis é a Commons Math da fundação Apache \cite{commons-math}.
Os relatórios gerados apresentam também a quantidade de envios/respostas por segundo (ER/S),
o tempo médio de cada envio/resposta e ainda o tempo total gasto para a execução de
todos os envios/recebimentos. 

A tabela \ref{tab:medidas} mostra as melhores medidas dentre todas as execuções
feitas na execução do \english{Trading System} com atores remotos. O critério
utilizado para a comparação entre as medidas de um mesmo conjunto de instâncias
foi o valor que é apresentado na coluna média.

\renewcommand{\arraystretch}{0.85}
\captionsetup{margin=1.0cm}
\begin{table}
\begin{center}
\begin{small}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|} 
\hline

{Impl.} & {Clientes} & {ER/S} & {Média ($\mu s$)} & {25\% ($\mu s$)} & {50\% ($\mu s$)} & {75\% ($\mu s$)} & 
{95\% ($\mu s$)} & {Dur. ($s$)} \\ \hline \hline
Netty & 1 & 501 &  1995 & 1364 & 1433 & 1968 & 3266 & 59.85 \\
AMQP  & 1 & 263 &  3797 & 3283 & 3361 & 3537 & 4550 & 113.91 \\ \hline
 & Delta & -47.50\% & 90.33\%  &  140.69\% &  134.54\% &  79.73\% &  39.31\% &  54.06 (90.33\%) \\ \hline
									
Netty & 2 & 894 & 1119 & 885 & 898 & 918 & 1645 & 33.57 \\
AMQP  & 2 & 528 & 1894.5 & 1617 & 1679.5 & 1776 & 2104 & 56.835 \\ \hline
 & Delta & -40.99\% &  69.30\% &   82.71\% &  87.03\% &  93.46\% &  27.90\% &  23.26 (69.33\%) \\ \hline

Netty & 4 & 1245 & 893 & 517.5 & 629.25 & 618.5 & 1053.5 & 24.09 \\
AMQP  & 4 &  906 & 1104 & 812 & 903.5 & 1033.5 & 1272 & 33.12 \\ \hline
 & Delta  & -27.31\% &  37.48\% &  56.91\% &  43.58\% &  51.65\% &  20.74\% &  9.03 (37.48\%) \\ \hline

Netty & 8 & 1494 & 669.125 & 409.25 & 471.375 & 593.125 & 771 & 20.07 \\
AMQP & 8 & 1389 & 720 & 445.875 & 518.625 & 646 & 803.125 & 21.60 \\ \hline
 & Delta & -7.10\% &  7.60\% &  8.95\% &  10.02\% &  8.91\% &  4.17\% &   1.52 (7.60\%) \\ \hline

Netty & 10 & 1542 & 648.4 & 400.5 & 433 & 570.4 & 704.1 & 19.45 \\
AMQP & 10 & 1424 & 702.3 & 439.6 & 510.7 & 613.6 & 761 & 21.06 \\ \hline
 & Delta & -7.72\% &  8.31\% &   9.76\% &  17.94\% &  7.57\% &  8.08\% &  1.61 (8.31\%) \\ \hline

Netty & 20 & 1568 & 637.85 & 410.3 & 482.3 & 507.3 & 600.75 & 19.13 \\
AMQP & 20 & 1503 & 665.45 & 436.4 & 498.2 & 544.4 & 671.5 & 19.96 \\ \hline
 & Delta & -4.15\% &  4.33\% &   6.36\% &  3.30\% &  7.31\% &  11.78\% &  0.82 (4.33\%) \\ \hline

Netty & 40 & 1589 & 629.4 & 440.4 & 454.57 & 485.9 & 533.75 & 18.82 \\
AMQP & 40 & 1518 & 658.62 & 462.4 & 488.12 & 521.05 & 584 & 19.75 \\ \hline
& Delta & -4.41\% &  4.64\% &   5.00\% &  7.38\% &  7.23\% &  9.41\% &  0.87 (4.64\%) \\ \hline 

Netty & 80 & 1615 & 619.06 & 442.53 & 456.76 & 473.28 & 500.51 & 18.57 \\
AMQP & 80 & 1535 & 651.52 & 473.93 & 492.48 & 511.78 & 543.7 & 19.54 \\ \hline
 & Delta & -5.02\% & 5.24\% &  7.10\% & 7.82\% & 8.13\% & 8.63\% & 0.97 (5.24\%) \\

\hline 
\end{tabular}
\caption{Medidas de tempo do Trading System com atores remotos.}
\label{tab:medidas}
\end{small}
\end{center}
\end{table}

O fato de adicionarmos um terceiro nó com um \english{message broker} na comunicação
entre os atores remotos, naturalmente adiciona mais passagens pela rede que conecta os nós.
Um envio que utiliza o Netty faz com que duas mensagens trafeguem pela rede: a ordem é
enviada pelo \lstinline$RemoteClient$ direto ao \lstinline$RemoteServer$ e a resposta
faz o caminho inverso. Já quando utilizamos a implementação com AMQP, quatro mensagens
são trafegadas: a ordem é enviada pelo \lstinline$RemoteClient$ ao \english{message broker},
o \english{message broker} envia a ordem para o \lstinline$RemoteServer$ e a resposta faz o caminho
inverso). Por este motivo, esperávamos que o tempo gasto pela implementação com AMQP fosse, 
aproximadamente, duas vezes mais do que o tempo gasto pela implementação com Netty. 
Observando a comparação dos dados da tabela \ref{tab:medidas} para a instância com apenas $1$ ator cliente, 
podemos notar uma diferença bem próxima da esperada, 
já que o número de envios/respostas por segundo é quase metade ($-47.50\%$), o valor médio 
para cada envio/resposta leva quase o dobro do tempo ($90.33\%$), fazendo com que a duração total 
também leve quase o dobro do tempo ($90.33$\%). Quando observamos os percentis, podemos notar que a 
diferença de tempo das execuções com AMQP que estão abaixo da mediana, foram mais de duas vezes mais lentas em 
relação às execuções feitas com Netty ($140.69$\% e  $134.54$\%). Entretanto, quando comparamos os 
percentis acima da mediana, observamos uma boa redução na diferença ($79.73$\% e  $39.31$\%).

Com o aumento do número de atores clientes, a diferença de tempo apresenta uma boa diminução.
O gráfico da figura \ref{fig:grafico-er} mostra a evolução da quantidade de envios/recebimentos com o aumento
da quantidade de atores cliente. Podemos observar que, conforme a quantidade de atores cliente foi aumentando, 
os resultados com nossa implementação apresentaram uma boa melhora e se mantiveram muito
próximos dos resultados obtidos com a implementação original. A diferença que era de quase $-47.50\%$ envios/recebimentos
cai até chegar em apenas $-5.02\%$, o que no nosso teste representa pouco menos de $1$ segundo para
completar todos os envios/recebimentos. De um modo geral, se observarmos a diferença do tempo de execução 
para os testes a partir de $8$ clientes, a diferença de tempo fica abaixo de $1.6$ segundos. 

Devemos relembrar que não adicionamos compressão de mensagens na implementação com AMQP, e que
os testes feitos com Netty utilizaram compressão média. Como as mensagens são 
menores que $1$KB, entendemos que a implementação com AMQP possa ter levado ligeira
vantagem. Ademais, o terceiro nó colabora para a distribuição do processamento. Na implementação
feita com Netty, tanto as classes responsáveis pelo envio e recebimento de mensagens quanto as classes
do arcabouço compartilham mesma JVM que executa as classes do sistema de cotações. 
Já na implementação com AMQP, apenas as classes responsáveis pelo envio e recebimento de mensagens 
compartilham a mesma JVM. 

\begin{figure}[!h]
		\centering
		\includegraphics[scale=.70]{grafico-er} 
 		\caption{Comparação da quantidade de envios/recebimentos.}
  		\label{fig:grafico-er}
\end{figure}

Durante a execução dos testes observamos que, mesmo diante de diversos atores clientes executando envios
em paralelo de mesmo \lstinline$RemoteClient$, não tivemos problemas comuns de concorrência como
\english{deadlocks} e condições de corrida em nossa implementação. Observamos também que em um dado
momento quando a infraestrutura de rede teve problemas de latência, nossa implementação apresentou 
resultados mais lentos, contudo, a diferença de tempo se manteve próxima de duas vezes a diferença de tempo. 
(apêndice x). Naturalmente, pelo fato de as mensagens serem trafegadas duas vezes a mais na rede, a latência
na rede é um dos maiores fatores de impacto nos resultados.

Ainda que exista um processamento extra a cargo do \english{message broker} para recebimento, roteamento
e entrega das mensagens, concluímos que existe uma vantagem relativa em relação a implementação com o JBoss Netty.
Tal vantagem deve-se ao fato do JBoss Netty também possuir tarefas semelhantes, como recebimento e entrega
das mensagens, e de este processamento acontecer nos mesmos nós onde estão em execução as classes que fazem
o processamento das mensagens, como os atores. Conforme a frequência das mensagens foi aumentando, 
houve uma redução considerável na diferença de tempo, como mostrado no gráfico da figura \ref{fig:grafico-er}.
Assim, entendemos que a carga extra de processamento adicionada pelo \english{message broker}, não invalida
o seu uso como suporte para a troca de mensagens entre atores remotos. Enfatizamos que em um cenário realista
de um sistema de atores, é esperado um número razoável de atores executando em paralelo.

Comentamos brevemente no capítulo \ref{cap:estrutura-troca-mensagens-amqp} sobre algumas das características
da trocas de mensagens entre entidades conectadas ponto-a-ponto via \english{sockets}, como saber o endereço
do \english{host} e porta da outra parte no qual se está conectado, a possibilidade de identificar se a outra 
parte continua conectada e o não armazenamento intermediário de mensagens.  Na implementação feita com o JBoss Netty
pelo Akka, a biblioteca do Netty fornece meios para obter informações tanto sobre o endereço da outra parte,
como ser notificado em caso de falhas na conexão. O fato de utilizarmos 
filas para fazer o armazenamento intermediário das mensagens (ainda que, na maior parte do tempo, por um período 
breve), permite que um \lstinline$RemoteServer$ ou \lstinline$RemoteClient$ possam receber mensagens mesmo
não após sua execução ter sido interrompida. Basta que eles tenham executado alguma vez com uma configuração
durável\footnote{O mesmo vale para configurações transientes, desde que o \english{message broker} não tenha
sido reiniciado}. As mensagens ficam armazenadas até que um novo consumidor seja registrado. Um detalhe importante
a se destacar é em relação a \english{exchange} não existir no momento do envio. Em casos como este, quem está
fazendo o envio recebe uma exceção no mesmo momento que está tentando fazer o envio. Mensagens que foram
armazenadas, por exemplo, porque o \lstinline$RemoteServer$ ou \lstinline$RemoteClient$ não estavam
em execução para fazer o encaminhamento para o ator podem deixar de ter o mesmo significado para o ator,
passando até mesmo a serem desconhecidas para o comportamento do ator no momento do seu processamento.
Assim como o modelo de atores não preve a ordem de entrega das mensagens, deixando a cargo das aplicações
que utilizam o modelo fazer o tratamento, o recebimento de mensagens que ficaram armazenadas é uma situação
que leva a um cenário semelhante, deixando também a cargo da aplicação a responsabilidade sobre o processamento
de tais mensagens. Mensagens enviadas de forma síncrona para atores remotos que não estão acessíveis, causam
estouro no tempo limite de espera no resultado futuro. Uma eventual resposta do ator remoto após o tempo limite,
não causa erros. Do modo como está a implementação, o mapa de resultados futuros (seção \ref{subsec:akka_envio_resposta})
mantém as referências para os resultados até que eles sejam completados.

O uso do \english{message broker} como ponto central de comunicação de todos os atores remotos, cria um
ponto crítico para o caso de falhas. Caso o nó onde o \english{message broker} está em execução sofra alguma
avaria, a comunicação de todos os atores remotos é afetada. O RabbitMQ pode ser configurado para
em um grupo lógico de um ou mais nós Erlang (\english{cluster} \cite{rabbitmq-cluster}), onde os nós 
compartilham as informações dos \english{virtual hosts}. O uso do RabbitMQ em \english{cluster} elimina
o problema de um ponto central de falhas.

%------------------------------------------------------
\section{Considerações Finais} 

O uso do RabbitMQ como \english{message broker} AMQP em conjunto com a estrutura descrita no capítulo
\ref{cap:estrutura-troca-mensagens-amqp}, se mostrou eficaz nos nossos testes para transportar mensagens
entre atores remotos. Entendemos que existe uma boa sinergia entre as duas classes de p

O uso de um \english{message broker} ainda trás outros benefícios, como poder analis. 
%% falar das ferramentas administrativas, cluster do broker, e comecar a comentar do cloud

%------------------------------------------------------
\section{Sugestões para Pesquisas Futuras} 



falar de melhorias na parte de exceptions, colocar no akka 2.0 como sip. Cloud.