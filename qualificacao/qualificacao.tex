\documentclass[titlepage,11pt,letterpaper,abstracton]{scrartcl}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{cite}
\usepackage{url}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{graphicx,url}
\usepackage{epsfig}
\usepackage{float}

\setlength{\topmargin}{0.5in}
\setlength{\oddsidemargin}{0in}%{0.3in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8in}
\setlength{\parindent}{0.4in}

\floatstyle{ruled}
\newfloat{listing}{thp}{}[section]
\floatname{listing}{Listagem}
\newcounter{sublisting}
\newcounter{sublisting@save}

% Ajusta o cabeçalho e o rodapé.
\pagestyle{fancy}
\lhead{DCC - IME - USP}
\chead{}
\rhead{\textbf{Proposta de Dissertação -- Mestrado}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\setlength{\headheight}{13.6pt}

\newlength{\fmwidth}
\setlength{\fmwidth}{\textwidth}
\addtolength{\fmwidth}{-.1in}

% Algumas macros.
\newsavebox{\fmbox}
\newenvironment{fmpage}[0]
    {\begin{lrbox}{\fmbox}\begin{minipage}{\fmwidth}}
    {\end{minipage}\end{lrbox}\vspace{2em}\noindent\fbox{\usebox{\fmbox}}\vspace{2em}}

\newcommand{\code}[1]
    {\texttt{#1}}

\newcommand{\accentuate}[1]
    {\textsf{#1}}

\newcommand{\entry}[1]
    {\textit{#1}}

\newcommand{\english}[1]
    {\textit{#1}}



\begin{document}

\begin{titlepage}

  \begin{center}
    \rule{\textwidth}{1pt} \\[3mm]
    \textbf{\LARGE Universidade de São Paulo} \\[5mm]
    \textbf{\Large Instituto de Matemática e Estatística} \\[3mm]
    \textbf{\Large Departamento de Ciência da Computação} \\[3mm]
    \rule{\textwidth}{1pt} \\[30mm]
    
    \textbf{\textsf{\LARGE AMQP para o Transporte de Mensagens entre Atores Remotos}}
    \\[10mm]
    \textbf{\Large Exame de Qualificação de Mestrado} \\[20mm]
    {\large São Paulo, XX de XXXXX de 2010}\\[10mm]
    \rule{\textwidth}{1pt}\\[7mm]

    \textsf{\Large Thadeu de Russo e Carmo}\\[10mm]
    \textsc{\Large Orientador:}\\[5mm]
    \textsf{\Large Francisco Carlos da Rocha Reverbel}\\[5mm]
    \rule{\textwidth}{1pt}\\[5mm]
   \end{center}

\end{titlepage}


\pagenumbering{roman}
\begin{abstract}
 	%\par Modelar sistemas computacionais especificando tarefas que podem acontecer de maneira independente, 
	%em paralelo, e concorrentemente é algo extremamente comum, especialmente quando se busca desempenho. 
	\par Processadores com múltiplos núcleos se mostraram um alternativa para os limites impostos pela física
	para a construção de processadores com maior velocidade de \english{clock}. Para que programas possam usufruir
	dos ganhos de desempenho deste tipo de processador eles devem ser escritos de maneira concorrente, 
        uma tarefa não trivial.	
	
	\par O modelo de atores com troca de mensagens foi proposto como uma das possíveis soluções para problemas 
	oriundos da programação concorrente, as dificuldades no uso de travas e blocos sincronizados para a proteção de dados 
	compartilhados. Atores são entidades computacionais conhecidos por especificar o endereço de sua caixa de correio e 
        seu comportamento. Mensagens enviadas por outros atores são armazenadas na caixa de correio e processadas de maneira
        assíncrona.

	\par Neste trabalho estudaremos o modelo de atores em um ambiente com instâncias distribuídas entre várias
	máquinas virtuais Java. Faremos uma implementação em Scala tomando como base a abordagem proposta no projeto Akka, 
	substituindo o uso de \english{sockets} para o tráfego das mensagens, pelo padrão aberto de
	\english{middleware} orientado a mensagens, \english{Advanced Message Queuing Protocol}, ou AMQP. 
	Além disso, faremos também uma avaliação comparativa entre o uso das duas implementações.
 

\end{abstract}

\tableofcontents
\newpage

\pagenumbering{arabic}

\normalsize
\onehalfspacing


% ----------------------------------------------------------------------
\newpage
\section{Introdução}	
	Em $1965$, após fazer uma análise da relação da quantidade de componentes de circuito integrado
	desenvolvidos entre os anos de $1959$ e $1964$, Gordon Moore tentou prever uma tendência para o crescimento observado. 
        Considerando os dados observados até $1975$, Moore fez uma projeção onde a quantidade de componentes teria um crescimento exponencial
        a cada ano. 
        Em $1975$, após notados os avanços na produção e desenvolvimento de microprocessadores, e com dados mais atualizados, a razão foi
	revista e reduzida a um crescimento exponencial a cada dois anos. Essa previsão se confirmou e ficou conhecida como a
	Lei de Moore, sendo um dos princípios que ajuda a indústria de semi-condutores\cite{moore-1965}.
	
	\par Durante anos, fabricantes de processadores conseguiram ganhos de desempenho em três áreas principais: \entry{(i)}
	aumento da velocidade do \english{clock}; \entry{(ii)} otimização de execução; \entry{(iii)} uso de memória auxiliar
	(\english{cache}). Uma consequência direta aumento de velocidade em qualquer uma destas três áreas é o aumento da velocidade
	de execução de programas, tanto sequenciais como concorrentes. O aumento da velocidade de \english{clock} passou a
	não acompanhar mais o aumento de transitores em processadores por questões físicas, como  aquecimento e dissipação,
	alto consumo de energia e vazamento de corrente elétrica. Por conta das limitações físicas, as buscas por ganhos
	de velocidade de processamento se voltaram para três áreas: \entry{(i)} 
	\english{Hyperthreading}, onde duas ou mais \english{threads} são executadas ao mesmo tempo em uma CPU;
	\entry{(ii)} \english{Multicore}, onde um chip contém mais de uma CPU; \entry{(iii)} Aumento de memória auxiliar (\english{cache}). 
	
        \par Um dos principais impactos das novas buscas no desenvolvimento de programas está diretamente relacionado a forma em que 
        os programas são escritos. Para usufruir dos ganhos de desempenho dos novos processadores, programas precisam ser escritos de forma 
        concorrente\cite{sutter-free-lunch-is-over}, algo que não é uma tarefa simples, dado que muitas das linguagens de programação não são
	adequadas para transformar programas sequênciais em concorrentes\cite{sutter-concurrent-revolution}.
	

	\par A abordagem convencional no desenvolvimento deste tipo de programa é via uso de travas e variáveis condicionais. 
	Em linguagens orientadas a objetos como Java e C\#, cada instância possui implicitamente sua própria trava e 
	travamentos podem acontecer em blocos sincronizados dentro de métodos. Essa abordagem, contudo, não permite a componibilidade 
	de travas de maneira segura criando uma situação propensa a \english{deadlocks}. 
        A componibilidade de travas é necessária quando existe mais de uma instância envolvida na ação a ser executada de modo exclusivo. 
        Existem ainda outras dificuldades no uso de travas, 
	como esquecimento de se obter a trava de alguma instância, obtenção excessiva de travas, obtenção de travas de instâncias	 
	erradas, obtenção de travas em ordem errada, manutenção da consistência do sistema na presença de erros, 
	esquecimento de sinalização em variáveis de condição ou de se testar novamente uma condição após o despertar
	de um estado de espera\cite{sj:bc}. Estas dificuldades são alguns exemplos da inviabilidade desta abordagem para uma programação modular, 
        ou seja, criação de grandes programas por vários programas menores.
	
	\par Duas abordagens para os problemas citados são a memória transacional, uma abstração para compartilhamento 
	seguro de uma mesma região de memória, e o uso do modelo de atores, baseado na troca assíncrona de mensagens entre processos. 
	
	\par Conhecida como STM\cite{STM} (\english{Software Transactional Memory}), é um mecanismo de controle de
	concorrência análogo às transações de bancos de dados para o controle de acesso à memória compartilhada. Neste contexto, 
	a transação é um pedaço de código que executa uma série de operações atômicas de leitura e escrita na memória compartilhada. 
        
        \par Atores são definidos\cite{gul-agha} como sendo agentes computacionais que especificam um endereço para sua caixa de
        correio e seu comportamento.
        Uma vez que o endereço da caixa de correio de um ator seja conhecido, mensagens podem ser adicionadas na sua fila para processamento
        assíncrono, o que desacopla o envio do processamento. Mensagens recebidas por atores são mapeadas em uma $3$-tupla consistindo de:
        \entry{(i)} Um conjunto finito de mensagens enviadas para outros atores onde o endereço é conhecido (incluindo o próprio);
        \entry{(ii)} Um novo comportamento a ser usado para processar a mensagem seguinte; 
        \entry{(iii)} Um conjunto finito de novos atores criados. A implementação do modelo de atores com o uso do casamento de padrões,
        usado na verificação das mensagens a serem aceitas, mostraram resultados muito efetivos na linguagem Erlang\cite{erlang-survey}.

	\par A linguagem Scala possui embutida em sua distribuição uma implementação de atores chamada de \english{Scala Actors}. Esta
	implementação possui suporte tanto para atores locais, quanto para atores remotos. Existem 
	ainda algumas implementações alternativas na linguagem do modelo de atores, como por exemplo o projeto Akka\cite{akka},
	originado pelo descontinuado Scala OTP, cujo objetivo era de se portar as idéias de Erlang OTP\cite{prog-erlang} para a linguagem Scala.


	\par Pode-se notar uma sinergia entre o modelo de atores e \english{middlewares} orientados a mensagens. Conhecidos como MOMs,
        trabalham com a troca assíncrona de mensagens, assim como o modelo de atores.
	As mensagens enviadas são armazenadas em filas, sendo mantidas até que o destinatário esteja pronto para fazer o
	recebimento e processamento.      
        Os termos produtor e consumidor podem ser entendidos tanto como cliente e servidor ou o contrário, já que da perspectiva
        do MOM não existe o conceito de cliente e servidor como em sistemas baseados em \english{Remote Procedure Call} (RPC). 
        A diferença entre cliente e servidor é conceitual e pode, somente ser definida, por humanos que conhecem a semântica da 
        troca das mensagens. Apesar de quando comparado com formas de interações distribuídas baseadas em RPC, MOMs não apresentarem benefícios
        particulares, MOMs formam a base para simplificar o desenvolvimento de sistemas, permitindo interoperabilidade, 
        e suporte para gerenciamento de erros no caso de falhas. MOMs são frequentemente apresentados como uma tecnologia que pode 
        mudar a maneira com que sistemas distribuídos são construídos\cite{alonso}. 
        
        \par A garantia da entrega de mensagens é uma das características mais importantes de MOMs, estando relacionada 
        com a robustez diante de erros e falhas. Filas transacionais são uma abstração usada para garantir que, 
        uma vez que uma mensagem tenha sido recebida pelo MOM, 
        está possa ser salva em algum mecanismo de persistência, sendo removida somente após a confirmação da entrega. 
        Caso o sistema falhe, uma vez que ele seja reiniciado, as mensagens
        que não foram confirmadas como entregues e foram salvas no momento do seu recebimento podem ser entregues aos seus respectivos 
        destinatários. As retiradas de mensagens de filas transacionais podem ser feitas também de maneira atômica, onde as mensagens
        só serão removidas efetivamente da fila caso todas tenham sido retiradas com sucesso.
        
        \par \english{Middlewares} orientados a mensagem possuem a capacidade de criar ligações ponto-a-ponto entre sistemas,
        sendo um tanto quanto inflexíveis no que diz respeito ao roteamento e filtro de mensagens. \english{Message brokers} 
        são descendentes diretos dos MOMs e endereçam essas limitações pois agem como intermediários, provendo maior 
        flexibilidade para roteamento, filtro e abilidade de se adicionar lógica de negócios para o processamento
        de mensagens no nível do próprio \english{middleware}. 

        \par A especificação de Java \english{Messaging Service} (JMS) define uma biblioteca padrão para que programas
        Java possam interagir com \english{message brokers}, já que assim como  bancos de dados, os protocolos
        variam entre fabricantes. Várias implementações de \english{message brokers} são compatíveis
        com o padrão JMS. Dentre os mais conhecidos, podemos destacar JBoss Messaging\cite{jboss-messaging}, 
        IBM Websphere MQ\cite{ibm-mqseries} (mais conhecido como MQ Series) e Apache Active MQ\cite{apache-activemq}. 
        
	
	
\subsection{Objetivos}
	\par Os dois principais objetivos deste trabalho são:
	\begin{enumerate}
        \item Estudar a implementação de atores feita pelo projeto Akka.
	\item Implementação do modelo de atores remotos com o uso de AMQP para o transporte das mensagens: tomaremos 
	  como base a implementação feita pelo projeto Akka\footnote{O trabalho será desenvolvido tendo como base a última 
            versão estável disponível para \english{download} no site do projeto.} de atores remotos e substituiremos o mecanismo
	  existente para o transporte de mensagens, que atualmente é feito com o uso de \english{sockets}.
	  
	\item A comparação das duas implementações: será feito uma análise comparativa do resultado de ambas as implementações.
	  
	\end{enumerate}	
	
\subsection{Organização do texto}
	\par O restante deste texto é organizado da seguinte forma: A seção~\ref{sec:trabalhos-relacionados} apresenta trabalhos
	relacionados, a seção~\ref{sec:amqp-e-atores-mensagens} apresenta uma visão geral sobre o funcionamento de um sistema
	AMQP e o funcionamento da troca de mensagens entre atores e o fluxo de processamento, sejam eles locais ou remotos, a
	seção~\ref{sec:projeto} apresenta o projeto a ser desenvolvido, e por fim a seção~\ref{sec:cronograma} apresenta as
	atividades previstas e o cronograma para a conclusão de tais atividades.
	
% ----------------------------------------------------------------------------
\newpage
\section{Trabalhos relacionados}
\label{sec:trabalhos-relacionados}
	\par Esta seção apresenta os trabalhos relacionados que foram estudados e contribuíram para o desenvolvimento
	do nosso trabalho. Dividiremos essa seção em três partes, sendo na primeira parte a apresentação da linguagem Erlang
	e seu modelo de atores; na segunda e na terceira parte apresentaremos a linguagem Scala e o projeto Akka, com suas 
	respectivas implementações do modelo de atores.
	
\subsection{Atores em Erlang}
	\par Erlang\cite{erlang-dev} é uma linguagem funcional, com tipagem dinâmica e executada por uma máquina virtual Erlang. 
	Voltada para o desenvolvimento de sistemas distribuídos de larga escala e tempo real, foi desenvolvida 
	nos laboratórios da Ericsson no período de $1985$ à $1997$. A linguagem em si, embora bem enxuta, possui características 
	interessantes para simplificar o desenvolvimento de sistemas concorrentes. 
	Exemplos de tais características são: variáveis de atribuição única,  casamento de padrões e um conjunto de primitivas que inclui
        \english{spawn} para criação de atores, \english{send} e \english{!} para o envio de mensagens, \english{receive} 
	para o recebimento de mensagens e \english{link} para a definição de adjacências entre atores. Ademais a linguagem dá suporte
        a hierarquias de supervisão entre atores e troca quente de código (\english{hotswap}).

	\par Em Erlang, atores\footnote{Embora Erlang implemente o modelo de atores, sua literatura e suas bibliotecas não utilizam o termo 
          ``ator'' (\english{actor}). O termo utilizado é ``processo'' (\english{process}).} 
        são processos ultra leves criados dentro de uma máquina virtual. A criação, destruição e troca
	de mensagens entre atores é extremamente rápida, e como não existe compartilhamento de memória entre os atores, a única
	interação possível é via troca de mensagens. Num teste feito em um computador com $512MB$ de memória, com um
	processador de $2.4GHz$  Intel Celeron rodando Ubuntu Linux, a criação de $20000$ processos levou em
	média $3.5\mu s$ de tempo de CPU por ator e $9.2\mu s$ de tempo de relógio\cite{prog-erlang} por ator.
        
	\par Com a possibilidade de se criar uma quantidade considerável de atores, o uso de uma hierarquia de supervisão torna-se extremamente
	importante. No que diz respeito ao tratamento de erros em atores filhos, 
        as primitivas existentes na linguagem dão suporte a três abordagens:
	\entry{(i)} não se tem interesse em saber se um ator filho foi terminado normalmente ou não; \entry{(ii)} caso
	um ator filho não tenha terminado normalmente, o ator criador também é terminado; \entry{(iii)} caso um ator filho
	não tenha terminado normalmente, o ator criador é notificado e pode fazer o controle de erros da maneira que julgar mais
	apropriada. 

	\par Em Erlang é possível criar atores em nós remotos (\english{remote spawn}). Vale ressaltar que o 
	código do ator deve estar acessível na máquina virtual onde o ator irá ser executado, 
	pois não há suporte para carga remota de código. Uma vez que alguns detalhes de infra-estrutura foram observados\footnote{As 
	máquinas virtuais Erlang necessitam se autenticar umas com as outras.},
	a troca de mensagens entre atores remotos acontece de maneira transparente. No processo de envio, as mensagens trafegam
	com o uso de \english{sockets} TCP e UDP.
	
\subsection{A biblioteca de atores de Scala}
	\par Scala\cite{scala-overview} é uma linguagem moderna, com tipagem estática e que unifica os paradigmas de programação funcional e 
	orientado a objetos. Vem sendo desenvolvida desde $2001$ no laboratório de métodos de 
	programação da EPFL(\english{Ecolé Polytechnique Fédérale de Lausanne}). O código escrito em Scala pode ser compilado
	para execução tanto na JVM (\english{Java Virtual Machine}) quanto na CLR (\english{Common Language Runtime}).
	Diferentemente de Erlang, a linguagem Scala é consideravelmente extensa e possui muitos conceitos não implementados nem
	em Java e nem em C\#. Exemplos de tais conceitos são: funções de ordem superior, criação de tipos de dados algébricos
	(\english{case classes}), casamento de padrões e funções parciais.
	
	\par A implementação do modelo de atores\cite{prog-scala} não é parte da linguagem Scala, mas pode ser oferecida por bibliotecas.
        A distribuição de Scala inclui uma biblioteca de atores inspirada pelo suporte a atores em  
        Erlang\cite{erlang-dev}. Essa biblioteca oferece basicamente as funcionalidades já descritas na seção anterior. 
        Atores foram projetados como objetos baseados em \english{threads} Java e possuem métodos como \english{send}, 
        \english{!}, \english{receive}, além de outros métodos como \english{act} e \english{react}. Cada ator possui uma caixa
        de correio para o recebimento e armazenamento temporário das mensagens. O processamento de uma mensagem é feito por 
        um bloco \english{receive}, que define os padrões a serem casados com a mensagem aguardada e a ações associadas a cada padrão. 
        A primeira mensagem que casar com qualquer dos padrões é removida da caixa de correio e a ação correspondente é executada. 
        Caso não haja casamento com nenhum dos padrões, o ator é suspenso.

	%\par Existem algumas recomendações para se atingir um bom desempenho fazendo uso de \english{react} no lugar de 
        %\english{receive}, algo que proporciona o reuso das \english{threads} já criadas quando inativas\cite{prog-scala}.

	\par Além de métodos  para envio de mensagem equivalentes às primitivas de Erlang, a biblioteca de atores
        de Scala implementa métodos adicionais, que facilitam o tratamento de algumas necessidades específicas. Esses métodos
        são: \entry{(i)} \english{!?} faz envio síncrono e aguarda uma resposta dentro de um tempo limite especificado; 
        \entry{(ii)} \english{!!} faz o envio assíncrono da mensagem e recebe um resultado futuro correspondente a uma resposta. 
        
	\par O suporte a atores remotos faz parte da biblioteca, porém com algumas restrições em comparação com os atores de
	Erlang. Em Scala não é possível a criação de um ator em um nó que não seja o local, ou seja, \english{remote spawns} não são
	possíveis. Atores são acessíveis remotamente via \english{proxies}. Para obter uma referência a um ator remoto, um cliente
        faz uma busca  em um determinado nó (uma JVM identificada por um par \english{host} e porta), utilizando como chave
        o nome sob o qual o ator foi registrado.Esta abordagem, apesar de soar restritiva, evita um problema
	importante que é a necessidade de carga remota da classe do ator (\english{remote class loading}) e torna desnecessário o uso de
	interfaces remotas como em Java RMI. O trafégo das mensagens é feito via seriação padrão Java através de \english{sockets}
	TCP.
 	
\subsection{O projeto Akka}
	\par O projeto Akka\cite{akka} é composto por um conjunto de módulos escritos em Scala
        \footnote{O projeto disponibiliza também uma versão de suas APIs voltada para aplicações Java.}, 
        que implementam uma plataforma voltada para
	o desenvolvimento de aplicações escaláveis e tolerantes a falhas. Suas principais características são: uma
	nova biblioteca de atores locais e remotos, suporte a STM, hierarquias de supervisão e uma combinação entre atores e STM (\english{``transactors''})
        que da suporte a fluxos de mensagens baseados em eventos transacionais, assíncronos e componíveis. Akka oferece, ainda, uma série de módulos
        adicionais para integração com outras tecnologias.

	\par A biblioteca de atores do projeto Akka é totalmente independente da que é parte da distribuição de Scala,
	apesar de também seguir as idéias de Erlang. O comportamento dos atores Akka no recebimento de mensagens inesperadas (que não casam com
        nenhum dos padrões especificados em um \english{receive})
	é diferente dos atores de Erlang e Scala, onde o ator é suspenso. No caso de atores Akka, tais mensagens
	provocam o lançamento de exceções.
	
        \par O suporte a atores remotos do projeto Akka é bem mais completo do que o oferecido pela biblioteca de atores de Scala e será
        discutido na seção~\ref{sec:atores_remotos_akka}. Assim como a biblioteca de atores de Scala, o Akka oferece métodos
        para diferentes tipos de envio de mensagens:
	\entry{(i)} \english{!!} semelhante ao método \english{!?} da biblioteca de atores de Scala, no qual o
	remetente fica bloqueado aguardando uma resposta durante um tempo limite;
	\entry{(ii)} \english{!!!} semelhante ao método \english{!!} da biblioteca de atores de Scala, que devolve um resultado
        futuro ao remetente.

	% colocar referencias para protocolos
	\par No que diz respeito à seriação das mensagens para um ator remoto, o Akka oferece as seguintes opções: JSON, Protobuf, SBinary e seriação
	Java padrão. O transporte das mensagens é feito via TCP/IP,
	com o auxílio do JBoss Netty\cite{jboss-netty}, um arcabouço para comunicação assíncrona dirigido a eventos e baseado em 
        \english{sockets}. Este arcabouço oferece facilidades para compressão de mensagens, que são utilizados pelo Akka.
\newpage
\section{Background}
\label{sec:amqp-e-atores-mensagens}
	\par Apresentaremos a seguir o funcionamento do tráfego de mensagens entre clientes AMQP, 
	bem como o tráfego de mensagens entre atores locais e remotos. Diferentemente do protocolo AMQP e apesar de 
	bem definido, o modelo de atores não é especificado por nenhum orgão ou conjunto de empresas, devido a este motivo
	tomaremos como base a implementação do projeto Akka, por ter mostrado ser uma implementação com melhor suporte
	a atores remotos dentre as estudadas.
	
\subsection{AMQP}
	\par AMQP (\english{Advanced Message Queuing Protocol}) é um protocolo aberto 
	para sistemas corporativos de troca de mensagens. Foi criado por um conjunto de empresas (Red Hat, JPMorgan Chase, 
	Cisco Systems, entre outras), com o objetivo de viabilizar tanto o desenvolvimento quanto a disseminação de um protocolo 
        padrão para este tipo de sistema. Especificado pelo AMQP \english{Working Group}, o protocolo permite completa interoperabilidade 
	para \english{middleware} orientado a mensagens. A especificação define não somente o protocolo de rede, mas também a semântica dos serviços do
	da aplicação servidora. Também é parte do foco que capacidades providas por sistemas de \english{middleware}
	orientados a mensagem possam estar pervasivamente disponíveis nas redes das empresas, incentivando o desenvolvimento de
	aplicações interoperáveis baseadas em troca de mensgens\cite{amqp-spec}.
	
	\par Os componentes principais do modelo AMQP são: 
	\begin{itemize}
	\item Servidor: É o processo,  conhecido também como \english{broker}, que aceita conexões de clientes e implementa as funções de
          filas de mensagens e roteamento.
	  
	\item Filas: São entidades internas do servidor que armazenam as mensagens, tanto em memória quanto em disco,
	  até que elas sejam enviadas em sequência para as aplicações consumidoras. As filas são totalmente independentes umas das outras. 
          Na criação de uma fila, várias propriedades podem ser especificadas:
	  a fila de ser pública ou privada, armazenar mensagens de modo durável ou transiente, e ter existência permanente ou temporária 
          (e.g.: a existência da fila é vinculada ao ciclo de vida de uma aplicação consumidora). 
          A combinação de propriedades como essas viabiliza a criação de diversos tipos de fila, como por exemplo: 
          fila armazena-e-encaminha (\english{store-and-forward}), 
	  que armazena as mensagens e as distribui para vários consumidores na forma \english{round-robin}, 
	  fila temporária para resposta, que armazena as mensagens e as encaminha para um  único consumidor; 
	  e fila \english{pub-sub}, que armazena mensagens provenientes de vários produtores e as envia para um único consumidor.
	  
	\item \english{Exchanges}: São entidades internas do servidor que recebem e roteiam as mensagens das aplicações produtoras
	  para as filas, levando em conta critérios pré-definidos (\english{bindings}). Essas entidades inspecionam
	  as mensagens, verificando, na maioria dos casos, a chave de roteamento presente no cabeçalho de cada mensagem. 
          Com o auxílio da tabela de \english{bindings}, uma \english{exchange} decide como encaminhar as mensagens às respectivas filas,
          jamais armazenado mensagens.
	  
	\item \english{Bindings}: São relacionamentos entre \english{exchanges} e filas. Esses relacionamentos definem como
	  deverá ser feito o roteamento das mensagens.
	  
	\item \english{Virtual hosts}: São coleções de \english{exchanges}, filas e objetos associados. \english{Virtual hosts}
	  são domínios independentes no servidor e compartilham um ambiente comum para autenticação e segurança. As aplicações
	  clientes escolhem um \english{virtual host} após se autenticarem no servidor.		  		
	\end{itemize}	
	
	\par A figura~\ref{fig:amqp_overview} mostra os componentes acima descritos e os relacionamentos entre esses componentes. 
	\vspace{1ex}
	\begin{figure}[hbtp]
	  \centering
	  \includegraphics{imagens/amqp-overview.eps}
	  \caption{Visão geral dos componentes do modelo AMQP.}
	  \label{fig:amqp_overview}
	\end{figure}
        
	\par Em modelos pré-AMQP,  as tarefas das \english{exchanges} e das filas eram feitas por blocos
        monolíticos que implementavam tipos específicos de
	roteamento e armazenamento. O modelo AMQP separa essas tarefas e as atribui a entidades distintas (\english{exchanges} e filas), que têm os seguintes
	papéis: \entry{(i)} receber as mensagens e fazer o roteamento para as filas; \entry{(ii)} armazenar as mensagens e fazer o
	encaminhamento para as aplicações consumidoras. Vale frisar que filas, \english{exchanges} e \english{bindings} podem ser criados tanto
	de modo programático como por meio de ferramentas administrativas.
	
	\par Há uma analogia entre o modelo AMQP e sistemas de email:
	\begin{enumerate}
	\item Uma mensagem AMQP é análoga a uma mensagem de \english{email}.
	\item Uma fila é análoga a uma caixa de mensagens.
	\item Um consumidor corresponde a um cliente de \english{email} que carrega e apaga as mensagens.
	\item Uma \english{exchange} corresponde a um \english{mail transfer agent} (MTA) que inspeciona as mensagens e, 
	  com base nas chaves de roteamento, 
	  verifica as tabelas de registro e decide como enviar as mensagens para uma ou mais caixas de mensagens. 
          No caso do correio eletrônico as chaves de roteamento são os campos de destinatário e cópias (To, Cc e Bcc).
	\item Um \english{binding} corresponde a uma entrada nas tabelas de roteamento do MTA.
	\end{enumerate}
        
        \par Para enviar uma mensagem, uma aplicação produtora especifica uma determinada \english{exchange} de um determinado
        \english{virtual host}, uma rotulação com informação de roteamento e eventualmente algumas propriedades adicionais, bem
        como os dados do corpo da mensagem. Uma vez que a mensagem tenha sido recebida no servidor
	AMQP, ocorre o roteamento para uma ou mais filas do conjunto de filas do \english{virtual host} especificado. 
        No caso de não ser possível rotear a mensagem, seja qual for
	o motivo, as opções  são: rejeitar a mensagem, descartá-la silenciosamente, ou ainda fazer o
	roteamento para uma \english{exchange} alternativa. A escolha depende do comportamento definido pelo produtor. Quando a mensagem
	é depositada em alguma fila (ou possivelmente em algumas filas), a fila tenta repassá-la imediatamente para a aplicação consumidora.
	Caso isso não seja possível, a fila mantém a mensagem armazenada para uma futura tentativa de entrega. Uma vez que a mensagem foi entregue com sucesso
	a um consumidor, ela é removida da fila. A figura~\ref{fig:amqp-message-flow} mostra o envio e recebimento de uma mensagem.
        
	\vspace{1ex}
	\begin{figure}[hbtp]
	  \centering
	  \includegraphics{imagens/amqp-message-flow.eps}
	  \caption{Visão geral do fluxo de uma mensagem desde o produtor até o seu consumidor.}
	  \label{fig:amqp-message-flow}
	\end{figure}
        
	\par A aceitação ou confirmação de recebimento de uma mensagem fica a critério da aplicação consumidora, podendo acontecer
	imediatamente depois da retirada da mensagem da fila ou após a aplicação consumidora ter processado a mensagem.
        %% ou na efetivação da transação que retirou a mensagem da fila.
	
        \subsection{Atores no projeto Akka}
	\par Apesar do modelo de atores ser bem definido, não existe uma padronização para a sua implementação. 
	De acordo com o modelo, o processamento das mensagens deve ser desacoplado do envio. 

        \par Os atores do Akka podem ser locais ou remotos. O termo ``ator local'' é usado para denotar um ator que pode receber mensagens apenas de atores
        residentes na mesma máquina virtual. Por outro lado, um ator remoto pode receber mensagens de quaisquer outros atores, inclusive daqueles 
        residentes em outras máquinas virtuais. Em outras palavras, o termo ``ator remoto'' é um sinônimo de ``ator remotamente acessível''.

        \par Nas próximas duas sub-seções examinaremos a implementação de atores do projeto Akka. 
        Mostraremos a criação e o uso de atores locais ou remotos, bem como o fluxo de uma mensagem (envio,
        tráfego e processamento da mensagem) tanto no caso local como no remoto.

        
        \subsubsection{Atores locais}
	\par A criação de atores locais pode acontecer tanto por meio uma sub-classe de \texttt{Actor}
	provendo uma implementação para o método \texttt{receive}, como mostrado na listagem~\ref{lst:subclass-actor}, 
	quanto via chamadas ao método \texttt{actor} da própria classe \texttt{Actor}, 
        como mostrado na listagem~\ref{lst:anonym-actor}. Note que no segundo caso o ator criado é uma instância de uma classe anônima, e que 
        não é necessário chamar explicitamente o método \texttt{start} para inicializá-lo.
        
        \begin{listing}
          \scriptsize
          \lstset{language=Java}
          \begin{lstlisting}[numbers=left]
            import se.scalablesolutions.akka.actor.Actor._
	    
            class MyActor extends Actor {
	      def receive = {
		case "test" => println("received test")
		case 	  _ => println("received unknown message")
	      }
            }
	    
            val myActor = actorOf[MyActor].start
            myActor ! "test"
          \end{lstlisting}
          \caption{Criação e uso da classe \texttt{MyActor}.}
          \label{lst:subclass-actor}
        \end{listing}
        
        \begin{listing}
          \scriptsize
          \lstset{language=Java}
          \begin{lstlisting}[numbers=left]
            import se.scalablesolutions.akka.actor.Actor._
	    
            val myActor = actor {
	      case "test" => println("received test")
	      case	_ => println("received unknown message")
            }
	    
            myActor ! "test"
          \end{lstlisting}
          \caption{Criação e uso de ator anônimo.}
          \label{lst:anonym-actor}
        \end{listing}
        
	\par Uma vez que uma mensagem foi enviada para um ator, ela é colocada sincronamente na fila de mensagens do ator, 
	em tempo $O(1)$. 
	As mensagens enfileiradas são então despachadas assincronamente para a função parcial definida no 
	bloco \texttt{receive}, como mostrado na figura~\ref{fig:local-actor-message}. 
        Por padrão, atores são criados com um despachador que é impulsionado por eventos e que utiliza um \english{thread pool} para despachar
        as mensagens. Cada vez que uma mensagem é adicionada na fila de um ator, uma tarefa de despachamento é criada e colocada
        na fila de processamento do \english{thread pool}. É possível a definição e utilização de outros tipos de despachadores para se 
        obter melhores resultados em casos específicos\cite{akka-dispatchers}.
        
	\vspace{1ex}
	\begin{figure}[hbtp]
	  \centering
	  \includegraphics{imagens/local-actor-message.eps}
	  \caption{Envio e despacho de mensagens para atores locais.} 
	  \label{fig:local-actor-message}
	\end{figure}
        
        \subsubsection{Atores remotos}
        \label{sec:atores_remotos_akka}
        \par No contexto de um envio de mensagem para um ator remoto, o termo cliente se refere à entidade que está enviando
        a mensagem. O termo servidor denota o processo (máquina virtual) no qual reside o ator remoto. A infra-estrutura de atores
        remotos utiliza os seguintes elementos:

	
        \begin{itemize}
	\item \texttt{RemoteActor}: Sub-classe de \texttt{Actor} que torna conveniente a criação de um ator remoto, 
	  ao invés de se criar explicitamente um ator local e torná-lo remoto.
	  
	\item \texttt{RemoteServer}: É um componente usado no lado do servidor. Tem como responsabilidade
	  manter registrados os atores, bem como encaminhar a eles as mensagens recebidas de
	  clientes remotos. Cada \texttt{RemoteServer} é associado a um \english{host} e a uma porta TCP. Um mesma máquina virtual 
          pode conter múltiplos \texttt{RemoteServer}s.
	  
	\item \texttt{RemoteNode}: Objeto \english{singleton} que é instância de \texttt{RemoteServer}. Não possui nenhum comportamento adicional e
	  é usado quando se deseja ter um único \texttt{RemoteServer} numa dada máquina virtual.
	  
	\item \texttt{Cluster}: Abstração para se agrupar instâncias de \texttt{RemoteServer}. Permite que um cliente
          interaja com múltiplos \texttt{RemoteServer}s, por exemplo via \english{broadcasts} de mensagens;
	  
	\item \texttt{RemoteClient}: É um componente usado pelo cliente. Tem como responsabilidade 
	  visível oferecer uma interface para obtenção de referências a atores remotos. 
          Oferece também suporte em tempo de execução para a infra-estrutura de atores do lado do cliente, provendo uma série de
          serviços não vísiveis para o usuário, tais como: \entry{(i)} seriação de mensagens; \entry{(ii)} envio de mensagens para atores remotos; 
          \entry{(iii)} conversão de ator local em ator remoto; \entry{(iv)} intermediação de mensagens de resposta vindas do \texttt{RemoteServer}, 
          no caso envios via \texttt{!!} ou \texttt{!!!}.
	\end{itemize}
	
        \par A figura~\ref{fig:remote-actor-diagram} mostra os elementos acima descritos e os relacionamentos entre esses elementos.
	A criação de atores remotos pelo cliente é análoga a de atores locais, salvo o fato de se informar
	o \english{host} e porta de um \texttt{RemoteServer} já em execução. A listagem ~\ref{lst:subclass-actor-remote} mostra a criação por meio de 
        uma sub-classe de \texttt{RemoteActor}. Vale destacar que, nesta listagem, o valor de \texttt{myRemoteActor} (linha $12$) é um \english{proxy} local para
        %% conferir se tem acento ^ em converte-lo
        o ator remoto. Outra possibilidade é criar um ator local e posteriormente converte-lo em remoto, por meio de uma chamada ao 
        método \texttt{makeRemote(host, port)} (listagem~\ref{lst:make-remote-of-local-actor}). Tal chamada deve ocorrer anteriormente
        à ativação do ator via chamada ao método \texttt{start}.
        	
	\par A criação de atores remotos pelo servidor, por sua vez, é exatamente igual a de atores locais, mostram as 
        listagens~\ref{lst:subclass-actor} e~\ref{lst:anonym-actor}. Depois de criar o ator localmente,
	basta registrá-lo em um \texttt{RemoteServer} ou \texttt{RemoteNode}, como mostra a listagem~\ref{lst:registering-actor}. 
        A maneira com que o cliente remoto busca pelo ator e envia uma mensagem pode ser vista na listagem~\ref{lst:using-remote-actor}.
        
        \begin{listing}
          \scriptsize
          \lstset{language=Java}
          \begin{lstlisting}[numbers=left]
            import se.scalablesolutions.akka.actor._
            import se.scalablesolutions.akka.actor.Actor._
            import se.scalablesolutions.akka.remote._
            
            class MyRemoteActor extends RemoteActor("localhost",15092) {
	      def receive = {
		case   "Hi" => println("hello")
		case 	  _ => println("received unknown message")
	      }
            }
            
            val myRemoteActor = actorOf[MyRemoteActor].start
            myRemoteActor ! "Hi"
          \end{lstlisting}
          \caption{Criação e uso da classe \texttt{MyRemoteActor}.}
          \label{lst:subclass-actor-remote}
        \end{listing}
        
        \begin{listing}
          \scriptsize
          \lstset{language=Java}
          \begin{lstlisting}[numbers=left]
            import se.scalablesolutions.akka.actor.Actor._
	    
            class MyActor extends Actor {
	      def receive = {
		case "test" => println("received test")
		case 	  _ => println("received unknown message")
	      }
            }
	    
            val myActor = actorOf[MyActor]
            myActor.makeRemote("localhost", 15092)
            myActor.start
            myActor ! "test"
          \end{lstlisting}
          \caption{Uso de \texttt{makeRemote} em atores locais.}
          \label{lst:make-remote-of-local-actor}
        \end{listing}
        
        
        \begin{listing}
          \scriptsize
          \lstset{language=Java}
          \begin{lstlisting}[numbers=left]
            RemoteNode.start("localhost", 15092)
            RemoteNode.register("my-actor", myActor)
          \end{lstlisting}
          \caption{Registro de um ator local em um nó.}
          \label{lst:registering-actor}
        \end{listing}
        
        
        \begin{listing}
          \scriptsize
          \lstset{language=Java}
          \begin{lstlisting}[numbers=left]
	    val myActor = RemoteClient.actorFor("my-actor", "localhost", 15092)
	    myActor ! "Hi"
          \end{lstlisting}
          \caption{Cliente acessando o ator remoto \texttt{myActor}.}
          \label{lst:using-remote-actor}
        \end{listing}
        
        \vspace{1ex}
        \begin{figure}[hbtp]
          \centering
          \includegraphics[scale=.95]{imagens/remote-actor-diagram.eps}
          \caption{Disposição dos elementos da infra-estrutura de atores remotos.} 
          \label{fig:remote-actor-diagram}
        \end{figure}
        
        \par Quando um cliente envia uma mensagem a um ator remoto, o \english{proxy} local embrulha a mensagem,
        adicionando a ela informações de cabeçalho necessárias para o envio. O \english{proxy} usa um  \texttt{RemoteClient}
        para enviar a mensagem ao \texttt{RemoteServer} correspondente. Este processo de envio, do ponto de vista do cliente
        leva tempo $O(1)$, já que a seriação da mensagem é feita de modo assíncrono.
        
        \par A figura~\ref{fig:remote-actor-message-flow} mostra o caminho que a mensagem faz saindo da aplicação cliente
        via \english{proxy} e sendo repassada para um \texttt{RemoteClient}, que por sua vez faz a seriação assíncrona
        da mensagem e a envia para o \texttt{RemoteServer} correspondente. Uma vez que a mensagem tenha sido recebida pelo \english{handler} plugado 
        ao JBoss Netty no lado servidor, o \english{handler} examina as informações de cabeçalho, localiza o ator destinatário no
        registro local de atores e encaminha a mensagem a caixa de mensagens do ator, como se o envio fosse local. O despachador associado 
        ao ator faz o tratamento mostrado na figura~\ref{fig:local-actor-message}, já que do ponto de vista do despachador não há diferença 
        entre um envio local e um remoto.

        \par Em alguns casos, o processamento deve gerar uma mensagem de resposta, como por exemplo um resultado futuro ou uma mensagem
        de erro para um ator supervisor. Em tais casos a mensagem de resposta faz o caminho contrário, indo do \texttt{RemoteServer} para
        o \texttt{RemoteClient}, onde analogamente o \english{handler} faz o repasse da resposta para quem a estiver aguardando.
        
        \vspace{1ex}
        \begin{figure}[hbtp]
          \centering
          \includegraphics[scale=.9]{imagens/remote-actor-message-flow.eps}
          \caption{Fluxo de envio de mensagens para atores remotos.} 
          \label{fig:remote-actor-message-flow}
        \end{figure}	
        
        \section{O projeto}
        \label{sec:projeto}
        \par Criaremos uma versão modificada do Akka, na qual o envio de mensagens para atores
        remotos seja feito via AMQP. O mecanismo de transporte atualmente utlizado pelo
        Akka é o JBoss Netty, baseado em \english{sockets}. Nossa proposta é substituir esse mecanismo de transporte por um 
        \english{message broker} AMQP. Isso implica na substituição de todos os componentes
        associados ao JBoss Netty (\english{bootstraps} e \english{handlers}).
        
        \par Optamos por basear nosso projeto na implementação de atores do Akka, ao invés da implementação presente 
        na distribuição de Scala, pois a implementação do Akka é mais abrangente e, em nossa avaliação, mais robusta. Sobre a escolha 
        do \english{broker} AMQP, consideramos como opções RabbitMQ\cite{rabbitmq} e Apache Qpid\cite{qpid}.
        Como a especificação AMQP não define uma API para as aplicações clientes, o código a ser desenvolvido será específico
        para um desses \english{message brokers}.
        
        
% ----------------------------------------------------------------------
%\newpage
\section{Próximas etapas}
\label{sec:cronograma}
\subsection{Atividades programadas}
\par Apresentamos a seguir uma lista com as próximas atividades:

\begin{enumerate}
\item análise dos \english{brokers} AMQP para definição do que será usado;
\item análise de desenvolvimento do código necessário para o transporte das mensagens para atores remotos utilizando AMQP;
\item desenvolvimento de testes, refatoração e aprimoramento da implementação;
\item elaboração e execução de cenários de experimento para comparação entre as implementações de atores remotos com JBoss Netty e AMQP;
\item redação da dissertação;
\item redação de artigo;
\item defesa.
  
\end{enumerate}

\subsection{Cronograma}
O cronograma para as próximas atividades:

\newcommand{\x}{$\bullet$}
\begin{center}
  
  \textbf{2010/2011}
  
  \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
    \hline
    & nov & dez & jan & fev & mar & abr & mai & jun & jul \\ \hline
    1 & \x  &     &     &     &     &     &     &     &     \\ \hline
    2 &     & \x  & \x  & \x  &     &     &     &     &     \\ \hline
    3 &     &     & \x  & \x  & \x  &     &     &     &     \\ \hline
    4 &     &     &     &     & \x  & \x  &     &     &     \\ \hline
    5 &     &     &     &     & \x  & \x  & \x  & \x  &     \\ \hline
    6 &     &     &     &     &     &     &     & \x  & \x    \\ \hline
    7 &     &     &     &     &     &     &     &     & \x  \\ \hline
  \end{tabular}
  
\end{center}

\newpage
\bibliographystyle{plain}
\bibliography{referencias}
\end{document}
