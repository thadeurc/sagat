\documentclass[titlepage,11pt,letterpaper,abstracton]{scrartcl}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{cite}
\usepackage{url}
\usepackage{indentfirst}
\usepackage{graphicx,url}
\usepackage{epsfig}


\setlength{\topmargin}{0.5in}
\setlength{\oddsidemargin}{0in}%{0.3in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{8in}
\setlength{\parindent}{0.4in}

% Ajusta o cabeçalho e o rodapé.
\pagestyle{fancy}
\lhead{DCC - IME - USP}
\chead{}
\rhead{\textbf{Proposta de Dissertação -- Mestrado}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}
\setlength{\headheight}{13.6pt}

\newlength{\fmwidth}
\setlength{\fmwidth}{\textwidth}
\addtolength{\fmwidth}{-.1in}

% Algumas macros.
\newsavebox{\fmbox}
\newenvironment{fmpage}[0]
    {\begin{lrbox}{\fmbox}\begin{minipage}{\fmwidth}}
    {\end{minipage}\end{lrbox}\vspace{2em}\noindent\fbox{\usebox{\fmbox}}\vspace{2em}}

\newcommand{\code}[1]
    {\texttt{#1}}

\newcommand{\accentuate}[1]
    {\textsf{#1}}

\newcommand{\entry}[1]
    {\textit{#1}}

\newcommand{\english}[1]
    {\textit{#1}}


\begin{document}

\begin{titlepage}

  \begin{center}
    \rule{\textwidth}{1pt} \\[3mm]
    \textbf{\LARGE Universidade de São Paulo} \\[5mm]
    \textbf{\Large Instituto de Matemática e Estatística} \\[3mm]
    \textbf{\Large Departamento de Ciência da Computação} \\[3mm]
    \rule{\textwidth}{1pt} \\[30mm]
    
    \textbf{\textsf{\LARGE AMQP para o Transporte de Mensagens entre Atores Remotos}}
    \\[10mm]
    \textbf{\Large Exame de Qualificação de Mestrado} \\[20mm]
    {\large São Paulo, XX de XXXXX de 2010}\\[10mm]
    \rule{\textwidth}{1pt}\\[7mm]

    \textsf{\Large Thadeu de Russo e Carmo}\\[10mm]
    \textsc{\Large Orientador:}\\[5mm]
    \textsf{\Large Francisco Carlos da Rocha Reverbel}\\[5mm]
    \rule{\textwidth}{1pt}\\[5mm]
   \end{center}

\end{titlepage}


\pagenumbering{roman}
\begin{abstract}
 	\par Modelar sistemas computacionais especificando tarefas que podem acontecer de maneira independente, 
	em paralelo, e concorrentemente é algo extremamente comum, especialmente quando se busca performance. 
	O modelo de atores com troca de mensagens foi proposto como uma das possíveis soluções para os problemas 
	oriundos da programação concorrente, como o uso de travas e blocos sincronizados para a proteção de dados 
	compartilhados. Atores são entidades baseadas em \english{threads} que possuem uma caixa de correio para o 
	recebimento e armazenamento das mensagens enviadas por outros atores para processamento assíncrono.

	\par Neste trabalho estudaremos o modelo de atores em um ambiente com instâncias distribuídas entre várias
	máquinas virtuais Java. Faremos uma implementação em Scala tomando como base a abordagem proposta no projeto AKKA, 
	substituindo o uso de \english{sockets} escolhido para o tráfego das mensagens, pelo padrão aberto voltado à
	\english{middleware} orientado a mensagens, \english{Advanced Message Queuing Protocol}, ou AMQP. 
	Além disso, faremos um comparativo entre as duas abordagens.
 

\end{abstract}

\tableofcontents
\newpage

\pagenumbering{arabic}

\normalsize
\onehalfspacing


% ----------------------------------------------------------------------
\newpage
\section{Introdução}
	Performance e escalabilidade são necessidades fundamentais e quase sempre obrigatórias para qualquer sistema 
	computacional. Bons ganhos de performance podem ser obtidos, por exemplo, encontrando soluções alterativas para 
	se obter o mesmo resultado com uma menor complexidade computacional, algo que nem sempre é possível ou viável do 
	ponto de vista de desenvolvimento de algoritmos. Escalabilidade pode ser obtida através do uso de computadores com 
	maior poder de processamento, algo que também nem sempre é viável por questões de custo. Uma alternativa para se alcançar 
	tanto performance quanto escalabilidade, é o uso de vários computadores com processadores de menor capacidade de 
	processamento, ou ainda o uso de processadores com múltiplos núcleos. Em ambos os casos estará implícito a necessidade 
	e capacidade de execuções paralelas e concorrentes, de modo a existir uma interação significativa entre as tarefas e 
	os processos executados\cite{dijkistra-65}.

	\par Ultimamente, problemas relacionados ao desenvolvimento de sistemas com características concorrentes, como 
	\english{deadlocks} e exclusão mútua\cite{dijkistra-mutual-exclusion}, tem recebido enorme interesse por conta tanto 
	da popularização de processadores com múltiplos núcleos, como da computação distribuída e \english{web-services} serem 
	inerentemente concorrentes. 	

	\par A abordagem convencional no desenvolvimento deste tipo de sistemas é através do uso de travas e variáveis condicionais. 
	Em linguagens orientadas a objetos, como Java e C\#, cada instância de um objeto possui implicitamente sua própria trava e 
	travamentos podem acontecer em blocos sincronizados dentro de métodos. Esta abordagem contudo, não permite a componibilidade 
	de travas de maneira segura, necessária quando se existe mais de uma instância envolvida na ação a ser executada de modo 
	exclusivo, criando uma situação fatalmente propensa a \english{deadlocks}. Existem ainda outras dificuldades no uso de travas, 
	como o esquecimento de se obter a trava de alguma instância, obtenção excessiva de travas, obtenção de travas de instâncias erradas, 
	obtenção de travas em ordem errada, se manter o sistema consistente na presença de erros ou ainda o esquecimento da sinalização 
	em variáveis de condição ou de se testar novamente uma condição após o despertar de um estado de espera \cite{sj:bc}, 
	mostrando a inviabilidade desta abordagem para uma programação modular, ou seja, criação de grandes programas através 
	de vários programas menores.
	
	\par Duas abordagens para os problemas citados são a memória transacional, uma abstração para compartilhamento 
	seguro de uma mesma região de memória, e o uso do modelo de atores, baseado na troca de mensagens entre processos, não existindo 
	compartilhamento de área comum de memória. 
	
	%% todo: melhorar parte de stm?  Colocar codigo haskell ou outro exemplo?

	\par Conhecida como STM\cite{STM} (\english{Software Transactional Memory}), é um mecanismo de controle de
	concorrência análogo às transações de bancos de dados para o controle de acesso à memória compartilhada. Neste contexto, 
	a transação é um pedaço de código que executa uma série de operações atômicas de leitura e escrita na memória compartilhada. 


	%% preciso 'vender' mais erlang? falar dos 'problemas' de erlang (popularidade de vm), e justificar o pq de scala?
	\par Atores\cite{gul-agha} são basicamente processos concorrentes que se comunicam através da troca de mensagens de modo assíncrono.
	Quando combinado com o casamento de padrões, modelos de processos baseados em atores se mostraram muito efetivos, como por exemplo,
	Erlang\cite{erlang-survey}. Um ator pode responder a uma mensagem assíncrona seja criado novos atores, enviando mensagens 
	para atores conhecidos (incluindo o próprio), ou alterando seu comportamento. Comportamento este que define como o ator 
	respondera a próxima mensagem que ele recebe\cite{haller-master}.Na linguagem Scala, um ator é uma entidade como uma 
	\english{thread} que possui uma caixa de correio para o recebimento	de mensagens. A criação de atores em Scala\cite{prog-scala} 
	foi baseada no modelo de Erlang\cite{erlang-dev}. Para enviar uma mensagem \code{msg} para um ator \code{a}, usa-se a 
	expressão \code{a ! msg}. A operação de recebimento segue o seguinte formato: \\
	\\
	\begin{fmpage}
		\small{
			\begin{verbatim}
				receive {
				    case padrao_1 => acao_1
				    ...
				    case padrao_n => acao_n
				}
			\end{verbatim}		
		}
	\end{fmpage}	
	\par A primeira mensagem que casar com qualquer dos padrões $padrao_i$ é removida da caixa de correio, e a ação $acao_i$ correspondente é
	executada. Caso não haja casamento de nenhum dos padrões, o ator é suspendido.
	% falar sobre como criar os atores? Falar dos outros tipos de envios? !!, !? !!!

	\par A linguagem Scala possui embutida na distribuição uma implementação de atores, chamada de \english{Scala Actors} com 
	suporte para atores remotos\cite{scala-api}. Esta biblioteca permite que se inicialize atores como serviços remotos associados 
	a portas TCP. Em \cite{ping-pong-local} podemos ver um exemplo de uma implementação de \english{ping-pong} entre atores locais. 
	O mesmo exemplo com atores remotos pode ser visto em \cite{ping-pong-remoto}. Existem ainda algumas implementações alternativas 
	que se propõe a dar este tipo de suporte, tal como o projeto AKKA\cite{akka}, que foi originado pelo descontinuado Scala OTP, 
	cujo objetivo era de se portar as idéias do Erlang OTP para a linguagem Scala, possui maior robustez, mais funcionalidades e uma API 
	mais simples para se trabalhar com atores remotos, usando também a abordagem com portas TCP para a disponibilização dos 
	serviços aos clientes remotos. %citar codigo do akka? LIft actors?

	\par Dentro do projeto AKKA existe um módulo adicional\cite{akka-amqp} que abstrai a criação de produtores e consumidores 
	AMQP como sendo atores. AMQP\cite{amqp-spec} (\english{Advanced Message Queuing Protocol}) é um protocolo de internet aberto 
	para mensageria corporativa. Especificado pelo AMQP \english{Working Group}, o protocolo permite completa interoperabilidade 
	para \english{middleware} orientado a mensagens, sendo ambos o protocolo de rede como a semântica dos serviços do \english{broker} 
	definidos por ele.
	
\subsection{Objetivos}
	\par Os dois principais objetivos deste trabalho são:
	\begin{enumerate}
		\item A implementação do modelo de atores remotos com o uso de AMQP para o transporte das mensagens: tomaremos 
		como base a implementação feita pelo projeto AKKA\footnote{O trabalho sera desenvolvido tendo como base a última 
		versão estável disponível para \english{download} no site do projeto.} de atores remotos e substituiremos o mecanismo
		existente para o transporte de mensagens, que atualmente é feito pelo JBoss Netty \cite{jboss-netty}. Utilizaremos o 
		RabbitMQ\cite{rabbitmq}, uma implementação em Erlang da especificação AMQP, como o mecanismo para cuidar do transporte 
		das mensagens.
		
		\item A comparação das duas implementações: será feito um comparativo do resultado de ambos as implementações para 
		avaliar a robustes e escalabilidade de cada uma, as vantagens proporcionadas em uma possível implantação num ambiente
		real, como segurança e infra-estrutura além de uma análise da sobrecarga imposta pelo uso de AMQP em relação ao uso de
		portas TCP com o intuito de observar a viabilidade do uso desta implementação.
		
	\end{enumerate}	
	
\subsection{Organização do texto}
TODO: Colocar a descricao dos capitulos no termino.
% ----------------------------------------------------------------------------
\newpage
\section{Trabalhos relacionados}
	\par Esta seção apresenta os trabalhos relacionados que foram estudados e contribuíram para o desenvolvimento
	do nosso trabalho. Dividiremos essa seção em três partes. Na primeira parte apresentaremos a linguagem Erlang
	e seu modelo de atores remotos; na segunda e na terceira parte apresentaremos o modelo de atores distribuídos
	da linguagem Scala e do projeto AKKA. Nesta última, mostraremos também dois modulos adicionais do projeto sobre
	atores remotos: AMQP e Camel.
	
\subsection{Atores remotos em Erlang}
	\par Erlang\cite{erlang-dev} é uma linguagem funcional e interpretada para programação concorrente projetada para
	o desenvolvimento de sistemas distribuídos de larga escala de tempo real, tendo sido desenvolvida nos laboratórios 
	da Ericsson no período de 1985 à 1997. A linguagem em si, apesar de bem enxuta, possui conceitos interessantes em 
	sua estrutura para simplificar o desenvolvimento de sistemas com características concorrentes. Exemplos destes 
	conceitos são: variáveis de atribuição única, átomos, casamento de padrões e as primitivas \english{spawn} para 
	criação de processos, \english{send} ou \emph{!} para o envio de mensagens entre os processos e \english{receive} 
	para o recebimento de mensagens que foram enviadas para o processo.

	\par A criação de processos através de outros processos pode criar uma hierarquia de dependência entre eles, o que pode
	implicar na necessidade de supervisão. Erlang possui embutido na linguagem algumas funções como \english{link} para a 
	construção desta hierarquia de dependências, de modo que processos criadores podem definir ligações para serem notificados 
	de términos tanto esperados, quando inesperados dos processos filhos. Estas notificações podem, eventualmente forçar um
	término do processo criador, ou apenas notificá-lo para que outras ações sejam tomadas.
	
	\par Uma vez que as máquinas virtuais Erlang, que uma vez nomeadas são chamadas de nós,  estão em execução nas 
	diferentes máquinas de uma rede de computadores, os respectivos nós conectados e os fontes do código a ser 
	executado como descrito em\cite{prog-erlang}, a criação de processos em nós remotos é semelhante a criação de 
	processos locais e é feita pela função \english{spawn}, porém informando não só a função a ser executada mas 
	também o nome do nó remoto. No modelo construído em Erlang, o tráfego das mensagens é feito através de portas TCP e UDP.
	\\
	\\
	\begin{fmpage}
		\small{
			\begin{verbatim}
				-module(sample_remoto).
				-export([start/0]).
					
				start() ->
				    Pid = spawn(node1@machine1.ime.usp.br, 
					            fun() -> loop() end).
				loop() ->
				    receive
				        {ProcId, {soma, Lista}} ->
				            ProcId ! {resultado, somatorio(Lista)};
						{ProcId, Msg} ->
				            ProcId ! {erro, mensagem_desconhecida, Msg}
					end,
					loop().
				
				somatorio(Lista) ->
				    somatorio_aux(Lista,0).

				somatorio_aux([], Acumulador) ->
				    Acumulador;

				somatorio_aux([Cabeca|Cauda], Acumulador) ->
				    somatorio_aux(Cauda, Cabeca + Acumulador).
					
			\end{verbatim}		
		}
	\end{fmpage}
\newpage
\section{Transações distribuídas em ambientes Web services}
\section{O projeto}
% ----------------------------------------------------------------------
\newpage
\section{Próximas etapas}
\subsection{Atividades programadas}
\subsection{Cronograma}
\bibliographystyle{plain}
\bibliography{referencias}
\end{document}
